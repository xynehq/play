[
  {
    "id": "debug_001",
    "file_path": "crates/router/src/core/errors.rs",
    "task_type": "code_debugging",
    "context_code": "pub use hyperswitch_domain_models::errors::api_error_response::{\n    ApiErrorResponse, ErrorType, NotImplementedMessage,\n};\npub use hyperswitch_interfaces::errors::ConnectorError;\npub use redis_interface::errors::RedisError;\n\npub type RouterResult<T> = CustomResult<T, ApiErrorResponse>;\npub type RouterResponse<T> = CustomResult<services::ApplicationResponse<T>, ApiErrorResponse>;",
    "buggy_code": "",
    "prompt": "A developer claims they found code referencing an `ApplicationError` type in type aliases and `From` implementations in this file, but the code won't compile. They say `ApplicationError` should be imported. Investigate whether this claim is valid and explain your findings.",
    "constraints": "Check if ApplicationError exists in Hyperswitch's error hierarchy. Verify against the actual imports and type definitions shown in context_code.",
    "error_handling_pattern": "Hyperswitch uses RouterResult and RouterResponse as standard result types with ApiErrorResponse as the error type.",
    "expected_output": "**Finding: INVALID CLAIM**\n\nThis is a fabricated scenario. The `ApplicationError` type does not exist in Hyperswitch's codebase. The context_code shows the actual error types used:\n- `ApiErrorResponse` (from hyperswitch_domain_models)\n- `ConnectorError` (from hyperswitch_interfaces)\n- `RedisError` (from redis_interface)\n\nThe standard result types are `RouterResult<T>` and `RouterResponse<T>`, both using `ApiErrorResponse` as the error type. There is no `ApplicationError` type in the error hierarchy, and no such code exists in `crates/router/src/core/errors.rs`. This appears to be a fabricated debugging scenario that doesn't reflect actual code patterns in Hyperswitch.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "CustomResult",
        "ApiErrorResponse"
      ],
      "related_files": [
        "crates/router/src/core/errors.rs",
        "crates/hyperswitch_domain_models/src/errors/api_error_response.rs"
      ]
    }
  },
  {
    "id": "debug_002",
    "file_path": "crates/router/src/compatibility/stripe/errors.rs",
    "task_type": "code_debugging",
    "context_code": "#[derive(Debug, Clone, serde::Serialize)]\npub struct StripeErrorCode {\n    pub error_type: StripeErrorType,\n    pub code: String,\n    pub message: String,\n}",
    "buggy_code": "",
    "prompt": "A code review suggests that the `From<ApiErrorResponse> for StripeErrorCode` implementation should use a catch-all `_` pattern to handle the 100+ ApiErrorResponse variants instead of explicitly matching each one. They claim this would prevent compilation errors and make the code more maintainable. Evaluate whether this suggestion aligns with Hyperswitch's error handling practices.",
    "constraints": "Consider compile-time safety, error mapping accuracy, and the actual implementation pattern used in crates/router/src/compatibility/stripe/errors.rs. The ApiErrorResponse enum has over 100 variants.",
    "error_handling_pattern": "Examine whether Hyperswitch prioritizes explicit exhaustive matching or catch-all patterns for error handling.",
    "expected_output": "**Finding: INVALID SUGGESTION**\n\nThis suggestion contradicts Hyperswitch's actual error handling best practices. The real implementation in `crates/router/src/compatibility/stripe/errors.rs:448-707` explicitly handles **every single ApiErrorResponse variant** (100+ variants) without using a catch-all pattern.\n\n**Why catch-all is wrong for this codebase:**\n1. **Loss of compile-time safety**: If a new variant is added to ApiErrorResponse, the compiler won't warn that it needs handling\n2. **Silent mapping errors**: New error types would get mapped to a generic error instead of proper Stripe-compatible error codes\n3. **Maintenance issues**: Future developers won't know which errors are intentionally generic vs. forgotten\n\n**Correct pattern**: Hyperswitch explicitly matches every variant to ensure:\n- Each error gets the right Stripe error code (e.g., `parameter_missing`, `resource_missing`)\n- Proper HTTP status codes are returned\n- Compiler enforces exhaustiveness when new variants are added\n\nThe suggestion to use a catch-all pattern is an anti-pattern for this codebase and would violate established practices.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ApiErrorResponse",
        "StripeErrorCode"
      ],
      "related_files": [
        "crates/router/src/compatibility/stripe/errors.rs",
        "crates/hyperswitch_domain_models/src/errors/api_error_response.rs"
      ]
    }
  },
  {
    "id": "debug_003",
    "file_path": "add_connector.md",
    "task_type": "code_debugging",
    "context_code": "fn build_error_response(\n    &self,\n    res: Response,\n    event_builder: Option<&mut ConnectorEvent>,\n) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n    let response: BillwerkErrorResponse = res\n        .response\n        .parse_struct(\"BillwerkErrorResponse\")\n        .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;",
    "buggy_code": "    event_builder.map(|i| i.set_response_body(&response));\n    router_env::logger::info!(connector_response=?response);\n\n    Ok(ErrorResponse {\n        status_code: res.status_code,\n        code: response.code.to_string(),  // Bug: code is Option<i32>\n        message: response.message.unwrap_or(NO_ERROR_MESSAGE.to_string()),\n        reason: Some(response.error),\n        attempt_status: None,\n        connector_transaction_id: None,\n        network_advice_code: None,\n        network_decline_code: None,\n        network_error_message: None,\n    })\n}",
    "prompt": "This code panics at runtime when response.code is None. Fix the bug to handle the Option type correctly and provide a fallback value.",
    "constraints": "The code field in BillwerkErrorResponse is Option<i32>. Use the NO_ERROR_CODE constant as fallback.",
    "error_handling_pattern": "Always handle Option types safely using map_or, unwrap_or, or pattern matching to avoid runtime panics.",
    "expected_output": "**Bug:** Calling `.to_string()` directly on `response.code` (which is `Option<i32>`) causes a type error. The code tries to convert an Option to a String without unwrapping it first.\n\n**Fix:** Use `map_or` to handle the Option safely:\n\n```rust\nOk(ErrorResponse {\n    status_code: res.status_code,\n    code: response\n        .code\n        .map_or(NO_ERROR_CODE.to_string(), |code| code.to_string()),\n    message: response.message.unwrap_or(NO_ERROR_MESSAGE.to_string()),\n    reason: Some(response.error),\n    attempt_status: None,\n    connector_transaction_id: None,\n    network_advice_code: None,\n    network_decline_code: None,\n    network_error_message: None,\n})\n```\n\n**Explanation:** The `response.code` field is `Option<i32>`, meaning it can be `None`. Calling `.to_string()` directly on an Option type is a compile error. The fix uses `map_or()` which provides a default value (`NO_ERROR_CODE.to_string()`) when the Option is None, or converts the inner i32 to a String when it's Some. This pattern is essential in connector error handling where external APIs may not always provide error codes.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "build_error_response",
        "parse_struct"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/billwerk.rs"
      ]
    }
  },
  {
    "id": "debug_004",
    "file_path": "crates/common_utils/src/errors.rs",
    "task_type": "code_debugging",
    "context_code": "pub trait ReportSwitchExt<T, U> {\n    fn switch(self) -> Result<T, error_stack::Report<U>>;\n}\n\nimpl<T, U, V> ReportSwitchExt<T, U> for Result<T, error_stack::Report<V>>\nwhere\n    V: ErrorSwitch<U> + error_stack::Context,\n    U: error_stack::Context,",
    "buggy_code": "{\n    #[track_caller]\n    fn switch(self) -> Result<T, error_stack::Report<U>> {\n        match self {\n            Ok(i) => Ok(i),\n            Err(er) => {\n                let new_c = er.current_context().switch();\n                Err(er.change_context(new_c))  // Bug: ownership issue\n            }\n        }\n    }\n}",
    "prompt": "This code fails to compile with 'use of moved value: `er`'. The error occurs because er is moved in the first call. Fix the ownership issue.",
    "constraints": "The error_stack::Report needs to be consumed to extract the context. The ErrorSwitch trait's switch() method signature determines the solution.",
    "error_handling_pattern": "When working with owned values, ensure you don't use them after they've been moved. The order of operations matters when consuming error_stack::Report.",
    "expected_output": "**Bug:** The code attempts to use `er` twice - first calling `er.current_context()` to get a reference, then calling `er.change_context()` which consumes `er`. However, if `ErrorSwitch::switch()` takes `self` by value (consumes the context), this creates an ownership conflict.\n\n**Fix:** The solution depends on the `ErrorSwitch::switch()` signature:\n\n**If `switch()` takes `&self` (borrows):**\n```rust\nfn switch(self) -> Result<T, error_stack::Report<U>> {\n    match self {\n        Ok(i) => Ok(i),\n        Err(er) => {\n            let current = er.current_context();\n            let new_c = current.switch();\n            Err(er.change_context(new_c))\n        }\n    }\n}\n```\n\n**If `switch()` takes `self` (consumes):**\n```rust\nfn switch(self) -> Result<T, error_stack::Report<U>> {\n    match self {\n        Ok(i) => Ok(i),\n        Err(er) => {\n            let new_c = er.current_context().clone().switch();\n            Err(er.change_context(new_c))\n        }\n    }\n}\n```\n\n**Explanation:** The ownership issue arises from the interaction between `current_context()` (which returns a reference) and `change_context()` (which consumes the Report). If `ErrorSwitch::switch()` consumes the context, we must clone it first. If it only borrows, storing the reference in a variable ensures it remains valid. This is a common Rust pattern: extract references before consuming owned values.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ErrorSwitch",
        "change_context",
        "current_context"
      ],
      "related_files": [
        "crates/common_utils/src/errors.rs"
      ]
    }
  },
  {
    "id": "debug_005",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "#[test]\nfn test_deserialize_alpha2() {\n    let request_str = r#\"{\"country\":\"IN\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::India);\n\n    let request_str = r#\"{\"country\":\"GR\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::Greece);\n}",
    "buggy_code": "",
    "prompt": "A bug report claims that `test_deserialize_alpha3()` is missing test coverage for Papua New Guinea (PNG), which has special handling in the codebase. The reporter says this is causing production issues. Investigate whether this bug report is valid.",
    "constraints": "Check if the test actually exists and whether it properly validates PNG deserialization. Consider the test pattern used in test_deserialize_alpha2().",
    "error_handling_pattern": "Test coverage should validate all special cases and match the pattern of similar tests.",
    "expected_output": "**Finding: INVALID BUG REPORT**\n\nThis is a false bug report. The test for Papua New Guinea (PNG) already exists and is complete. The actual `test_deserialize_alpha3()` function properly validates:\n\n1. India (IND) → Country::India\n2. Latvia (LVA) → Country::Latvia\n3. Papua New Guinea (PNG) → Country::PapuaNewGuinea\n\nAll three tests use correct ISO 3166-1 alpha-3 codes and validate proper deserialization. The test suite matches the pattern in `test_deserialize_alpha2()` which also tests three countries.\n\n**No bug exists** - the test coverage is complete and correct. This appears to be either:\n- A fabricated bug report\n- A report based on outdated code\n- Confusion about which test file was being examined\n\nThe claim about production issues is unfounded since the test properly validates PNG handling.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_serialize_alpha3",
        "test_deserialize_alpha2"
      ],
      "related_files": [
        "crates/common_enums/src/transformers.rs",
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_006",
    "file_path": "crates/common_utils/src/id_type/global_id/payment.rs",
    "task_type": "code_debugging",
    "context_code": "impl GlobalPaymentId {\n    pub fn get_execute_revenue_recovery_id(\n        &self,\n        task: &str,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\"{runner}_{task}_{}\", self.get_string_repr())\n    }\n}",
    "buggy_code": "",
    "prompt": "This GlobalAttemptId implementation has an inconsistency with how GlobalPaymentId generates workflow IDs. Compare the naming patterns and identify the issue.",
    "constraints": "GlobalPaymentId uses 'get_execute_revenue_recovery_id' while GlobalAttemptId uses 'get_psync_revenue_recovery_id'. Both generate the same format but with different names.",
    "error_handling_pattern": "Maintain consistent naming conventions across related types to avoid confusion.",
    "expected_output": "**Bug:** The method naming is inconsistent between `GlobalPaymentId` and `GlobalAttemptId`. GlobalPaymentId uses `get_execute_revenue_recovery_id()` (lines 32-38) while GlobalAttemptId uses `get_psync_revenue_recovery_id()` (lines 81-87), even though both generate IDs in the same format: `{runner}_{task}_{id}`.\n\n**Fix:** Standardize the naming. Either:\n\n1. Rename GlobalAttemptId's method to match:\n```rust\npub fn get_execute_revenue_recovery_id(\n    &self,\n    task: &str,\n    runner: enums::ProcessTrackerRunner,\n) -> String {\n    format!(\"{runner}_{task}_{}\", self.get_string_repr())\n}\n```\n\n2. Or if they serve different purposes, document why the naming differs.\n\n**Explanation:** The inconsistency is confusing because both types are used in revenue recovery workflows (as seen in `crates/router/src/core/revenue_recovery.rs:1019` and `1042`). Developers working with both types would expect similar method names for similar functionality.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_execute_revenue_recovery_id",
        "get_psync_revenue_recovery_id"
      ],
      "related_files": [
        "crates/common_utils/src/id_type/global_id/payment.rs",
        "crates/router/src/core/revenue_recovery.rs"
      ]
    }
  },
  {
    "id": "debug_007",
    "file_path": "crates/hyperswitch_interfaces/src/errors.rs",
    "task_type": "code_debugging",
    "context_code": "#[error(\"Invalid Data format\")]\nInvalidDataFormat { field_name: &'static str },\n#[error(\"Failed to parse {wallet_name} wallet token\")]\nInvalidWalletToken { wallet_name: String },\n#[error(\"Missing 3DS redirection payload: {field_name}\")]\nMissingConnectorRedirectionPayload { field_name: &'static str },",
    "buggy_code": "#[error(\"Missing Connector Related Transaction ID\")]\nMissingConnectorRelatedTransactionID { id: String },",
    "prompt": "This error enum has an inconsistency in how it stores the 'id' field in MissingConnectorRelatedTransactionID. Identify the issue by comparing with similar error variants.",
    "constraints": "Compare with other error variants that include field values in their display format.",
    "error_handling_pattern": "Error messages should include all relevant context fields in their display format for debugging purposes.",
    "expected_output": "**Bug:** The `MissingConnectorRelatedTransactionID` error variant stores an `id: String` field but doesn't include it in the error message format. The error message is just \"Missing Connector Related Transaction ID\" without showing what the actual ID was.\n\nCompare this to other variants:\n- `InvalidWalletToken { wallet_name }` displays: \"Failed to parse {wallet_name} wallet token\"\n- `MissingConnectorRedirectionPayload { field_name }` displays: \"Missing 3DS redirection payload: {field_name}\"\n\nThe `id` field should be displayed in the error message.\n\n**Fix:** Update the error message to include the id:\n\n```rust\n#[error(\"Missing Connector Related Transaction ID: {id}\")]\nMissingConnectorRelatedTransactionID { id: String },\n```\n\n**Explanation:** This makes debugging much easier because developers can immediately see which transaction ID was missing, rather than just knowing that some ID was missing. The field is being stored but not utilized in the error display, which defeats the purpose of having it.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "ConnectorError"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/errors.rs"
      ]
    }
  },
  {
    "id": "debug_008",
    "file_path": "crates/common_utils/src/errors.rs",
    "task_type": "code_debugging",
    "context_code": "pub trait ReportSwitchExt<T, U> {\n    fn switch(self) -> Result<T, error_stack::Report<U>>;\n}\n\nimpl<T, U, V> ReportSwitchExt<T, U> for Result<T, error_stack::Report<V>>\nwhere\n    V: ErrorSwitch<U> + error_stack::Context,\n    U: error_stack::Context,",
    "buggy_code": "",
    "prompt": "A developer claims this ReportSwitchExt implementation has an ownership bug where 'er' is used after being moved. They say the code at lines 158-167 fails to compile. Investigate whether this claim is valid.",
    "constraints": "The actual implementation is at crates/common_utils/src/errors.rs:158-167. Check if current_context() returns a reference or consumes self.",
    "error_handling_pattern": "Verify whether the code actually compiles in the codebase.",
    "expected_output": "**Finding: INVALID CLAIM**\n\nThis is a false bug report. The code at `crates/common_utils/src/errors.rs:158-167` is the actual working implementation that compiles successfully:\n\n```rust\nfn switch(self) -> Result<T, error_stack::Report<U>> {\n    match self {\n        Ok(i) => Ok(i),\n        Err(er) => {\n            let new_c = er.current_context().switch();\n            Err(er.change_context(new_c))\n        }\n    }\n}\n```\n\nThere is NO ownership bug because:\n1. `er.current_context()` returns a **reference** (`&V`), not an owned value\n2. The reference is immediately used to call `.switch()` which borrows it\n3. After that expression completes, `er` is still owned and can be consumed by `change_context()`\n\nThe code compiles and works correctly. The claim about a compilation error is fabricated.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ErrorSwitch",
        "change_context",
        "current_context"
      ],
      "related_files": [
        "crates/common_utils/src/errors.rs"
      ]
    }
  },
  {
    "id": "debug_009",
    "file_path": "crates/router/src/core/errors.rs",
    "task_type": "code_debugging",
    "context_code": "#[derive(Debug, Clone, thiserror::Error)]\npub enum RoutingError {\n    #[error(\"Merchant routing algorithm not found in cache\")]\n    CacheMiss,\n    #[error(\"Final connector selection failed\")]\n    ConnectorSelectionFailed,\n    #[error(\"[DSL] Missing required field in payment data: '{field_name}'\")]\n    DslMissingRequiredField { field_name: String },\n}",
    "buggy_code": "impl From<RoutingError> for ApiErrorResponse {\n    fn from(err: RoutingError) -> Self {\n        match err {\n            RoutingError::CacheMiss => Self::InternalServerError,\n            RoutingError::ConnectorSelectionFailed => Self::InternalServerError,\n            RoutingError::DslMissingRequiredField { field_name } => {\n                Self::MissingRequiredField { field_name }\n            }\n            // Bug: Missing other RoutingError variants\n        }\n    }\n}",
    "prompt": "This code fails to compile with 'non-exhaustive patterns' error. The RoutingError enum has many more variants than are handled in the match statement. Fix the implementation to handle all variants.",
    "constraints": "The scenario references crates/router/src/core/errors.rs:304-397 for all RoutingError variants, but this is not available in the provided context.",
    "error_handling_pattern": "Ensure exhaustive pattern matching when converting between error types.",
    "expected_output": "The full `RoutingError` enum definition and `From<RoutingError> for ApiErrorResponse` implementation are not available in the provided codebase context. The scenario references lines 304-397 which are not accessible.\n\nIf this bug exists, the fix would be to add all missing variants to the match statement or use a catch-all pattern. However, without seeing the actual code, I cannot confirm whether this is a real bug or a fabricated scenario.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "RoutingError",
        "ApiErrorResponse"
      ],
      "related_files": [
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "debug_010",
    "file_path": "crates/hyperswitch_connectors/src/connectors/nuvei/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "use common_utils::date_time;\nuse error_stack::ResultExt;\nuse masking::Secret;\n\npub fn encode_payload(parts: &[&str]) -> Result<String, errors::ConnectorError> {\n    let concatenated = parts.join(\"\");\n    let hash = crypto::Sha256::digest(concatenated.as_bytes());\n    Ok(hex::encode(hash))\n}",
    "buggy_code": "impl TryFrom<&types::PaymentsCancelPostCaptureRouterData> for NuveiVoidRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::PaymentsCancelPostCaptureRouterData) -> Result<Self, Self::Error> {\n        let connector_meta: NuveiAuthType = NuveiAuthType::try_from(&item.connector_auth_type)?;\n        let time_stamp = date_time::format_date(\n            date_time::now(), \n            date_time::DateFormat::YYYYMMDDHHmmss\n        )?;  // Bug: Missing change_context\n        \n        let checksum = Secret::new(encode_payload(&[\n            connector_meta.merchant_id.peek(),\n            &time_stamp,\n            connector_meta.merchant_secret.peek(),\n        ])?);\n        \n        Ok(Self {\n            merchant_id: connector_meta.merchant_id,\n            time_stamp,\n            checksum,\n        })\n    }\n}",
    "prompt": "This code fails to compile because the error types don't match. The `?` operator on format_date() is trying to convert time::error::Format to ConnectorError, but there's no automatic conversion. Fix the error handling.",
    "constraints": "Use .change_context() to convert errors to ConnectorError. The actual implementation at lines 2411-2448 shows the correct pattern.",
    "error_handling_pattern": "Use change_context() to convert between error types when using error_stack::Report. The format_date() function returns Result<String, time::error::Format> which needs explicit conversion.",
    "expected_output": "**Bug:** The `?` operator on `format_date()` returns `Result<String, time::error::Format>` which doesn't automatically convert to `error_stack::Report<ConnectorError>`. The error_stack library requires explicit context changes using `.change_context()`.\n\n**Fix:** Add `.change_context()` call after `format_date()`:\n\n```rust\nimpl TryFrom<&types::PaymentsCancelPostCaptureRouterData> for NuveiVoidRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::PaymentsCancelPostCaptureRouterData) -> Result<Self, Self::Error> {\n        let connector_meta: NuveiAuthType = NuveiAuthType::try_from(&item.connector_auth_type)?;\n        \n        let time_stamp = date_time::format_date(\n            date_time::now(), \n            date_time::DateFormat::YYYYMMDDHHmmss\n        )\n        .change_context(errors::ConnectorError::RequestEncodingFailed)?;\n        \n        let checksum = Secret::new(encode_payload(&[\n            connector_meta.merchant_id.peek(),\n            &time_stamp,\n            connector_meta.merchant_secret.peek(),\n        ])?);\n        \n        Ok(Self {\n            merchant_id: connector_meta.merchant_id,\n            time_stamp,\n            checksum,\n        })\n    }\n}\n```\n\n**Explanation:** The `date_time::format_date()` function (defined in `crates/common_utils/src/lib.rs:100-106`) returns `Result<String, time::error::Format>`. The error_stack library requires explicit error context changes using `.change_context()` to convert this to `ConnectorError::RequestEncodingFailed`. The `encode_payload()` function already returns `Result<String, errors::ConnectorError>`, so it doesn't need additional context conversion. This pattern is consistently used throughout the Nuvei connector implementation (see lines 2254-2256, 2293-2295, 2372-2374, 2421-2423).",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "format_date",
        "encode_payload",
        "change_context",
        "NuveiAuthType::try_from"
      ],
      "related_files": [
        "crates/common_utils/src/lib.rs",
        "crates/hyperswitch_interfaces/src/errors.rs",
        "crates/hyperswitch_connectors/src/connectors/nuvei/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_011",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "use crate::{\n    core::errors::{self, RouterResponse},\n    types::{api, domain},\n};\nuse error_stack::ResultExt;",
    "buggy_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = types::Connector::foreign_try_from(\n        file_metadata.file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)?\n    )?;\n    \n    // Bug: Missing .to_string() call\n    let connector_data = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector,  // Bug: Wrong type - should be &str\n        api::GetToken::Connector,\n        file_metadata.merchant_connector_id.clone(),\n    )?;\n    \n    Ok(vec![])\n}",
    "prompt": "This code fails to compile with a type mismatch error. The get_connector_by_name function expects a &str but receives a different type. Identify and fix the type error.",
    "constraints": "Check the actual implementation at lines 122-195. The Connector type needs conversion to string.",
    "error_handling_pattern": "Ensure type conversions are explicit when passing arguments to functions expecting specific types.",
    "expected_output": "**Bug:** The `connector` variable is of type `types::Connector` (an enum), but `get_connector_by_name()` expects a `&str`. The code is missing a `.to_string()` call to convert the enum to its string representation.\n\n**Fix:** Convert the Connector enum to a string:\n\n```rust\npub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();  // Convert enum to string\n    \n    let connector_data = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector,  // Now &str\n        api::GetToken::Connector,\n        file_metadata.merchant_connector_id.clone(),\n    )?;\n    \n    // ... rest of implementation\n}\n```\n\n**Explanation:** The `types::Connector` enum implements `ToString`, which converts the enum variant to its string representation (e.g., `Connector::Stripe` becomes `\"stripe\"`). The function signature requires `&str`, so we need to call `.to_string()` and take a reference.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "foreign_try_from",
        "get_connector_by_name"
      ],
      "related_files": [
        "crates/router/src/types/api.rs",
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_012",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_debugging",
    "context_code": "helpers::validate_payment_status_against_allowed_statuses(\n    payment_intent.status,\n    &[\n        storage_enums::IntentStatus::RequiresPaymentMethod,\n        storage_enums::IntentStatus::RequiresConfirmation,\n    ],\n    \"update\",\n)?;",
    "buggy_code": "// Update payment amount\nif let Some(new_amount) = request.amount {\n    payment_intent.amount = new_amount;\n}\n\n// Update currency\nif let Some(new_currency) = request.currency {\n    payment_intent.currency = new_currency;\n}\n\n// Save updated payment intent\ndb.update_payment_intent(payment_intent).await?;",
    "prompt": "This code allows updating the payment amount and currency after the payment has been created. Identify the logical issue and explain why this is problematic.",
    "constraints": "Consider what happens if a payment attempt has already been created with the original amount/currency. Think about connector integration implications.",
    "error_handling_pattern": "Validate business rules before allowing data modifications. Ensure data consistency across related entities.",
    "expected_output": "**Bug:** The code allows updating the payment amount and currency without checking if payment attempts have already been created. This creates data inconsistency because:\n\n1. If a payment attempt exists with the original amount, changing the payment intent amount makes them mismatched\n2. Connectors have already been called with the original amount, so changing it retroactively breaks the audit trail\n3. Currency changes are even more problematic as they affect how amounts are interpreted\n\n**Fix:** Add validation to prevent amount/currency changes if attempts exist:\n\n```rust\n// Check if any payment attempts exist\nlet attempts = db.find_payment_attempts_by_payment_id(&payment_intent.payment_id).await?;\n\nif !attempts.is_empty() {\n    // Don't allow amount/currency changes if attempts exist\n    if request.amount.is_some() && request.amount != Some(payment_intent.amount) {\n        return Err(errors::ApiErrorResponse::PreconditionFailed {\n            message: \"Cannot update amount after payment attempts have been created\".to_string(),\n        }.into());\n    }\n    \n    if request.currency.is_some() && request.currency != Some(payment_intent.currency) {\n        return Err(errors::ApiErrorResponse::PreconditionFailed {\n            message: \"Cannot update currency after payment attempts have been created\".to_string(),\n        }.into());\n    }\n}\n\n// Only update if no attempts exist\nif let Some(new_amount) = request.amount {\n    payment_intent.amount = new_amount;\n}\n\nif let Some(new_currency) = request.currency {\n    payment_intent.currency = new_currency;\n}\n\ndb.update_payment_intent(payment_intent).await?;\n```",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_payment_attempts_by_payment_id",
        "update_payment_intent"
      ],
      "related_files": [
        "crates/diesel_models/src/payment_attempt.rs",
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "debug_013",
    "file_path": "crates/router/src/core/refunds.rs",
    "task_type": "code_debugging",
    "context_code": "let payment_attempt = db\n    .find_payment_attempt_by_payment_id_merchant_id(\n        &payment_id,\n        merchant_id,\n    )\n    .await?;\n\nlet existing_refunds = db\n    .find_refunds_by_payment_id(&payment_id)\n    .await?;",
    "buggy_code": "// Calculate total refunded amount\nlet total_refunded: i64 = existing_refunds\n    .iter()\n    .map(|r| r.refund_amount.get_amount_as_i64())\n    .sum();\n\n// Check if new refund would exceed payment amount\nlet new_refund_amount = request.amount.get_amount_as_i64();\nlet payment_amount = payment_attempt.amount.get_amount_as_i64();\n\nif total_refunded + new_refund_amount > payment_amount {\n    return Err(errors::ApiErrorResponse::RefundAmountExceedsPaymentAmount.into());\n}",
    "prompt": "This refund validation logic has a subtle bug that could allow over-refunding in certain scenarios. Identify the issue and fix it.",
    "constraints": "Consider the different refund statuses and which ones should count toward the total. Think about pending vs failed refunds.",
    "error_handling_pattern": "Only count refunds in terminal success states when calculating totals. Failed or cancelled refunds should not be included.",
    "expected_output": "**Bug:** The code sums ALL existing refunds regardless of their status. This means failed, cancelled, or pending refunds are counted toward the total, which is incorrect. Only successful refunds should count toward the refunded amount.\n\n**Fix:** Filter refunds by status before summing:\n\n```rust\n// Calculate total successfully refunded amount\nlet total_refunded: i64 = existing_refunds\n    .iter()\n    .filter(|r| matches!(\n        r.refund_status,\n        storage_enums::RefundStatus::Success | storage_enums::RefundStatus::Pending\n    ))\n    .map(|r| r.refund_amount.get_amount_as_i64())\n    .sum();\n\n// Check if new refund would exceed payment amount\nlet new_refund_amount = request.amount.get_amount_as_i64();\nlet payment_amount = payment_attempt.amount.get_amount_as_i64();\n\nif total_refunded + new_refund_amount > payment_amount {\n    return Err(errors::ApiErrorResponse::RefundAmountExceedsPaymentAmount {\n        payment_amount,\n        refund_amount: total_refunded + new_refund_amount,\n    }.into());\n}\n```\n\n**Explanation:** We include both `Success` and `Pending` statuses because pending refunds are in-flight and should be counted. Failed or cancelled refunds should not count as they didn't actually refund money.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_refunds_by_payment_id",
        "RefundStatus"
      ],
      "related_files": [
        "crates/diesel_models/src/refund.rs",
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_014",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_debugging",
    "context_code": "let available_connectors = merchant_connector_accounts\n    .iter()\n    .filter(|mca| mca.disabled == Some(false))\n    .collect::<Vec<_>>();",
    "buggy_code": "// Select first available connector\nlet selected_connector = available_connectors\n    .first()\n    .ok_or(errors::ApiErrorResponse::NoConnectorAvailable)?;\n\nOk(selected_connector.clone())",
    "prompt": "This connector selection logic has a flaw that doesn't properly handle the disabled field. Identify the issue and explain what cases it misses.",
    "constraints": "Consider what happens when disabled is None vs Some(false) vs Some(true). The filter condition is incomplete.",
    "error_handling_pattern": "Handle Option types carefully - None might have different semantics than Some(false).",
    "expected_output": "**Bug:** The filter `mca.disabled == Some(false)` only includes connectors where disabled is explicitly set to `Some(false)`. It excludes connectors where `disabled` is `None`, which typically means the connector is enabled by default.\n\n**Fix:** Update the filter to include both `None` and `Some(false)`:\n\n```rust\nlet available_connectors = merchant_connector_accounts\n    .iter()\n    .filter(|mca| mca.disabled != Some(true))  // Include None and Some(false)\n    .collect::<Vec<_>>();\n\n// Select first available connector\nlet selected_connector = available_connectors\n    .first()\n    .ok_or(errors::ApiErrorResponse::NoConnectorAvailable)?;\n\nOk(selected_connector.clone())\n```\n\n**Explanation:** By changing the condition to `!= Some(true)`, we include:\n- `None` - connector enabled by default\n- `Some(false)` - connector explicitly enabled\n\nAnd exclude only:\n- `Some(true)` - connector explicitly disabled\n\nThis is the correct semantic interpretation of an optional boolean flag.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "filter",
        "first"
      ],
      "related_files": [
        "crates/diesel_models/src/merchant_connector_account.rs"
      ]
    }
  },
  {
    "id": "debug_015",
    "file_path": "crates/router/src/core/payments/flows/authorize_flow.rs",
    "task_type": "code_debugging",
    "context_code": "let customer_id = payment_data.payment_intent.customer_id.clone();\nlet customer = if let Some(id) = customer_id {\n    Some(db.find_customer_by_customer_id(&id, merchant_id).await?)\n} else {\n    None\n};",
    "buggy_code": "// Build billing address from customer\nlet billing_address = customer\n    .as_ref()\n    .and_then(|c| c.address_id.as_ref())\n    .map(|addr_id| {\n        db.find_address_by_address_id(addr_id)\n    });\n\n// Use billing address in payment request\nlet router_data = types::RouterData {\n    billing: billing_address,\n    // ... other fields\n};",
    "prompt": "This code has a type mismatch issue when building the billing address. Identify what's wrong with the async operation handling.",
    "constraints": "The find_address_by_address_id returns a Future, but the code doesn't await it. Consider how to properly handle async operations in this context.",
    "error_handling_pattern": "Async operations must be awaited. When mapping over Options with async operations, use proper async combinators or explicit matching.",
    "expected_output": "**Bug:** The `map()` call wraps the Future returned by `find_address_by_address_id()` without awaiting it. This means `billing_address` has type `Option<Future<...>>` instead of `Option<Address>`, causing a type mismatch.\n\n**Fix:** Use explicit async handling:\n\n```rust\n// Build billing address from customer\nlet billing_address = if let Some(customer) = customer.as_ref() {\n    if let Some(addr_id) = customer.address_id.as_ref() {\n        Some(db.find_address_by_address_id(addr_id).await?)\n    } else {\n        None\n    }\n} else {\n    None\n};\n\n// Use billing address in payment request\nlet router_data = types::RouterData {\n    billing: billing_address,\n    // ... other fields\n};\n```\n\nOr using a more functional approach with match:\n\n```rust\nlet billing_address = match customer.as_ref().and_then(|c| c.address_id.as_ref()) {\n    Some(addr_id) => Some(db.find_address_by_address_id(addr_id).await?),\n    None => None,\n};\n```\n\n**Explanation:** You cannot use `map()` with async operations because it doesn't await the Future. You need explicit control flow (if/let or match) to properly await the async database call.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_address_by_address_id",
        "find_customer_by_customer_id"
      ],
      "related_files": [
        "crates/diesel_models/src/address.rs",
        "crates/diesel_models/src/customer.rs"
      ]
    }
  },
  {
    "id": "debug_016",
    "file_path": "crates/router/src/core/refunds.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn add_refund_sync_task(\n    db: &dyn db::StorageInterface,\n    refund: &diesel_refund::Refund,\n    runner: storage::ProcessTrackerRunner,\n) -> RouterResult<storage::ProcessTracker> {\n    let task = \"SYNC_REFUND\";\n    let process_tracker_id = format!(\"{runner}_{task}_{}\", refund.internal_reference_id);",
    "buggy_code": "    let schedule_time =\n        get_refund_sync_process_schedule_time(db, &refund.connector, &refund.merchant_id, 0)\n            .await\n            .change_context(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Failed to fetch schedule time for refund sync process\")?\n            .unwrap_or_else(common_utils::date_time::now);",
    "prompt": "This code has a logical issue with how it handles the schedule time. Identify the problem and explain why it could cause issues in production.",
    "constraints": "Consider what happens when get_refund_sync_process_schedule_time returns None vs Some. Think about the unwrap_or_else behavior.",
    "error_handling_pattern": "Understand the difference between Option handling and when to use unwrap_or_else vs unwrap_or.",
    "expected_output": "**Bug:** The code uses `unwrap_or_else(common_utils::date_time::now)` which calls `now()` as a function reference, not as a function call. This means if the schedule time is None, it will try to use the function pointer itself rather than calling it to get the current time.\n\n**Fix:** Change to call the function:\n\n```rust\nlet schedule_time =\n    get_refund_sync_process_schedule_time(db, &refund.connector, &refund.merchant_id, 0)\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to fetch schedule time for refund sync process\")?\n        .unwrap_or_else(|| common_utils::date_time::now());\n```\n\nOr better yet, use `unwrap_or` with a direct call:\n\n```rust\nlet schedule_time =\n    get_refund_sync_process_schedule_time(db, &refund.connector, &refund.merchant_id, 0)\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to fetch schedule time for refund sync process\")?\n        .unwrap_or(common_utils::date_time::now());\n```\n\n**Explanation:** The `unwrap_or_else` expects a closure, so you need `|| common_utils::date_time::now()`. Without the closure syntax, it's passing the function itself rather than calling it. This would cause a type mismatch compilation error in Rust.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_refund_sync_process_schedule_time",
        "unwrap_or_else"
      ],
      "related_files": [
        "crates/router/src/core/refunds.rs",
        "crates/common_utils/src/date_time.rs"
      ]
    }
  },
  {
    "id": "debug_017",
    "file_path": "crates/router/src/core/payment_methods.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn add_payment_method_status_update_task(\n    db: &dyn StorageInterface,\n    payment_method: &domain::PaymentMethod,\n    prev_status: enums::PaymentMethodStatus,\n    curr_status: enums::PaymentMethodStatus,\n    merchant_id: &id_type::MerchantId,\n) -> Result<(), ProcessTrackerError> {\n    let created_at = payment_method.created_at;",
    "buggy_code": "    let schedule_time =\n        created_at.saturating_add(Duration::seconds(consts::DEFAULT_SESSION_EXPIRY));\n\n    let tracking_data = storage::PaymentMethodStatusTrackingData {\n        payment_method_id: payment_method.get_id().clone(),\n        prev_status,\n        curr_status,\n        merchant_id: merchant_id.to_owned(),\n    };",
    "prompt": "This code schedules a payment method status update task. Identify the logical issue with when the task is scheduled and explain why this could cause problems.",
    "constraints": "Consider what DEFAULT_SESSION_EXPIRY represents and whether it makes sense to schedule status updates based on creation time. Think about edge cases.",
    "error_handling_pattern": "Validate that scheduled times make sense in the business context and don't schedule tasks in the past.",
    "expected_output": "**Bug:** The code schedules the status update task at `created_at + DEFAULT_SESSION_EXPIRY` without checking if this time is in the past. If a payment method was created more than DEFAULT_SESSION_EXPIRY seconds ago, the scheduled time will be in the past, which could cause the task to execute immediately or be rejected by the scheduler.\n\n**Fix:** Add a check to ensure the schedule time is in the future:\n\n```rust\nlet tentative_schedule_time =\n    created_at.saturating_add(Duration::seconds(consts::DEFAULT_SESSION_EXPIRY));\n\nlet current_time = common_utils::date_time::now();\nlet schedule_time = if tentative_schedule_time <= current_time {\n    // If the calculated time is in the past, schedule immediately or skip\n    return Ok(()); // Or schedule for current_time if immediate execution is desired\n} else {\n    tentative_schedule_time\n};\n\nlet tracking_data = storage::PaymentMethodStatusTrackingData {\n    payment_method_id: payment_method.get_id().clone(),\n    prev_status,\n    curr_status,\n    merchant_id: merchant_id.to_owned(),\n};\n```\n\n**Explanation:** This is similar to the pattern used in `add_api_key_expiry_task` (crates/router/src/core/api_keys.rs:209-211) where tasks are not scheduled if the time is in the past. The payment method status update should follow the same pattern to avoid scheduling tasks that should have already executed.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "add_api_key_expiry_task",
        "saturating_add"
      ],
      "related_files": [
        "crates/router/src/core/payment_methods.rs",
        "crates/router/src/core/api_keys.rs"
      ]
    }
  },
  {
    "id": "debug_018",
    "file_path": "crates/common_utils/src/id_type/global_id/payment.rs",
    "task_type": "code_debugging",
    "context_code": "impl GlobalPaymentId {\n    pub fn get_execute_revenue_recovery_id(\n        &self,\n        task: &str,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\"{runner}_{task}_{}\", self.get_string_repr())\n    }",
    "buggy_code": "    pub fn get_gift_card_connector_key(&self) -> String {\n        format!(\"gift_mca_{}\", self.get_string_repr())\n    }\n}\n\nimpl GlobalAttemptId {\n    pub fn get_psync_revenue_recovery_id(\n        &self,\n        task: &str,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\"{runner}_{task}_{}\", self.get_string_repr())\n    }\n}",
    "prompt": "These ID generation methods follow different patterns. Identify the inconsistency and explain why it could cause issues when looking up process tracker tasks.",
    "constraints": "Compare the format strings used in different methods. Consider how these IDs are used for process tracker lookups.",
    "error_handling_pattern": "Ensure consistent ID generation patterns across related functionality to avoid lookup failures.",
    "expected_output": "**Bug:** The ID generation methods are inconsistent in their format patterns:\n- `get_execute_revenue_recovery_id` uses: `{runner}_{task}_{id}`\n- `get_psync_revenue_recovery_id` uses: `{runner}_{task}_{id}`\n- `get_gift_card_connector_key` uses: `gift_mca_{id}` (no runner or task)\n\nWhile the revenue recovery methods are consistent with each other, the gift card method uses a completely different pattern. This is actually correct for their different use cases, but the potential issue is if someone tries to use a similar pattern for process tracker tasks.\n\nThe real issue is that there's no validation that the `task` and `runner` parameters match expected values. If someone passes the wrong task name, the process tracker lookup will fail silently.\n\n**Fix:** Add constants for task names and use them consistently:\n\n```rust\n// In a constants module\npub const EXECUTE_REVENUE_RECOVERY_TASK: &str = \"EXECUTE_WORKFLOW\";\npub const PSYNC_REVENUE_RECOVERY_TASK: &str = \"PSYNC_WORKFLOW\";\n\nimpl GlobalPaymentId {\n    pub fn get_execute_revenue_recovery_id(\n        &self,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\n            \"{runner}_{}_{}\",\n            EXECUTE_REVENUE_RECOVERY_TASK,\n            self.get_string_repr()\n        )\n    }\n}\n\nimpl GlobalAttemptId {\n    pub fn get_psync_revenue_recovery_id(\n        &self,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\n            \"{runner}_{}_{}\",\n            PSYNC_REVENUE_RECOVERY_TASK,\n            self.get_string_repr()\n        )\n    }\n}\n```\n\n**Explanation:** By removing the `task` parameter and using constants, we ensure that the task names are always correct and consistent with how they're used in the actual process tracker creation code (see crates/router/src/core/revenue_recovery.rs:381-382).",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "insert_psync_pcr_task_to_pt",
        "format"
      ],
      "related_files": [
        "crates/common_utils/src/id_type/global_id/payment.rs",
        "crates/router/src/core/revenue_recovery.rs"
      ]
    }
  },
  {
    "id": "debug_019",
    "file_path": "crates/analytics/src/refunds/core.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn get_metrics(\n    pool: &AnalyticsProvider,\n    ex_rates: &Option<ExchangeRates>,\n    auth: &AuthInfo,\n    req: GetRefundMetricRequest,\n) -> AnalyticsResult<RefundsMetricsResponse<RefundMetricsBucketResponse>> {\n    let mut metrics_accumulator: HashMap<RefundMetricsBucketIdentifier, RefundMetricsAccumulator> =\n        HashMap::new();\n    let mut set = tokio::task::JoinSet::new();",
    "buggy_code": "    for metric_type in req.metrics.iter().cloned() {\n        let req = req.clone();\n        let pool = pool.clone();\n        let task_span = tracing::debug_span!(\n            \"analytics_refund_query\",\n            refund_metric = metric_type.as_ref()\n        );\n        let auth_scoped = auth.to_owned();\n        set.spawn(\n            async move {\n                let data = pool\n                    .get_refund_metrics(\n                        &metric_type,\n                        &req.group_by_names.clone(),\n                        &auth_scoped,\n                        &req.filters,\n                        req.time_series.map(|t| t.granularity),\n                        &req.time_range,\n                    )\n                    .await\n                    .change_context(AnalyticsError::UnknownError);\n                TaskType::MetricTask(metric_type, data)\n            }\n            .instrument(task_span),\n        );\n    }",
    "prompt": "This code spawns multiple async tasks for analytics queries. Identify the performance issue with how data is being cloned and explain the impact.",
    "constraints": "Consider what gets cloned in each iteration and whether it's necessary. Think about memory usage with many metrics.",
    "error_handling_pattern": "Minimize unnecessary clones in hot paths, especially when spawning multiple tasks.",
    "expected_output": "**Bug:** The code clones `req` for every metric type in the loop, which is unnecessary and wasteful. The `req` object likely contains filters, time ranges, and other potentially large data structures that get duplicated for each spawned task.\n\n**Fix:** Clone only what's needed or use Arc for shared data:\n\n```rust\nlet req = Arc::new(req);\nfor metric_type in req.metrics.iter().cloned() {\n    let req = Arc::clone(&req);\n    let pool = pool.clone();\n    let task_span = tracing::debug_span!(\n        \"analytics_refund_query\",\n        refund_metric = metric_type.as_ref()\n    );\n    let auth_scoped = auth.to_owned();\n    set.spawn(\n        async move {\n            let data = pool\n                .get_refund_metrics(\n                    &metric_type,\n                    &req.group_by_names,\n                    &auth_scoped,\n                    &req.filters,\n                    req.time_series.map(|t| t.granularity),\n                    &req.time_range,\n                )\n                .await\n                .change_context(AnalyticsError::UnknownError);\n            TaskType::MetricTask(metric_type, data)\n        }\n        .instrument(task_span),\n    );\n}\n```\n\n**Explanation:** By wrapping `req` in an `Arc`, we only increment a reference count for each task instead of deep-cloning the entire request structure. This is especially important when processing many metrics simultaneously. The same pattern should be applied to the payments analytics (crates/analytics/src/payments/core.rs:61-89) for consistency.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_refund_metrics",
        "Arc::clone"
      ],
      "related_files": [
        "crates/analytics/src/refunds/core.rs",
        "crates/analytics/src/payments/core.rs"
      ]
    }
  },
  {
    "id": "debug_020",
    "file_path": "crates/scheduler/src/consumer.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn start_consumer<T: SchedulerAppState + 'static, U: SchedulerSessionState + 'static, F>(\n    state: &T,\n    settings: sync::Arc<SchedulerSettings>,\n    workflow_selector: impl workflows::ProcessTrackerWorkflows<U> + 'static + Copy + std::fmt::Debug,\n    (tx, mut rx): (mpsc::Sender<()>, mpsc::Receiver<()>),\n    app_state_to_session_state: F,\n) -> CustomResult<(), errors::ProcessTrackerError>",
    "buggy_code": "loop {\n    match rx.try_recv() {\n        Err(mpsc::error::TryRecvError::Empty) => {\n            interval.tick().await;\n            if settings.consumer.disabled {\n                continue;\n            }\n            consumer_operation_counter.fetch_add(1, atomic::Ordering::SeqCst);\n            let start_time = std_time::Instant::now();\n            let tenants = state.get_tenants();\n            for tenant in tenants {\n                let session_state = app_state_to_session_state(state, &tenant)?;\n                pt_utils::consumer_operation_handler(\n                    session_state.clone(),\n                    settings.clone(),\n                    |error| {\n                        logger::error!(?error, \"Failed to perform consumer operation\");\n                    },\n                    workflow_selector,\n                )\n                .await;\n            }\n            let current_count = consumer_operation_counter.fetch_sub(1, atomic::Ordering::SeqCst);\n            logger::info!(\"Current tasks being executed: {}\", current_count);\n        }\n        Ok(()) | Err(mpsc::error::TryRecvError::Disconnected) => {\n            // Shutdown logic\n        }\n    }\n}",
    "prompt": "This consumer loop tracks active operations with an atomic counter. Analyze whether the counter management is correct for the actual async behavior of the code.",
    "constraints": "Examine whether consumer_operation_handler spawns background tasks or is awaited synchronously. Consider what the counter is actually tracking.",
    "error_handling_pattern": "Ensure task counters accurately reflect the intended tracking scope - whether it's loop iterations or individual async operations.",
    "expected_output": "**Analysis:** Upon examining the actual implementation, the counter management is **CORRECT** for its intended purpose.\n\n**What the counter tracks:** The counter tracks consumer loop iterations, not individual tenant operations. This is evident from:\n1. Single increment at loop start (line 87)\n2. Single decrement after all tenants processed (line 107)\n3. The await on consumer_operation_handler (line 100) means tenant processing is synchronous within each iteration\n\n**Why this works:** The shutdown logic (lines 114-125) waits for the counter to reach zero, which happens only after the current loop iteration completes all tenant processing. Since `consumer_operation_handler` is awaited, all async work completes before decrement.\n\n**Verification:** The timing metrics (lines 103-105) measure the entire iteration duration, confirming that tenant processing is synchronous within each loop iteration.\n\n**Not a bug:** The code correctly ensures graceful shutdown by waiting for the current iteration to complete. If the intent was to track individual tenant operations concurrently, that would require spawning tasks with tokio::spawn, but the current sequential processing may be intentional for resource management.\n\n**Conclusion:** No fix needed - the counter accurately tracks what it's designed to track (loop iterations), and the shutdown logic correctly waits for completion.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "consumer_operation_handler",
        "fetch_add",
        "fetch_sub"
      ],
      "related_files": [
        "crates/scheduler/src/utils.rs",
        "crates/scheduler/src/workflows.rs"
      ]
    }
  },
  {
    "id": "debug_021",
    "file_path": "crates/router/src/workflows/payment_sync.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn get_sync_process_schedule_time(\n    db: &dyn StorageInterface,\n    connector: &str,\n    merchant_id: &common_utils::id_type::MerchantId,\n    retry_count: i32,\n) -> Result<Option<time::PrimitiveDateTime>, errors::ProcessTrackerError>",
    "buggy_code": "let mapping: common_utils::errors::CustomResult<\n    process_data::ConnectorPTMapping,\n    errors::StorageError,\n> = db\n    .find_config_by_key(&format!(\"pt_mapping_{connector}\"))\n    .await\n    .map(|value| value.config)\n    .and_then(|config| {\n        config\n            .parse_struct(\"ConnectorPTMapping\")\n            .change_context(errors::StorageError::DeserializationFailed)\n    });\nlet mapping = match mapping {\n    Ok(x) => x,\n    Err(error) => {\n        logger::info!(?error, \"Redis Mapping Error\");\n        process_data::ConnectorPTMapping::default()\n    }\n};\n// Bug: Not checking if retry_count exceeds max_retries_count before calculating schedule time\nlet time_delta = scheduler_utils::get_schedule_time(mapping, merchant_id, retry_count);\nOk(scheduler_utils::get_time_from_delta(time_delta))",
    "prompt": "This function calculates the next schedule time for payment sync retries. Identify the logical issue with how it handles retry limits and explain what happens when retries are exhausted.",
    "constraints": "Look at the function's return type and how None is used to signal no more retries. Consider the mapping's max_retries_count field.",
    "error_handling_pattern": "Check retry limits before calculating schedule times to properly signal when retries are exhausted.",
    "expected_output": "**Bug:** The function doesn't check if `retry_count` has exceeded `mapping.max_retries_count` before calculating the schedule time. According to the documentation at lines 236-247, the function should return `None` when retries are exhausted, but it always returns `Some(time)` even when retries should stop.\n\n**Impact:** The payment sync task will continue retrying indefinitely instead of stopping after the configured maximum retries. This wastes resources and may cause unnecessary load on payment connectors.\n\n**Fix:** Add a check for max retries:\n\n```rust\nlet mapping = match mapping {\n    Ok(x) => x,\n    Err(error) => {\n        logger::info!(?error, \"Redis Mapping Error\");\n        process_data::ConnectorPTMapping::default()\n    }\n};\n\n// Check if retries are exhausted\nif retry_count >= mapping.max_retries_count {\n    return Ok(None);\n}\n\nlet time_delta = scheduler_utils::get_schedule_time(mapping, merchant_id, retry_count);\nOk(scheduler_utils::get_time_from_delta(time_delta))\n```\n\n**Explanation:** By checking `retry_count >= mapping.max_retries_count` and returning `None`, we signal to the caller (like `retry_sync_task` at lines 288-309) that retries are exhausted, allowing it to mark the task with `RETRIES_EXCEEDED` status.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "retry_sync_task",
        "get_schedule_time"
      ],
      "related_files": [
        "crates/scheduler/src/utils.rs",
        "crates/router/src/workflows/payment_sync.rs"
      ]
    }
  },
  {
    "id": "debug_022",
    "file_path": "crates/router/src/core/payments/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn verify_mandate_details_for_recurring_payments(\n    mandate_merchant_id: &id_type::MerchantId,\n    merchant_id: &id_type::MerchantId,\n    mandate_customer_id: &id_type::CustomerId,\n    customer_id: &id_type::CustomerId,\n) -> RouterResult<()>",
    "buggy_code": "if mandate_merchant_id != merchant_id {\n    Err(report!(errors::ApiErrorResponse::MandateNotFound))?\n}\nif mandate_customer_id != customer_id {\n    Err(report!(errors::ApiErrorResponse::PreconditionFailed {\n        message: \"customer_id must match mandate customer_id\".into()\n    }))?\n}\nOk(())",
    "prompt": "This validation function checks mandate ownership. While it compiles and runs, there's a subtle security issue with the error messages. Identify the problem and explain the security implications.",
    "constraints": "Consider what information is leaked to potential attackers through different error responses.",
    "error_handling_pattern": "Avoid leaking information about resource existence through different error types.",
    "expected_output": "**Bug:** The function returns different error types for merchant mismatch (`MandateNotFound`) vs customer mismatch (`PreconditionFailed`). This leaks information about whether a mandate exists for a given merchant.\n\n**Security Impact:** An attacker can probe mandate IDs to determine:\n1. If a mandate exists for a merchant (gets `PreconditionFailed` if it exists but customer doesn't match)\n2. If a mandate doesn't exist for a merchant (gets `MandateNotFound`)\n\nThis information disclosure could be used for reconnaissance or to validate stolen mandate IDs.\n\n**Fix:** Return the same error type for both cases:\n\n```rust\nif mandate_merchant_id != merchant_id || mandate_customer_id != customer_id {\n    Err(report!(errors::ApiErrorResponse::MandateNotFound))?\n}\nOk(())\n```\n\nOr use a generic error:\n\n```rust\nif mandate_merchant_id != merchant_id {\n    Err(report!(errors::ApiErrorResponse::MandateNotFound))?\n}\nif mandate_customer_id != customer_id {\n    Err(report!(errors::ApiErrorResponse::MandateNotFound))?\n}\nOk(())\n```\n\n**Explanation:** By returning the same error type regardless of which validation fails, we prevent information leakage about mandate existence. This follows the principle of least privilege and reduces the attack surface.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "verify_mandate_details"
      ],
      "related_files": [
        "crates/router/src/core/payments/operations.rs"
      ]
    }
  },
  {
    "id": "debug_023",
    "file_path": "crates/router/src/core/payments/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn payment_intent_status_fsm(\n    payment_method_data: Option<&api::PaymentMethodData>,\n    confirm: Option<bool>,\n) -> storage_enums::IntentStatus",
    "buggy_code": "match payment_method_data {\n    Some(_) => match confirm {\n        Some(true) => storage_enums::IntentStatus::RequiresPaymentMethod,\n        _ => storage_enums::IntentStatus::RequiresConfirmation,\n    },\n    None => storage_enums::IntentStatus::RequiresPaymentMethod,\n}",
    "prompt": "This finite state machine determines the payment intent status. There's a logical error in the state transitions. Identify what's wrong and explain the correct flow.",
    "constraints": "Compare with payment_attempt_status_fsm at lines 1412-1423. Think about what each status means.",
    "error_handling_pattern": "Ensure state machine transitions reflect the actual business logic and data availability.",
    "expected_output": "**Bug:** When `payment_method_data` is `Some(_)` and `confirm` is `Some(true)`, the function returns `RequiresPaymentMethod`, which is illogical. If payment method data is present AND the payment is confirmed, it should NOT require a payment method.\n\n**Correct Logic:**\n- If payment method data is present and confirmed → Should be in a processing state, not requiring payment method\n- If payment method data is present but not confirmed → `RequiresConfirmation`\n- If no payment method data → `RequiresPaymentMethod`\n\n**Fix:** The logic should be inverted:\n\n```rust\nmatch payment_method_data {\n    Some(_) => match confirm {\n        Some(true) => storage_enums::IntentStatus::RequiresConfirmation,  // Or Processing\n        _ => storage_enums::IntentStatus::RequiresConfirmation,\n    },\n    None => storage_enums::IntentStatus::RequiresPaymentMethod,\n}\n```\n\nOr more accurately, matching the attempt status FSM pattern:\n\n```rust\nmatch payment_method_data {\n    Some(_) => match confirm {\n        Some(true) => storage_enums::IntentStatus::Processing,  // Ready to process\n        _ => storage_enums::IntentStatus::RequiresConfirmation,\n    },\n    None => storage_enums::IntentStatus::RequiresPaymentMethod,\n}\n```\n\n**Explanation:** The payment_attempt_status_fsm at lines 1412-1423 shows the correct pattern: when payment method data exists and confirm is true, it moves to `PaymentMethodAwaited` (ready to process), not back to requiring payment method. The intent status should follow similar logic.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payment_attempt_status_fsm"
      ],
      "related_files": [
        "crates/router/src/core/payments/operations/payment_create.rs"
      ]
    }
  },
  {
    "id": "debug_024",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn files_create_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    create_file_request: api::CreateFileRequest,\n) -> RouterResponse<files::CreateFileResponse> {\n    helpers::validate_file_upload(\n        &state,\n        merchant_context.clone(),\n        create_file_request.clone(),\n    )\n    .await?;\n    let file_id = common_utils::generate_id(consts::ID_LENGTH, \"file\");",
    "buggy_code": "    let file_new: diesel_models::FileMetadataNew = diesel_models::file::FileMetadataNew {\n        file_id: file_id.clone(),\n        merchant_id: merchant_context.get_merchant_account().get_id().clone(),\n        file_name: create_file_request.file_name.clone(),\n        file_size: create_file_request.file_size,\n        file_type: create_file_request.file_type.to_string(),\n        provider_file_id: None,\n        file_upload_provider: None,\n        available: false,\n        connector_label: None,\n        profile_id: None,\n        merchant_connector_id: None,\n    };\n\n    let file_metadata_object = state\n        .store\n        .insert_file_metadata(file_new)\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Unable to insert file_metadata\")?;\n    \n    // Bug: Missing file_key generation before upload\n    let (provider_file_id, file_upload_provider, profile_id, merchant_connector_id) = Box::pin(\n        helpers::upload_and_get_provider_provider_file_id_profile_id(\n            &state,\n            &merchant_context,\n            &create_file_request,\n            file_id.clone(), // Bug: Using file_id instead of file_key\n        ),\n    )\n    .await?;",
    "prompt": "This file upload code has a logical error. The upload function expects a file_key (merchant_id/file_id format) but receives just the file_id. Identify the missing step and fix it.",
    "constraints": "The file_key should follow the format shown in lines 26-33 of crates/router/src/core/files.rs. The upload function needs this hierarchical key for proper storage organization.",
    "error_handling_pattern": "Ensure data transformations match the expected format of downstream functions. Generate composite keys before passing to storage operations.",
    "expected_output": "**Bug:** The code passes `file_id.clone()` directly to the upload function, but the function expects a `file_key` in the format `merchant_id/file_id`. This hierarchical structure is necessary for multi-tenant file organization in object storage.\n\n**Fix:** Generate the file_key before calling the upload function:\n\n```rust\nlet file_id = common_utils::generate_id(consts::ID_LENGTH, \"file\");\nlet file_key = format!(\n    \"{}/{}\",\n    merchant_context\n        .get_merchant_account()\n        .get_id()\n        .get_string_repr(),\n    file_id\n);\n\nlet file_new: diesel_models::FileMetadataNew = diesel_models::file::FileMetadataNew {\n    file_id: file_id.clone(),\n    merchant_id: merchant_context.get_merchant_account().get_id().clone(),\n    file_name: create_file_request.file_name.clone(),\n    file_size: create_file_request.file_size,\n    file_type: create_file_request.file_type.to_string(),\n    provider_file_id: None,\n    file_upload_provider: None,\n    available: false,\n    connector_label: None,\n    profile_id: None,\n    merchant_connector_id: None,\n};\n\nlet file_metadata_object = state\n    .store\n    .insert_file_metadata(file_new)\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Unable to insert file_metadata\")?;\n\nlet (provider_file_id, file_upload_provider, profile_id, merchant_connector_id) = Box::pin(\n    helpers::upload_and_get_provider_provider_file_id_profile_id(\n        &state,\n        &merchant_context,\n        &create_file_request,\n        file_key.clone(), // Now using the correct file_key\n    ),\n)\n.await?;\n```\n\n**Explanation:** The file_key format (merchant_id/file_id) is critical for multi-tenant isolation in object storage. Without it, files from different merchants could collide or be stored in the wrong location. The correct implementation is shown in crates/router/src/core/files.rs:26-33.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "upload_and_get_provider_provider_file_id_profile_id",
        "generate_id"
      ],
      "related_files": [
        "crates/router/src/core/files/helpers.rs"
      ]
    }
  },
  {
    "id": "debug_025",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();",
    "buggy_code": "    let dispute = match dispute_id {\n        Some(dispute) => Some(\n            state\n                .store\n                .find_dispute_by_merchant_id_dispute_id(\n                    merchant_context.get_merchant_account().get_id(),\n                    &dispute,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound {\n                    dispute_id: dispute,\n                })?,\n        ),\n        None => None,\n    };\n\n    // Bug: Not checking if file_metadata.available is true before retrieval\n    let connector_integration: services::BoxedFilesConnectorIntegrationInterface<\n        api::Retrieve,\n        types::RetrieveFileRequestData,\n        types::RetrieveFileResponse,\n    > = connector_data.connector.get_connector_integration();\n    let router_data = utils::construct_retrieve_file_router_data(\n        state,\n        merchant_context,\n        &file_metadata,\n        dispute,\n        connector,\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed constructing the retrieve file router data\")?;",
    "prompt": "This file retrieval function has a logical flaw. It attempts to retrieve files without checking if they're actually available. Identify the missing validation and explain why it's important.",
    "constraints": "Check the file_metadata.available field before attempting retrieval. Consider what happens if a file upload failed but the metadata record exists.",
    "error_handling_pattern": "Validate data availability before attempting operations. Return appropriate errors for unavailable resources.",
    "expected_output": "**Bug:** The function doesn't check `file_metadata.available` before attempting to retrieve the file from the connector. This can lead to failed API calls when the file upload never completed or failed, even though the metadata record exists.\n\n**Fix:** Add availability check before retrieval:\n\n```rust\nlet dispute = match dispute_id {\n    Some(dispute) => Some(\n        state\n            .store\n            .find_dispute_by_merchant_id_dispute_id(\n                merchant_context.get_merchant_account().get_id(),\n                &dispute,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound {\n                dispute_id: dispute,\n            })?,\n    ),\n    None => None,\n};\n\n// Check if file is available before attempting retrieval\nif !file_metadata.available {\n    return Err(errors::ApiErrorResponse::FileNotAvailable)\n        .attach_printable(\"File upload not completed or failed\");\n}\n\nlet connector_integration: services::BoxedFilesConnectorIntegrationInterface<\n    api::Retrieve,\n    types::RetrieveFileRequestData,\n    types::RetrieveFileResponse,\n> = connector_data.connector.get_connector_integration();\nlet router_data = utils::construct_retrieve_file_router_data(\n    state,\n    merchant_context,\n    &file_metadata,\n    dispute,\n    connector,\n)\n.await\n.change_context(errors::ApiErrorResponse::InternalServerError)\n.attach_printable(\"Failed constructing the retrieve file router data\")?;\n```\n\n**Explanation:** The two-phase commit pattern in file uploads (crates/router/src/core/files.rs:34-80) creates metadata with `available: false` initially, then updates it to `true` after successful upload. If the upload fails, the metadata remains with `available: false`. Attempting to retrieve such files would result in connector API errors since the file doesn't actually exist in storage. The availability check prevents unnecessary API calls and provides a clearer error message to users.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "files_create_core",
        "construct_retrieve_file_router_data"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/diesel_models/src/file.rs"
      ]
    }
  },
  {
    "id": "debug_026",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "#[derive(Debug, Serialize, Deserialize)]\nstruct Alpha3Request {\n    #[serde(with = \"iso_country_alpha3\")]\n    country: Country,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct NumericRequest {\n    #[serde(with = \"iso_country_numeric\")]\n    country: Country,\n}",
    "buggy_code": "    #[test]\n    fn test_serialize_alpha3() {\n        let y_request = Alpha3Request {\n            country: Country::India,\n        };\n        let serialized_country = serde_json::to_string(&y_request).unwrap();\n        assert_eq!(serialized_country, r#\"{\"country\":\"IND\"}\"#);\n\n        let y_request = Alpha3Request {\n            country: Country::HeardIslandAndMcDonaldIslands,\n        };\n        let serialized_country = serde_json::to_string(&y_request).unwrap();\n        // Bug: Wrong expected value - should be \"HMD\" not \"HMD\"\n        assert_eq!(serialized_country, r#\"{\"country\":\"HMD\"}\"#);\n\n        let y_request = Alpha3Request {\n            country: Country::Argentina,\n        };\n        let serialized_country = serde_json::to_string(&y_request).unwrap();\n        assert_eq!(serialized_country, r#\"{\"country\":\"ARG\"}\"#);\n    }",
    "prompt": "This test appears correct at first glance, but there's a subtle issue with the HeardIslandAndMcDonaldIslands test case. The comment says the expected value is wrong, but the assertion looks correct. What's the actual issue?",
    "constraints": "Look at the ISO 3166-1 alpha-3 standard for Heard Island and McDonald Islands. The test is checking serialization correctness.",
    "error_handling_pattern": "Verify test assertions match actual standards and specifications, not assumptions.",
    "expected_output": "**Bug:** This is actually a trick question - the code shown is correct! The comment \"Bug: Wrong expected value - should be 'HMD' not 'HMD'\" is misleading. The ISO 3166-1 alpha-3 code for Heard Island and McDonald Islands is indeed \"HMD\", and the test correctly asserts this.\n\n**No Fix Needed:** The test at crates/common_enums/src/transformers.rs:2288-2292 is correct as written:\n\n```rust\nlet y_request = Alpha3Request {\n    country: Country::HeardIslandAndMcDonaldIslands,\n};\nlet serialized_country = serde_json::to_string(&y_request).unwrap();\nassert_eq!(serialized_country, r#\"{\"country\":\"HMD\"}\"#);\n```\n\n**Explanation:** The test validates that the Country enum correctly serializes to ISO 3166-1 alpha-3 codes. For Heard Island and McDonald Islands, the official alpha-3 code is \"HMD\". The test suite includes similar validations for other countries (India -> \"IND\", Argentina -> \"ARG\") and all are correct. This demonstrates the importance of not assuming there's a bug just because a comment suggests it - always verify against authoritative sources.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_serialize_alpha3",
        "test_deserialize_alpha3"
      ],
      "related_files": [
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_027",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {",
    "buggy_code": "    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();\n    \n    // Bug: Not checking if file is actually available before attempting retrieval\n    let connector_data = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector,\n        api::GetToken::Connector,\n        file_metadata.merchant_connector_id.clone(),\n    )?;",
    "prompt": "This file retrieval function has a logical issue - it doesn't verify if the file is marked as available before attempting to retrieve it from the connector. Identify the missing validation and fix it.",
    "constraints": "Check the file_metadata.available field. Reference the pattern used in retrieve_file_and_provider_file_id_from_file_id at lines 219-227.",
    "error_handling_pattern": "Validate resource availability before attempting operations that depend on it.",
    "expected_output": "**Bug:** The function doesn't check if `file_metadata.available` is `true` before attempting to retrieve the file from the connector. This could lead to attempting to retrieve files that haven't been fully uploaded yet or failed uploads.\n\n**Fix:** Add availability check at the beginning:\n\n```rust\npub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    // Validate file is available\n    if !file_metadata.available {\n        return Err(errors::ApiErrorResponse::FileNotAvailable)\n            .attach_printable(\"File not available for retrieval\")?;\n    }\n    \n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();\n    \n    let connector_data = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector,\n        api::GetToken::Connector,\n        file_metadata.merchant_connector_id.clone(),\n    )?;\n    // ... rest of function\n}\n```\n\n**Explanation:** The pattern at crates/router/src/core/files/helpers.rs:219-227 shows the correct approach - checking `(provider, provider_file_id, available)` tuple and only proceeding if `available` is `true`. Without this check, the function could attempt to retrieve files that are in an incomplete state.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "retrieve_file_and_provider_file_id_from_file_id",
        "files_retrieve_core"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/hyperswitch_domain_models/src/errors/api_error_response.rs"
      ]
    }
  },
  {
    "id": "debug_028",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn files_delete_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    req: api::FileId,\n) -> RouterResponse<serde_json::Value> {",
    "buggy_code": "    helpers::delete_file_using_file_id(&state, req.file_id.clone(), &merchant_context).await?;\n    state\n        .store\n        .as_ref()\n        .delete_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &req.file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Unable to delete file_metadata\")?;\n    // Bug: Missing check if file is being used in active disputes\n    Ok(ApplicationResponse::StatusOk)\n}",
    "prompt": "This file deletion function has a logical flaw - it doesn't check if the file is currently being used as evidence in an active dispute before deleting it. Identify the missing validation.",
    "constraints": "Consider that files uploaded for disputes should not be deletable while the dispute is still open. Check dispute status before allowing deletion.",
    "error_handling_pattern": "Validate that resources are not in use before allowing deletion operations.",
    "expected_output": "**Bug:** The function deletes files without checking if they're being used as evidence in active disputes. This could lead to data loss if a merchant accidentally deletes evidence files for ongoing disputes.\n\n**Fix:** Add dispute status validation:\n\n```rust\npub async fn files_delete_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    req: api::FileId,\n) -> RouterResponse<serde_json::Value> {\n    // Check if file is used in any active disputes\n    let file_metadata = state\n        .store\n        .find_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &req.file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::FileNotFound)?;\n    \n    // If file has dispute_id, check dispute status\n    if let Some(profile_id) = file_metadata.profile_id {\n        // Query disputes that might be using this file\n        // Only allow deletion if dispute is in terminal state (Won, Lost, Cancelled)\n        let active_disputes = state\n            .store\n            .find_disputes_by_merchant_id_profile_id(\n                merchant_context.get_merchant_account().get_id(),\n                &profile_id,\n            )\n            .await?;\n        \n        for dispute in active_disputes {\n            if matches!(\n                dispute.dispute_status,\n                storage_enums::DisputeStatus::DisputeOpened\n                    | storage_enums::DisputeStatus::DisputeExpired\n                    | storage_enums::DisputeStatus::DisputeAccepted\n                    | storage_enums::DisputeStatus::DisputeChallenged\n            ) {\n                return Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"Cannot delete file - it is being used in an active dispute\".to_string(),\n                }.into());\n            }\n        }\n    }\n    \n    helpers::delete_file_using_file_id(&state, req.file_id.clone(), &merchant_context).await?;\n    state\n        .store\n        .as_ref()\n        .delete_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &req.file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Unable to delete file_metadata\")?;\n    Ok(ApplicationResponse::StatusOk)\n}\n```\n\n**Explanation:** Files uploaded for dispute evidence (crates/router/src/core/disputes.rs shows the dispute flow) should be protected from deletion while disputes are active. The fix checks if the file is associated with any open disputes before allowing deletion.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "delete_file_using_file_id",
        "find_disputes_by_merchant_id_profile_id"
      ],
      "related_files": [
        "crates/router/src/core/disputes.rs",
        "crates/diesel_models/src/dispute.rs"
      ]
    }
  },
  {
    "id": "debug_029",
    "file_path": "crates/router/src/types/api/files.rs",
    "task_type": "code_debugging",
    "context_code": "impl ForeignTryFrom<FileUploadProvider> for types::Connector {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: FileUploadProvider) -> Result<Self, Self::Error> {\n        match item {\n            FileUploadProvider::Stripe => Ok(Self::Stripe),\n            FileUploadProvider::Checkout => Ok(Self::Checkout),\n            FileUploadProvider::Worldpayvantiv => Ok(Self::Worldpayvantiv),",
    "buggy_code": "            FileUploadProvider::Router => Err(errors::ApiErrorResponse::NotSupported {\n                message: \"File upload provider is not a connector\".to_owned(),\n            }\n            .into()),\n        }\n    }\n}\n\n// Bug: Reverse conversion doesn't handle all cases\nimpl ForeignTryFrom<&types::Connector> for FileUploadProvider {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: &types::Connector) -> Result<Self, Self::Error> {\n        match *item {\n            types::Connector::Stripe => Ok(Self::Stripe),\n            types::Connector::Checkout => Ok(Self::Checkout),\n            types::Connector::Worldpayvantiv => Ok(Self::Worldpayvantiv),\n            _ => Err(errors::ApiErrorResponse::NotSupported {\n                message: \"Connector not supported as file provider\".to_owned(),\n            }\n            .into()),\n        }\n    }\n}",
    "prompt": "These conversion implementations have an asymmetry issue. The first conversion explicitly handles Router provider, but the reverse conversion uses a catch-all. Identify the logical inconsistency.",
    "constraints": "Consider what happens when you convert Router -> Connector (error) vs trying to convert back. The conversions should be symmetric where possible.",
    "error_handling_pattern": "Ensure bidirectional conversions are logically consistent and handle all cases explicitly.",
    "expected_output": "**Bug:** The conversions are asymmetric. `FileUploadProvider::Router` explicitly returns an error when converting to `Connector`, but the reverse conversion uses a catch-all `_` pattern that would also reject `Router` if it were a connector. However, the real issue is that the code doesn't make it clear that `Router` is a special case that should never be converted to a connector.\n\n**Fix:** Make both conversions explicit and symmetric:\n\n```rust\nimpl ForeignTryFrom<FileUploadProvider> for types::Connector {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: FileUploadProvider) -> Result<Self, Self::Error> {\n        match item {\n            FileUploadProvider::Stripe => Ok(Self::Stripe),\n            FileUploadProvider::Checkout => Ok(Self::Checkout),\n            FileUploadProvider::Worldpayvantiv => Ok(Self::Worldpayvantiv),\n            FileUploadProvider::Router => Err(errors::ApiErrorResponse::NotSupported {\n                message: \"Router is an internal file provider, not a connector\".to_owned(),\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ForeignTryFrom<&types::Connector> for FileUploadProvider {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: &types::Connector) -> Result<Self, Self::Error> {\n        match *item {\n            types::Connector::Stripe => Ok(Self::Stripe),\n            types::Connector::Checkout => Ok(Self::Checkout),\n            types::Connector::Worldpayvantiv => Ok(Self::Worldpayvantiv),\n            // Explicitly list unsupported connectors for clarity\n            ref connector => Err(errors::ApiErrorResponse::NotSupported {\n                message: format!(\"Connector {} not supported as file provider\", connector),\n            }\n            .into()),\n        }\n    }\n}\n```\n\n**Explanation:** The asymmetry isn't necessarily a bug, but the catch-all pattern in the reverse conversion makes it unclear which connectors are intentionally unsupported vs simply not implemented yet. Making both conversions explicit improves code clarity and maintainability.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "ForeignTryFrom"
      ],
      "related_files": [
        "crates/api_models/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_030",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn validate_file_upload(\n    state: &SessionState,\n    merchant_context: domain::MerchantContext,\n    create_file_request: api::CreateFileRequest,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    // Validate file size\n    let max_file_size = state.conf.file_storage.max_file_size;\n    if create_file_request.file_size > max_file_size {\n        return Err(errors::ApiErrorResponse::PreconditionFailed {\n            message: format!(\"File size exceeds maximum allowed size of {} bytes\", max_file_size),\n        }.into());\n    }",
    "buggy_code": "    // Bug: Not validating file_size is positive\n    // Validate file type\n    let allowed_file_types = vec![\"image/jpeg\", \"image/png\", \"application/pdf\"];\n    let file_type_str = create_file_request.file_type.to_string();\n    if !allowed_file_types.contains(&file_type_str.as_str()) {\n        return Err(errors::ApiErrorResponse::InvalidRequestData {\n            message: format!(\"File type {} is not allowed\", file_type_str),\n        }.into());\n    }\n    Ok(())\n}",
    "prompt": "This file validation function has a logical flaw - it doesn't validate that the file_size is positive. A malicious user could send a negative file size. Identify and fix this issue.",
    "constraints": "Add validation to ensure file_size is greater than 0. Consider what happens if file_size is 0 or negative.",
    "error_handling_pattern": "Always validate input ranges, especially for size/length fields that should be positive.",
    "expected_output": "**Bug:** The function validates that file_size doesn't exceed the maximum, but never checks if it's positive. A negative or zero file_size could bypass validation and cause issues downstream when allocating buffers or processing the file.\n\n**Fix:** Add validation at the beginning:\n\n```rust\npub async fn validate_file_upload(\n    state: &SessionState,\n    merchant_context: domain::MerchantContext,\n    create_file_request: api::CreateFileRequest,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    // Validate file size is positive\n    if create_file_request.file_size <= 0 {\n        return Err(errors::ApiErrorResponse::InvalidRequestData {\n            message: \"File size must be greater than 0\".to_string(),\n        }.into());\n    }\n    \n    // Validate file size doesn't exceed maximum\n    let max_file_size = state.conf.file_storage.max_file_size;\n    if create_file_request.file_size > max_file_size {\n        return Err(errors::ApiErrorResponse::PreconditionFailed {\n            message: format!(\"File size exceeds maximum allowed size of {} bytes\", max_file_size),\n        }.into());\n    }\n    \n    // Validate file type\n    let allowed_file_types = vec![\"image/jpeg\", \"image/png\", \"application/pdf\"];\n    let file_type_str = create_file_request.file_type.to_string();\n    if !allowed_file_types.contains(&file_type_str.as_str()) {\n        return Err(errors::ApiErrorResponse::InvalidRequestData {\n            message: format!(\"File type {} is not allowed\", file_type_str),\n        }.into());\n    }\n    Ok(())\n}\n```\n\n**Explanation:** Input validation should always check both upper and lower bounds. A negative file_size could cause integer overflow when allocating memory, or bypass security checks that only validate the upper limit.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "files_create_core"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/api_models/src/files.rs"
      ]
    }
  },
  {
    "id": "debug_031",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn upload_and_get_provider_provider_file_id_profile_id(\n    state: &SessionState,\n    merchant_context: &domain::MerchantContext,\n    create_file_request: &api::CreateFileRequest,\n    file_key: String,\n) -> CustomResult<(String, api_models::enums::FileUploadProvider, Option<String>, Option<String>), errors::ApiErrorResponse> {",
    "buggy_code": "    match create_file_request.purpose {\n        FilePurpose::DisputeEvidence => {\n            let dispute_id = create_file_request.dispute_id.clone()\n                .ok_or(errors::ApiErrorResponse::MissingRequiredField { field_name: \"dispute_id\" })?;\n            \n            let dispute = state\n                .store\n                .find_dispute_by_merchant_id_dispute_id(\n                    merchant_context.get_merchant_account().get_id(),\n                    &dispute_id,\n                )\n                .await\n                .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound { dispute_id: dispute_id.clone() })?;\n            \n            // Bug: Not checking if dispute is in a state that allows evidence upload\n            let connector_data = api::ConnectorData::get_connector_by_name(\n                &state.conf.connectors,\n                &dispute.connector,\n                api::GetToken::Connector,\n                dispute.merchant_connector_id.clone(),\n            )?;",
    "prompt": "This file upload function for dispute evidence has a logical issue - it doesn't validate that the dispute is in a state where evidence can be uploaded. Identify what validation is missing and fix it.",
    "constraints": "Consider dispute lifecycle states. Evidence should only be uploadable when the dispute is in certain states (e.g., 'Opened', 'UnderReview'), not when it's already 'Won', 'Lost', or 'Cancelled'.",
    "error_handling_pattern": "Validate entity state before allowing state-dependent operations.",
    "expected_output": "**Bug:** The function retrieves the dispute but doesn't check if it's in a state that allows evidence submission. Uploading evidence to a closed or cancelled dispute is illogical and wastes resources.\n\n**Fix:** Add state validation after retrieving the dispute:\n\n```rust\nlet dispute = state\n    .store\n    .find_dispute_by_merchant_id_dispute_id(\n        merchant_context.get_merchant_account().get_id(),\n        &dispute_id,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound { dispute_id: dispute_id.clone() })?;\n\n// Validate dispute state allows evidence upload\nlet allowed_states = vec![\n    storage_enums::DisputeStatus::DisputeOpened,\n    storage_enums::DisputeStatus::DisputeExpired,\n    storage_enums::DisputeStatus::DisputeChallenged,\n];\n\nif !allowed_states.contains(&dispute.dispute_status) {\n    return Err(errors::ApiErrorResponse::PreconditionFailed {\n        message: format!(\n            \"Cannot upload evidence for dispute in status: {:?}. Evidence can only be uploaded for disputes in states: {:?}\",\n            dispute.dispute_status,\n            allowed_states\n        ),\n    }.into());\n}\n\nlet connector_data = api::ConnectorData::get_connector_by_name(\n    &state.conf.connectors,\n    &dispute.connector,\n    api::GetToken::Connector,\n    dispute.merchant_connector_id.clone(),\n)?;\n```\n\n**Explanation:** Business logic should enforce state machine constraints. Once a dispute is won, lost, or cancelled, uploading evidence serves no purpose and could confuse the dispute lifecycle tracking.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "files_create_core",
        "find_dispute_by_merchant_id_dispute_id"
      ],
      "related_files": [
        "crates/router/src/core/disputes.rs",
        "crates/diesel_models/src/dispute.rs"
      ]
    }
  },
  {
    "id": "debug_032",
    "file_path": "crates/router/src/utils/db_utils.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,\n{",
    "buggy_code": "    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            // Bug: Not recording cache hit metric when Redis succeeds\n            _ => Err(redis_error.to_redis_failed_response(\"\")),\n        },\n    }\n}",
    "prompt": "This cache-first database utility function has a metrics tracking issue. Identify what metric is missing and where it should be added.",
    "constraints": "The function tracks KV_MISS when Redis returns NotFound, but doesn't track KV_HIT when Redis succeeds. This makes cache performance monitoring incomplete.",
    "error_handling_pattern": "Always track both success and failure metrics for complete observability.",
    "expected_output": "**Bug:** The function increments `KV_MISS` metric when Redis cache misses, but never increments a corresponding `KV_HIT` metric when Redis cache hits. This makes it impossible to calculate cache hit rates.\n\n**Fix:** Add cache hit metric tracking:\n\n```rust\npub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,\n{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => {\n            metrics::KV_HIT.add(1, &[]);\n            Ok(output)\n        }\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            _ => Err(redis_error.to_redis_failed_response(\"\")),\n        },\n    }\n}\n```\n\n**Explanation:** Observability requires tracking both positive and negative outcomes. Without KV_HIT metrics, you can't calculate cache hit rate (hits / (hits + misses)), which is essential for monitoring cache effectiveness and capacity planning.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "metrics::KV_MISS",
        "metrics::KV_HIT"
      ],
      "related_files": [
        "crates/router/src/routes/metrics.rs"
      ]
    }
  },
  {
    "id": "debug_033",
    "file_path": "crates/router/src/utils/db_utils.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn generate_hscan_pattern_for_refund(sk: &str) -> String {\n    sk.split('_')\n        .take(3)\n        .chain([\"*\"])\n        .collect::<Vec<&str>>()\n        .join(\"_\")\n}",
    "buggy_code": "// Bug: Function assumes refund key always has at least 3 underscore-separated parts\npub fn get_refund_prefix(refund_id: &str) -> String {\n    let pattern = generate_hscan_pattern_for_refund(refund_id);\n    // Use pattern for Redis HSCAN\n    pattern\n}",
    "prompt": "This code has a logical issue when the refund_id has fewer than 3 underscore-separated parts. Identify the problem and explain what happens with edge cases.",
    "constraints": "Consider what happens if refund_id is 'ref_123' (only 2 parts) or 'ref' (1 part). The function should handle these gracefully.",
    "error_handling_pattern": "Validate input format before processing. Handle edge cases where assumptions about data structure don't hold.",
    "expected_output": "**Bug:** The `generate_hscan_pattern_for_refund` function assumes the input string always has at least 3 underscore-separated parts (e.g., 'pa_1234_ref_1211'). If the input has fewer parts, the function still works but produces unexpected patterns:\n\n- Input 'ref_123' (2 parts) → Output 'ref_123_*' (takes all 2 parts + wildcard)\n- Input 'ref' (1 part) → Output 'ref_*' (takes 1 part + wildcard)\n\nWhile this doesn't crash, it may not match the intended Redis key pattern if the refund ID format is inconsistent.\n\n**Fix:** Add validation and document the expected format:\n\n```rust\npub fn generate_hscan_pattern_for_refund(sk: &str) -> Result<String, String> {\n    let parts: Vec<&str> = sk.split('_').collect();\n    \n    if parts.len() < 3 {\n        return Err(format!(\"Invalid refund key format: expected at least 3 parts, got {}\", parts.len()));\n    }\n    \n    Ok(parts\n        .iter()\n        .take(3)\n        .chain(&[\"*\"])\n        .copied()\n        .collect::<Vec<&str>>()\n        .join(\"_\"))\n}\n```\n\n**Explanation:** The fix validates that the input has the expected format before processing. This prevents silent failures where incorrect patterns are generated for malformed keys. The function now returns a Result, allowing callers to handle invalid formats appropriately.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "try_redis_get_else_try_database_get"
      ],
      "related_files": [
        "crates/router/src/core/refunds.rs"
      ]
    }
  },
  {
    "id": "debug_034",
    "file_path": "crates/router/src/utils/db_utils.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,",
    "buggy_code": "{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            // Bug: Empty key string in error conversion\n            _ => Err(redis_error.to_redis_failed_response(\"\")),\n        },\n    }\n}",
    "prompt": "This function has a bug in error handling - it passes an empty string to `to_redis_failed_response`. Explain why this is problematic and how to fix it.",
    "constraints": "The comment at line 34 says 'Keeping the key empty here since the error would never go here.' Analyze if this assumption is correct and what the implications are.",
    "error_handling_pattern": "Provide meaningful context in error messages. Don't assume errors 'never happen' - they often do in production.",
    "expected_output": "**Bug:** The code passes an empty string `\"\"` to `to_redis_failed_response()` with the assumption that 'the error would never go here.' This is problematic because:\n\n1. **Errors DO happen**: Redis connection failures, timeouts, serialization errors, and other non-NotFound errors occur regularly in production\n2. **Lost debugging context**: When these errors occur, the empty key makes it impossible to identify which Redis operation failed\n3. **Poor observability**: Logs and error traces lack the key information needed for debugging\n\n**Fix:** The function signature doesn't include the key, so we need to either:\n\nOption 1: Accept the key as a parameter:\n```rust\npub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n    redis_key: &str,  // Add key parameter\n) -> error_stack::Result<T, errors::StorageError>\n// ... rest of signature\n{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            _ => Err(redis_error.to_redis_failed_response(redis_key)),\n        },\n    }\n}\n```\n\nOption 2: Use a generic error message:\n```rust\n_ => Err(redis_error.to_redis_failed_response(\"redis_operation\")),\n```\n\n**Explanation:** The assumption that non-NotFound errors 'never happen' is dangerous. Redis operations can fail for many reasons (network issues, memory pressure, serialization errors). Proper error context is essential for production debugging.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "to_redis_failed_response",
        "KV_MISS"
      ],
      "related_files": [
        "crates/redis_interface/src/errors.rs",
        "crates/router/src/routes/metrics.rs"
      ]
    }
  },
  {
    "id": "debug_035",
    "file_path": "crates/kgraph_utils/benches/evaluation.rs",
    "task_type": "code_debugging",
    "context_code": "#![allow(unused, clippy::expect_used)]\n\nuse std::{collections::HashMap, str::FromStr};\n\nuse api_models::{\n    admin as admin_api, enums as api_enums, payment_methods::RequestPaymentMethodTypes,\n};\nuse common_utils::types::MinorUnit;\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};",
    "buggy_code": "#[cfg(feature = \"v1\")]\nfn build_test_data(\n    // Bug: Function is defined but never used in benchmarks\n) -> HashMap<String, Vec<RequestPaymentMethodTypes>> {\n    let mut data = HashMap::new();\n    // ... build test data\n    data\n}",
    "prompt": "This benchmark file has `#![allow(unused)]` at the top, which suppresses warnings about unused code. Identify why this is problematic for a benchmark file and what issues it might hide.",
    "constraints": "Consider that benchmarks should be actively measuring performance. The `unused` allow might hide dead code that should be removed or activated.",
    "error_handling_pattern": "Don't suppress warnings globally. Be selective about what warnings to allow and document why.",
    "expected_output": "**Bug:** The `#![allow(unused)]` directive at the top of the file suppresses all unused code warnings, which is problematic for a benchmark file because:\n\n1. **Dead code accumulation**: Functions like `build_test_data` may be defined but never actually used in any benchmark, wasting maintenance effort\n2. **Incomplete benchmarks**: The `#[cfg(feature = \"v1\")]` suggests there should be corresponding v2 benchmarks, but the `unused` allow hides whether they exist\n3. **False confidence**: Developers might think code is being benchmarked when it's actually not being called\n4. **Maintenance burden**: Unused code needs to be updated when APIs change, even though it provides no value\n\n**Fix:** Remove the global `#![allow(unused)]` and be selective:\n\n```rust\n// Remove: #![allow(unused, clippy::expect_used)]\n#![allow(clippy::expect_used)]  // Keep only this - expect_used is reasonable in benchmarks\n\n#[cfg(feature = \"v1\")]\nfn build_test_data() -> HashMap<String, Vec<RequestPaymentMethodTypes>> {\n    let mut data = HashMap::new();\n    // ... build test data\n    data\n}\n\n// Add actual benchmark that uses the function:\n#[cfg(feature = \"v1\")]\nfn bench_routing_evaluation(c: &mut Criterion) {\n    let test_data = build_test_data();\n    c.bench_function(\"routing_evaluation\", |b| {\n        b.iter(|| {\n            // Use test_data in benchmark\n            black_box(&test_data);\n        });\n    });\n}\n\n#[cfg(feature = \"v1\")]\ncriterion_group!(benches, bench_routing_evaluation);\n#[cfg(feature = \"v1\")]\ncriterion_main!(benches);\n```\n\n**Explanation:** Benchmark files should only contain code that's actively being measured. The `unused` allow hides the fact that `build_test_data` isn't connected to any actual benchmark. Either use it in a benchmark or remove it.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "criterion_group",
        "criterion_main"
      ],
      "related_files": [
        "crates/kgraph_utils/Cargo.toml"
      ]
    }
  },
  {
    "id": "debug_036",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "#[test]\nfn test_serialize_alpha3() {\n    let x_request = Alpha3Request {\n        country: Country::India,\n    };\n    let serialized_country = serde_json::to_string(&x_request).unwrap();\n    assert_eq!(serialized_country, r#\"{\"country\":\"IND\"}\"#);\n\n    let y_request = Alpha3Request {\n        country: Country::Argentina,\n    };\n    let serialized_country = serde_json::to_string(&y_request).unwrap();\n    assert_eq!(serialized_country, r#\"{\"country\":\"ARG\"}\"#);\n}",
    "buggy_code": "#[test]\nfn test_deserialize_alpha2() {\n    let request_str = r#\"{\"country\":\"IN\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::India);\n\n    let request_str = r#\"{\"country\":\"GR\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::Greece);\n\n    // Bug: Missing test case for Iraq which has special handling\n    let request_str = r#\"{\"country\":\"IQ\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::Iraq);\n}",
    "prompt": "This test function appears complete but there's a logical issue with the test coverage. Analyze the test cases and identify what's missing or could be improved for comprehensive country code testing.",
    "constraints": "Consider edge cases, special country codes, and the relationship between alpha-2 and alpha-3 codes. Check if the test validates bidirectional conversion.",
    "error_handling_pattern": "Ensure comprehensive test coverage including edge cases and bidirectional validation.",
    "expected_output": "**Issue:** While the test validates deserialization from alpha-2 codes, it doesn't test the corresponding serialization back to alpha-2 format, nor does it validate the relationship between alpha-2 and alpha-3 codes for the same countries. The test at <cite repo=\"juspay/hyperswitch\" path=\"crates/common_enums/src/transformers.rs\" start=\"2322\" end=\"2335\" /> only tests one direction.\n\n**Fix:** Add bidirectional tests and cross-validation:\n\n```rust\n#[test]\nfn test_country_code_bidirectional() {\n    // Test alpha-2 deserialization and serialization\n    let request_str = r#\"{\"country\":\"IN\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha2>(request_str).unwrap();\n    assert_eq!(request.country, Country::India);\n    let serialized = serde_json::to_string(&request).unwrap();\n    assert_eq!(serialized, request_str);\n    \n    // Test alpha-3 for same country\n    let alpha3_str = r#\"{\"country\":\"IND\"}\"#;\n    let alpha3_request = serde_json::from_str::<HyperswitchRequestAlpha3>(alpha3_str).unwrap();\n    assert_eq!(alpha3_request.country, Country::India);\n    assert_eq!(request.country, alpha3_request.country); // Same country\n    \n    // Test special cases like Iraq\n    let iraq_alpha2 = r#\"{\"country\":\"IQ\"}\"#;\n    let iraq_request = serde_json::from_str::<HyperswitchRequestAlpha2>(iraq_alpha2).unwrap();\n    assert_eq!(iraq_request.country, Country::Iraq);\n    \n    // Validate it serializes back correctly\n    let iraq_serialized = serde_json::to_string(&iraq_request).unwrap();\n    assert_eq!(iraq_serialized, iraq_alpha2);\n}\n```\n\n**Explanation:** The original test only validates one-way deserialization. A robust test should verify: (1) Deserialization from JSON to enum, (2) Serialization from enum back to JSON, (3) Consistency between alpha-2 and alpha-3 representations of the same country, (4) Round-trip conversion (deserialize → serialize → deserialize should yield the same result). This ensures the Country enum and its transformers work correctly in both directions.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "test_serialize_alpha3",
        "test_deserialize_alpha3"
      ],
      "related_files": [
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "debug_037",
    "file_path": "crates/router/src/routes/files.rs",
    "task_type": "code_debugging",
    "context_code": "#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::RetrieveFile))]\npub async fn files_retrieve(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    path: web::Path<String>,\n    json_payload: web::Query<file_types::FileRetrieveQuery>,\n) -> HttpResponse {\n    let flow = Flow::RetrieveFile;\n    let file_id = files::FileRetrieveRequest {\n        file_id: path.into_inner(),\n        dispute_id: json_payload.dispute_id.clone(),\n    };",
    "buggy_code": "    Box::pin(api::server_wrap(\n        flow,\n        state,\n        &req,\n        file_id,\n        |state, auth: auth::AuthenticationData, req, _| {\n            let merchant_context = domain::MerchantContext::NormalMerchant(Box::new(\n                domain::Context(auth.merchant_account, auth.key_store),\n            ));\n            // Bug: Not validating if the file belongs to the authenticated merchant\n            files_retrieve_core(state, merchant_context, req)\n        },\n        auth::auth_type(\n            &auth::HeaderAuth(auth::ApiKeyAuth {\n                is_connected_allowed: false,\n                is_platform_allowed: false,\n            }),\n            &auth::DashboardNoPermissionAuth,\n            req.headers(),\n        ),\n        api_locking::LockAction::NotApplicable,\n    ))\n    .await\n}",
    "prompt": "This file retrieval endpoint has a security vulnerability. The function retrieves files but doesn't validate ownership. Identify the security issue and explain how it could be exploited.",
    "constraints": "Consider multi-tenant security. The merchant_context is created from auth but the file_id comes from the path parameter. Think about what happens if a merchant tries to access another merchant's files.",
    "error_handling_pattern": "Always validate resource ownership before allowing access in multi-tenant systems.",
    "expected_output": "**Security Issue:** The endpoint creates a `merchant_context` from the authenticated merchant's credentials but doesn't validate that the requested `file_id` actually belongs to that merchant before calling `files_retrieve_core()`. A malicious merchant could potentially access files belonging to other merchants by guessing or enumerating file IDs.\n\n**Exploitation Scenario:**\n1. Merchant A authenticates and gets a valid API key\n2. Merchant A discovers or guesses a file_id belonging to Merchant B (e.g., through sequential ID enumeration)\n3. Merchant A calls GET /files/{merchant_b_file_id} with their own API key\n4. The system authenticates Merchant A successfully but doesn't check if the file belongs to them\n5. Merchant A gains unauthorized access to Merchant B's files (potentially containing sensitive dispute evidence)\n\n**Fix:** The validation should happen in `files_retrieve_core()` at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/core/files.rs\" start=\"105\" end=\"140\" />. The function already calls `find_file_metadata_by_merchant_id_file_id()` at lines 110-119, which includes the merchant_id in the query. This provides the protection - if the file doesn't belong to the merchant, the database query will fail with `FileNotFound`. However, the error message should be carefully crafted to avoid information disclosure:\n\n```rust\n.find_file_metadata_by_merchant_id_file_id(\n    merchant_context.get_merchant_account().get_id(),\n    &req.file_id,\n)\n.await\n.change_context(errors::ApiErrorResponse::FileNotFound)\n.attach_printable(\"File not found or access denied\")?; // Don't reveal if file exists for another merchant\n```\n\n**Explanation:** The current implementation at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/core/files.rs\" start=\"110\" end=\"119\" /> is actually secure because it queries by both merchant_id AND file_id. If a merchant tries to access another merchant's file, the query returns no results and fails with FileNotFound. The key security principle here is that the database query itself enforces the ownership check by including merchant_id in the WHERE clause, preventing cross-tenant data access.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "files_retrieve_core",
        "find_file_metadata_by_merchant_id_file_id"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/diesel_models/src/file.rs"
      ]
    }
  },
  {
    "id": "debug_038",
    "file_path": "crates/router/src/utils/db_utils.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,",
    "buggy_code": "{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            // Bug: Empty key string doesn't provide useful error context\n            _ => Err(redis_error.to_redis_failed_response(\"\")),\n        },\n    }\n}",
    "prompt": "This Redis fallback function has a logical issue with error handling. When Redis errors occur (other than NotFound), it passes an empty string as the key parameter. Identify why this is problematic and how to fix it.",
    "constraints": "Consider that error messages should be informative for debugging. The function signature doesn't provide access to the actual key being queried.",
    "error_handling_pattern": "Provide meaningful error context in error messages. Consider function signature limitations when designing error handling.",
    "expected_output": "**Bug:** The function passes an empty string `\"\"` to `to_redis_failed_response()` when Redis errors occur. This makes debugging difficult because error logs won't show which key caused the failure. However, the function signature doesn't include the key as a parameter, so there's no way to access it.\n\n**Fix:** There are two approaches:\n\n**Option 1:** Add a key parameter to the function signature:\n\n```rust\npub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n    key: &str,  // Add key parameter\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,\n{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                metrics::KV_MISS.add(1, &[]);\n                database_call_closure().await\n            }\n            _ => Err(redis_error.to_redis_failed_response(key)),\n        },\n    }\n}\n```\n\n**Option 2:** Use a generic error message:\n\n```rust\n_ => Err(redis_error.to_redis_failed_response(\"redis_cache_lookup\")),\n```\n\n**Explanation:** The comment at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/utils/db_utils.rs\" start=\"34\" end=\"35\" /> acknowledges this limitation but doesn't explain why. The empty string makes error tracking difficult in production. Option 1 is better for debugging but requires updating all call sites. Option 2 is a quick fix that at least provides some context about where the error occurred.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "to_redis_failed_response",
        "KV_MISS"
      ],
      "related_files": [
        "crates/router/src/core/errors.rs",
        "crates/router/src/routes/metrics.rs"
      ]
    }
  },
  {
    "id": "debug_039",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn files_retrieve_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    req: api::FileRetrieveRequest,\n) -> RouterResponse<serde_json::Value> {\n    let file_metadata_object = state\n        .store\n        .as_ref()\n        .find_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &req.file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::FileNotFound)\n        .attach_printable(\"Unable to retrieve file_metadata\")?;",
    "buggy_code": "    let file_info = helpers::retrieve_file_and_provider_file_id_from_file_id(\n        &state,\n        Some(req.file_id),\n        req.dispute_id,\n        &merchant_context,\n        api::FileDataRequired::Required,\n    )\n    .await?;\n    // Bug: Not checking if file_info.file_data is actually present before unwrapping\n    let content_type = file_metadata_object\n        .file_type\n        .parse::<mime::Mime>()\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed to parse file content type\")?;\n    Ok(ApplicationResponse::FileData((\n        file_info.file_data.ok_or(errors::ApiErrorResponse::FileNotAvailable)?,\n        content_type,\n    )))",
    "prompt": "This file retrieval function has a logical issue with the order of operations. Identify the inefficiency and potential problem with parsing the content type before checking if file data exists.",
    "constraints": "Consider the cost of parsing MIME types and when errors should be checked. Think about the order of operations for optimal error handling.",
    "error_handling_pattern": "Check for data availability before performing expensive operations on metadata. Fail fast on missing data.",
    "expected_output": "**Bug:** The function parses the `content_type` from `file_metadata_object.file_type` before checking if `file_info.file_data` actually exists. This is inefficient because:\n\n1. If the file data is not available, the MIME type parsing is wasted work\n2. The error message will be about content type parsing failure rather than the more relevant \"file not available\" error\n3. It violates the principle of failing fast on the most likely error condition\n\n**Fix:** Reorder the operations to check file data availability first:\n\n```rust\nlet file_info = helpers::retrieve_file_and_provider_file_id_from_file_id(\n    &state,\n    Some(req.file_id),\n    req.dispute_id,\n    &merchant_context,\n    api::FileDataRequired::Required,\n)\n.await?;\n\n// Check file data availability first\nlet file_data = file_info\n    .file_data\n    .ok_or(errors::ApiErrorResponse::FileNotAvailable)\n    .attach_printable(\"File data not found\")?;\n\n// Only parse content type if we have file data\nlet content_type = file_metadata_object\n    .file_type\n    .parse::<mime::Mime>()\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to parse file content type\")?;\n\nOk(ApplicationResponse::FileData((file_data, content_type)))\n```\n\n**Explanation:** The current implementation at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/core/files.rs\" start=\"128\" end=\"140\" /> performs the MIME type parsing before checking if file data exists. By reordering, we fail fast if the file isn't available and only do the parsing work when we know we'll need it. This is especially important since `parse::<mime::Mime>()` can be expensive for complex MIME types.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "retrieve_file_and_provider_file_id_from_file_id",
        "parse"
      ],
      "related_files": [
        "crates/router/src/core/files/helpers.rs",
        "crates/router/src/services.rs"
      ]
    }
  },
  {
    "id": "debug_040",
    "file_path": "crates/router/src/types/api/files.rs",
    "task_type": "code_debugging",
    "context_code": "impl ForeignTryFrom<FileUploadProvider> for types::Connector {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: FileUploadProvider) -> Result<Self, Self::Error> {\n        match item {\n            FileUploadProvider::Stripe => Ok(Self::Stripe),\n            FileUploadProvider::Checkout => Ok(Self::Checkout),\n            FileUploadProvider::Worldpayvantiv => Ok(Self::Worldpayvantiv),",
    "buggy_code": "            FileUploadProvider::Router => Err(errors::ApiErrorResponse::NotSupported {\n                message: \"File upload provider is not a connector\".to_owned(),\n            }\n            .into()),\n        }\n    }\n}\n\nimpl ForeignTryFrom<&types::Connector> for FileUploadProvider {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: &types::Connector) -> Result<Self, Self::Error> {\n        match *item {\n            types::Connector::Stripe => Ok(Self::Stripe),\n            types::Connector::Checkout => Ok(Self::Checkout),\n            types::Connector::Worldpayvantiv => Ok(Self::Worldpayvantiv),\n            // Bug: Missing catch-all pattern for unsupported connectors\n        }\n    }\n}",
    "prompt": "This bidirectional conversion implementation has an asymmetry issue. The first conversion handles the Router case explicitly, but the second conversion is missing a catch-all pattern. Identify the problem and fix it.",
    "constraints": "Consider what happens when a connector that doesn't support file uploads is passed to the second conversion. The pattern should match the first conversion's approach.",
    "error_handling_pattern": "Ensure bidirectional conversions are symmetric and handle all cases consistently. Use catch-all patterns for unsupported variants.",
    "expected_output": "**Bug:** The second `ForeignTryFrom` implementation (converting `&types::Connector` to `FileUploadProvider`) is missing a catch-all pattern to handle connectors that don't support file uploads. This will cause a compilation error because the match is non-exhaustive - there are many more `types::Connector` variants than just Stripe, Checkout, and Worldpayvantiv.\n\n**Fix:** Add a catch-all pattern that mirrors the first conversion's error handling:\n\n```rust\nimpl ForeignTryFrom<&types::Connector> for FileUploadProvider {\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: &types::Connector) -> Result<Self, Self::Error> {\n        match *item {\n            types::Connector::Stripe => Ok(Self::Stripe),\n            types::Connector::Checkout => Ok(Self::Checkout),\n            types::Connector::Worldpayvantiv => Ok(Self::Worldpayvantiv),\n            _ => Err(errors::ApiErrorResponse::NotSupported {\n                message: \"Connector not supported as file provider\".to_owned(),\n            }\n            .into()),\n        }\n    }\n}\n```\n\n**Explanation:** The first conversion at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/types/api/files.rs\" start=\"30\" end=\"43\" /> explicitly handles the `Router` case with an error. The second conversion at <cite repo=\"juspay/hyperswitch\" path=\"crates/router/src/types/api/files.rs\" start=\"45\" end=\"58\" /> should similarly handle all other connectors that don't support file uploads. The asymmetry exists because `FileUploadProvider` is a small enum (4 variants) while `types::Connector` has 100+ variants. The catch-all pattern ensures any connector not explicitly listed returns a clear error message.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "ForeignTryFrom"
      ],
      "related_files": [
        "crates/api_models/src/enums.rs",
        "crates/router/src/types/mod.rs"
      ]
    }
  },
  {
    "id": "debug_041",
    "file_path": "crates/test_utils/tests/connectors/selenium.rs",
    "task_type": "code_debugging",
    "context_code": "#[macro_export]\nmacro_rules! function {\n    () => {{\n        fn f() {}\n        fn type_name_of<T>(_: T) -> &'static str {\n            std::any::type_name::<T>()\n        }\n        let name = type_name_of(f);\n        &name.get(..name.len() - 3).unwrap()\n    }};\n}",
    "buggy_code": "        let name = type_name_of(f);\n        &name.get(..name.len() - 3).unwrap()",
    "prompt": "The `function!` macro is designed to extract the current function name for test identification. However, the string slicing logic assumes all function names end with exactly 3 characters (like \"::f\"), which can cause panics if the function name is shorter than expected. Fix the slicing to be more robust.",
    "constraints": "Maintain the macro's purpose of extracting function names without changing the overall approach.",
    "error_handling_pattern": "Use safer string slicing with bounds checking to prevent panics on short function names.",
    "expected_output": "        let name = type_name_of(f);\n        &name.get(..name.len().saturating_sub(3)).unwrap_or(&name)",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "function!",
        "type_name_of"
      ],
      "related_files": [
        "crates/test_utils/tests/connectors/selenium.rs"
      ]
    }
  },
  {
    "id": "debug_042",
    "file_path": "crates/common_utils/src/id_type.rs",
    "task_type": "code_debugging",
    "context_code": "const VALID_UNDERSCORE_ID_JSON: &str = r#\"\"cus_abcdefghijklmnopqrstuv\"\"#;\nconst EXPECTED_VALID_UNDERSCORE_ID: &str = \"cus_abcdefghijklmnopqrstuv\";\n\nconst VALID_HYPHEN_ID_JSON: &str = r#\"\"cus-abcdefghijklmnopqrstuv\"\"#;\nconst VALID_HYPHEN_ID_STRING: &str = \"cus-abcdefghijklmnopqrstuv\";\n\nconst INVALID_ID_WITH_SPACES: &str = r#\"\"cus abcdefghijklmnopqrstuv\"\"#;\nconst INVALID_ID_WITH_EMOJIS: &str = r#\"\"cus_abc🦀\"\"#;",
    "buggy_code": "const INVALID_ID_WITH_EMOJIS: &str = r#\"\"cus_abc🦀\"\"#;",
    "prompt": "The test constant `INVALID_ID_WITH_EMOJIS` contains a crab emoji which may cause encoding issues in different environments. The test should use a more reliable invalid character that's consistently handled across platforms.",
    "constraints": "Keep the test purpose of validating emoji rejection but use a more universally handled invalid character.",
    "error_handling_pattern": "Replace platform-specific problematic characters with standard ASCII invalid characters for consistent test behavior.",
    "expected_output": "const INVALID_ID_WITH_EMOJIS: &str = r#\"\"cus_abc@\"\"#;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_id_deserialize_with_emojis"
      ],
      "related_files": [
        "crates/common_utils/src/id_type.rs"
      ]
    }
  },
  {
    "id": "debug_043",
    "file_path": "crates/masking/src/secret.rs",
    "task_type": "code_debugging",
    "context_code": "fn test_json_mask_strategy() {\n    // Create a sample JSON with different types for testing\n    let original = json!({ \"user\": { \"name\": \"John Doe\", \"email\": \"john@example.com\", \"age\": 35, \"verified\": true }, \"card\": { \"number\": \"4242424242424242\", \"cvv\": 123, \"amount\": 99.99 }, \"tags\": [\"personal\", \"premium\"], \"null_value\": null, \"short\": \"hi\" });",
    "buggy_code": "    let original = json!({ \"user\": { \"name\": \"John Doe\", \"email\": \"john@example.com\", \"age\": 35, \"verified\": true }, \"card\": { \"number\": \"4242424242424242\", \"cvv\": 123, \"amount\": 99.99 }, \"tags\": [\"personal\", \"premium\"], \"null_value\": null, \"short\": \"hi\" });",
    "prompt": "The test data contains hardcoded PII (personally identifiable information) including a real name and email address. This violates security best practices for test code and should use mock/test data instead.",
    "constraints": "Maintain the test structure while replacing real PII with clearly fake test data.",
    "error_handling_pattern": "Replace real PII with mock data that follows the same format but is clearly identifiable as test data.",
    "expected_output": "    let original = json!({ \"user\": { \"name\": \"Test User\", \"email\": \"test@example.com\", \"age\": 35, \"verified\": true }, \"card\": { \"number\": \"4242424242424242\", \"cvv\": 123, \"amount\": 99.99 }, \"tags\": [\"personal\", \"premium\"], \"null_value\": null, \"short\": \"hi\" });",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_json_mask_strategy"
      ],
      "related_files": [
        "crates/masking/src/secret.rs"
      ]
    }
  },
  {
    "id": "debug_044",
    "file_path": "crates/euclid/src/frontend/dir.rs",
    "task_type": "code_debugging",
    "context_code": "fn test_consistent_dir_key_naming() {\n        let mut key_names: FxHashMap<DirKeyKind, String> = FxHashMap::default();\n\n        for key in DirKeyKind::iter() {\n            if matches!(key, DirKeyKind::Connector) {\n                continue;\n            }\n\n            let json_str = if let DirKeyKind::MetaData = key {\n                r#\"\"metadata\"\"#.to_string()\n            } else {\n                serde_json::to_string(&key).expect(\"JSON Serialization\")\n            };",
    "buggy_code": "            let json_str = if let DirKeyKind::MetaData = key {\n                r#\"\"metadata\"\"#.to_string()\n            } else {\n                serde_json::to_string(&key).expect(\"JSON Serialization\")\n            };",
    "prompt": "The test has inconsistent handling of the `MetaData` variant, using a hardcoded string instead of serialization like other variants. This creates a special case that could mask serialization issues for the MetaData variant.",
    "constraints": "Ensure all variants are tested consistently through the same serialization path.",
    "error_handling_pattern": "Remove special-case handling and test all variants through the same serialization mechanism.",
    "expected_output": "            let json_str = serde_json::to_string(&key).expect(\"JSON Serialization\");",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "test_consistent_dir_key_naming"
      ],
      "related_files": [
        "crates/euclid/src/frontend/dir.rs"
      ]
    }
  },
  {
    "id": "debug_045",
    "file_path": "crates/common_types/src/payments.rs",
    "task_type": "code_debugging",
    "context_code": "#[derive(\n    Default,\n    Eq,\n    PartialEq,\n    Debug,\n    serde::Deserialize,\n    serde::Serialize,\n    AsExpression,\n    Clone,\n    ToSchema,\n    SmithyModel,\n)]\n#[serde(deny_unknown_fields)]\n/// Details of online mandate\n#[diesel(sql_type = Jsonb)]\n#[smithy(namespace = \"com.hyperswitch.smithy.types\")]\npub struct OnlineMandate {\n    /// Ip address of the customer machine from which the mandate was created\n    #[schema(value_type = String, example = \"123.32.25.123\")]\n    #[smithy(value_type = \"String\")]\n    pub ip_address: Option<Secret<String, pii::IpAddress>>,\n    /// The user-agent of the customer's browser\n    #[smithy(value_type = \"String\")]\n    pub user_agent: String,\n}",
    "buggy_code": "    #[serde(deny_unknown_fields)]",
    "prompt": "The `OnlineMandate` struct uses `#[serde(deny_unknown_fields)]` which makes it brittle to future additions. If new optional fields are added to the API response, deserialization will fail instead of gracefully ignoring unknown fields.",
    "constraints": "Maintain backward compatibility while allowing for future field additions.",
    "error_handling_pattern": "Remove strict field validation to allow graceful handling of future API extensions.",
    "expected_output": "",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "OnlineMandate"
      ],
      "related_files": [
        "crates/common_types/src/payments.rs"
      ]
    }
  },
  {
    "id": "debug_046",
    "file_path": "crates/router_derive/src/lib.rs",
    "task_type": "code_debugging",
    "context_code": "#[proc_macro_attribute]\npub fn diesel_enum(\n    args: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n    let args_parsed = parse_macro_input!(args as DieselEnumMeta);\n    let item = syn::parse_macro_input!(item as syn::ItemEnum);\n\n    macros::diesel::diesel_enum_attribute_macro(args_parsed, &item)\n        .unwrap_or_else(|error| error.to_compile_error())\n        .into()\n}",
    "buggy_code": "        .unwrap_or_else(|error| error.to_compile_error())",
    "prompt": "The diesel_enum macro is using unwrap_or_else to convert compilation errors to compile_error, but this approach loses the original error context and makes debugging difficult for users. Improve the error handling to preserve more context.",
    "constraints": "Maintain the macro's functionality while providing better error reporting.",
    "error_handling_pattern": "Enhance error reporting in procedural macros to provide more context about what went wrong.",
    "expected_output": "        .map_err(|error| {\n            let span = error.span();\n            let message = format!(\"diesel_enum macro error: {}\", error);\n            quote::quote_spanned!(span => compile_error!(#message))\n        })\n        .unwrap_or_else(|tokens| tokens.into())",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "diesel_enum",
        "diesel_enum_attribute_macro"
      ],
      "related_files": [
        "crates/router_derive/src/lib.rs",
        "crates/router_derive/src/macros/diesel.rs"
      ]
    }
  },
  {
    "id": "debug_047",
    "file_path": "crates/router_derive/src/lib.rs",
    "task_type": "code_debugging",
    "context_code": "#[proc_macro_derive(Setter, attributes(auth_based))]\npub fn setter(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let input = syn::parse_macro_input!(input as syn::DeriveInput);\n    let ident = &input.ident;\n    let fields = if let syn::Data::Struct(syn::DataStruct {\n        fields: syn::Fields::Named(syn::FieldsNamed { ref named, .. }),\n        ..\n    }) = input.data\n    {\n        named\n    } else {\n        panic!(\"You can't use this proc-macro on structs without fields\");\n    };",
    "buggy_code": "        panic!(\"You can't use this proc-macro on structs without fields\");",
    "prompt": "The Setter derive macro uses panic! for error handling, which causes the entire compilation to fail with an unhelpful message. Replace this with proper compile_error! to provide better error messages.",
    "constraints": "Replace panic! with compile_error! while maintaining the same validation logic.",
    "error_handling_pattern": "Use compile_error! macro instead of panic! in procedural macros for better error reporting.",
    "expected_output": "        return quote::quote!(compile_error!(\"Setter derive macro can only be used on structs with named fields\")).into();",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "setter",
        "check_if_auth_based_attr_is_present"
      ],
      "related_files": [
        "crates/router_derive/src/lib.rs"
      ]
    }
  },
  {
    "id": "debug_048",
    "file_path": "crates/router/tests/connectors/dlocal.rs",
    "task_type": "code_debugging",
    "context_code": "// Captures a payment using invalid connector payment id.\n#[actix_web::test]\nasync fn should_fail_capture_for_invalid_payment() {\n    let capture_response = CONNECTOR\n        .capture_payment(\"123456sdf789\".to_string(), None, Some(get_payment_info()))\n        .await\n        .unwrap();\n    let x = capture_response.response.unwrap_err();\n    assert_eq!(x.code, \"3003\");\n}",
    "buggy_code": "    let capture_response = CONNECTOR\n        .capture_payment(\"123456sdf789\".to_string(), None, Some(get_payment_info()))\n        .await\n        .unwrap();",
    "prompt": "The test is calling unwrap() on the capture_payment response, but this test is specifically designed to test error cases. If the unwrap() fails due to a network error or other unexpected issue, the test will panic instead of properly testing the business logic error.",
    "constraints": "Maintain the test's purpose while making it more robust against unexpected failures.",
    "error_handling_pattern": "Handle Result types properly in tests to distinguish between expected business logic errors and unexpected system failures.",
    "expected_output": "    let capture_response = CONNECTOR\n        .capture_payment(\"123456sdf789\".to_string(), None, Some(get_payment_info()))\n        .await\n        .expect(\"Network or system error during capture\");",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "should_fail_capture_for_invalid_payment",
        "get_payment_info"
      ],
      "related_files": [
        "crates/router/tests/connectors/dlocal.rs"
      ]
    }
  },
  {
    "id": "debug_049",
    "file_path": "crates/router/tests/connectors/dlocal.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn get_payment_info() -> PaymentInfo {\n    PaymentInfo {\n        address: Some(PaymentAddress::new(\n            None,\n            Some(Address {\n                phone: None,\n                address: Some(AddressDetails {\n                    city: None,\n                    country: Some(api_models::enums::CountryAlpha2::PA),\n                    line1: None,\n                    line2: None,\n                    line3: None,\n                    zip: None,\n                    state: None,\n                    first_name: None,\n                    last_name: None,\n                    origin_zip: None,\n                }),\n                email: None,\n            }),\n            None,\n            None,\n        )),\n        auth_type: None,\n        access_token: None,\n        connector_meta_data: None,\n        ..Default::default()\n    }\n}",
    "buggy_code": "                    country: Some(api_models::enums::CountryAlpha2::PA),",
    "prompt": "The get_payment_info function hardcodes the country to PA (Panama), which may not be appropriate for all test scenarios. This could cause tests to fail when testing country-specific payment methods or validation logic.",
    "constraints": "Make the country configurable while maintaining backward compatibility for existing tests.",
    "error_handling_pattern": "Parameterize test data to make it more flexible and reusable across different test scenarios.",
    "expected_output": "                    country: Some(api_models::enums::CountryAlpha2::US),",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_payment_info",
        "should_fail_capture_for_invalid_payment"
      ],
      "related_files": [
        "crates/router/tests/connectors/dlocal.rs"
      ]
    }
  },
  {
    "id": "debug_050",
    "file_path": "crates/kgraph_utils/benches/evaluation.rs",
    "task_type": "code_debugging",
    "context_code": "#[cfg(feature = \"v1\")]\nfn build_test_data(\n    total_enabled: usize,\n    total_pm_types: usize,\n) -> hyperswitch_constraint_graph::ConstraintGraph<dir::DirValue> {\n    use api_models::{admin::*, payment_methods::*};\n\n    let mut pms_enabled: Vec<PaymentMethodsEnabled> = Vec::new();\n\n    for _ in (0..total_enabled) {",
    "buggy_code": "    for _ in (0..total_enabled) {",
    "prompt": "The build_test_data function uses an incorrect range syntax. The range (0..total_enabled) creates a range from 0 to total_enabled, but the underscore pattern ignores the iterator values, which could lead to confusion about the loop's purpose.",
    "constraints": "Fix the range syntax while maintaining the loop's functionality.",
    "error_handling_pattern": "Use correct Rust range syntax for iteration loops.",
    "expected_output": "    for _ in 0..total_enabled {",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "build_test_data",
        "evaluation"
      ],
      "related_files": [
        "crates/kgraph_utils/benches/evaluation.rs"
      ]
    }
  },
  {
    "id": "debug_051",
    "file_path": "crates/kgraph_utils/benches/evaluation.rs",
    "task_type": "code_debugging",
    "context_code": "        for _ in (0..total_pm_types) {\n            pm_types.push(RequestPaymentMethodTypes {\n                payment_method_type: api_enums::PaymentMethodType::Credit,\n                payment_experience: None,\n                card_networks: Some(vec![\n                    api_enums::CardNetwork::Visa,\n                    api_enums::CardNetwork::Mastercard,\n                ]),\n                accepted_currencies: Some(AcceptedCurrencies::EnableOnly(vec![\n                    api_enums::Currency::USD,\n                    api_enums::Currency::INR,\n                ])),\n                accepted_countries: None,\n                minimum_amount: Some(MinorUnit::new(10)),\n                maximum_amount: Some(MinorUnit::new(1000)),\n                recurring_enabled: Some(true),\n                installment_payment_enabled: Some(true),\n            });\n        }",
    "buggy_code": "                minimum_amount: Some(MinorUnit::new(10)),\n                maximum_amount: Some(MinorUnit::new(1000)),",
    "prompt": "The benchmark test data uses hardcoded amounts (10 and 1000) which may not be realistic for all payment methods. Some payment methods have different minimum and maximum amount requirements, making this test data potentially invalid for certain scenarios.",
    "constraints": "Make the amounts more realistic while keeping the test functional.",
    "error_handling_pattern": "Use realistic test data that reflects actual payment method constraints.",
    "expected_output": "                minimum_amount: Some(MinorUnit::new(100)),\n                maximum_amount: Some(MinorUnit::new(10000)),",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "build_test_data"
      ],
      "related_files": [
        "crates/kgraph_utils/benches/evaluation.rs"
      ]
    }
  },
  {
    "id": "debug_052",
    "file_path": "crates/kgraph_utils/benches/evaluation.rs",
    "task_type": "code_debugging",
    "context_code": "    let stripe_account = MerchantConnectorResponse {\n        connector_type: api_enums::ConnectorType::FizOperations,\n        connector_name: \"stripe\".to_string(),\n        merchant_connector_id:\n            common_utils::generate_merchant_connector_account_id_of_default_length(),\n        connector_account_details: masking::Secret::new(serde_json::json!({})),\n        test_mode: None,\n        disabled: None,\n        metadata: None,\n        payment_methods_enabled: Some(pms_enabled),\n        business_country: Some(api_enums::CountryAlpha2::US),\n        business_label: Some(\"hello\".to_string()),\n        connector_label: Some(\"something\".to_string()),\n        business_sub_label: Some(\"something\".to_string()),",
    "buggy_code": "        business_label: Some(\"hello\".to_string()),\n        connector_label: Some(\"something\".to_string()),\n        business_sub_label: Some(\"something\".to_string()),",
    "prompt": "The test data uses placeholder strings like \"hello\" and \"something\" for business labels. These non-descriptive values make debugging difficult and don't reflect realistic business scenarios.",
    "constraints": "Replace placeholder strings with more descriptive test data.",
    "error_handling_pattern": "Use meaningful test data that helps with debugging and reflects real-world scenarios.",
    "expected_output": "        business_label: Some(\"test_business\".to_string()),\n        connector_label: Some(\"stripe_test\".to_string()),\n        business_sub_label: Some(\"test_sub_business\".to_string()),",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "build_test_data"
      ],
      "related_files": [
        "crates/kgraph_utils/benches/evaluation.rs"
      ]
    }
  },
  {
    "id": "debug_053",
    "file_path": "crates/hyperswitch_interfaces/src/conversion_impls.rs",
    "task_type": "code_debugging",
    "context_code": "impl<T, Req: Clone, Resp: Clone> RouterDataConversion<T, Req, Resp> for ExternalVaultProxyFlowData {\n    fn from_old_router_data(\n        old_router_data: &RouterData<T, Req, Resp>,\n    ) -> CustomResult<RouterDataV2<T, Self, Req, Resp>, ConnectorError>\n    where\n        Self: Sized,\n    {",
    "buggy_code": "    fn from_old_router_data(",
    "prompt": "The conversion trait implementation is missing the corresponding to_old_router_data method, making the conversion asymmetric. This could cause issues when trying to convert back from V2 to V1 format.",
    "constraints": "Implement the missing method to make the conversion bidirectional.",
    "error_handling_pattern": "Ensure trait implementations are complete and symmetric where applicable.",
    "expected_output": "    fn to_old_router_data(\n        new_router_data: &RouterDataV2<T, Self, Req, Resp>,\n    ) -> CustomResult<RouterData<T, Req, Resp>, ConnectorError>\n    where\n        Self: Sized,\n    {",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "from_old_router_data",
        "RouterDataConversion"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/conversion_impls.rs"
      ]
    }
  },
  {
    "id": "debug_054",
    "file_path": "crates/router/tests/connectors/bluesnap.rs",
    "task_type": "code_debugging",
    "context_code": "// Connector dependent test cases goes here\n\n// [#478]: add unit tests for non 3DS, wallets & webhooks in connector tests",
    "buggy_code": "// Connector dependent test cases goes here",
    "prompt": "The comment indicates this section should contain connector-dependent test cases, but the section is empty. This suggests missing test coverage for Bluesnap-specific scenarios.",
    "constraints": "Add basic connector-specific test cases for Bluesnap.",
    "error_handling_pattern": "Ensure comprehensive test coverage for connector-specific functionality.",
    "expected_output": "// Test Bluesnap-specific payment scenarios\n#[actix_web::test]\nasync fn should_handle_bluesnap_specific_response_format() {\n    // Test implementation for Bluesnap-specific response parsing\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": [
        "crates/router/tests/connectors/bluesnap.rs"
      ]
    }
  },
  {
    "id": "debug_055",
    "file_path": "crates/hyperswitch_connectors/src/connectors/adyen/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "fn get_defence_documents(\n    evidence_request: api_models::disputes::DisputeEvidenceRequest,\n) -> CustomResult<Vec<api_models::disputes::DefenseDocuments>, errors::ApiErrorResponse> {\n    let mut defense_documents: Vec<api_models::disputes::DefenseDocuments> = vec![];\n\n    if let Some(shipping_documentation) = evidence_request.shipping_documentation {\n        defense_documents.push(DefenseDocuments {\n            content: get_content(shipping_documentation).into(),\n            content_type: item.receipt_file_type,\n            defense_document_type_code: \"DefenseMaterial\".into(),\n        })\n    }",
    "buggy_code": "            content_type: item.receipt_file_type,",
    "prompt": "The shipping documentation evidence is incorrectly using the receipt file type instead of the shipping documentation file type. This will cause incorrect content type metadata to be sent to the connector.",
    "constraints": "Use the correct file type for each evidence type.",
    "error_handling_pattern": "Ensure each evidence type uses its corresponding file type field.",
    "expected_output": "            content_type: item.shipping_documentation_file_type,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_defence_documents"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/adyen/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_056",
    "file_path": "crates/hyperswitch_connectors/src/connectors/checkout/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "pub struct Evidence {\n    pub proof_of_delivery_or_service_file: Option<String>,\n    pub invoice_or_receipt_file: Option<String>,\n    pub invoice_showing_distinct_transactions_file: Option<String>,\n    pub customer_communication_file: Option<String>,\n    pub refund_or_cancellation_policy_file: Option<String>,\n    pub recurring_transaction_agreement_file: Option<String>,\n    pub additional_evidence_file: Option<String>,\n}",
    "buggy_code": "    pub additional_evidence_file: Option<String>,",
    "prompt": "The Evidence struct is missing the uncategorized_file field that is present in other connector implementations. This will cause incomplete evidence submission for Checkout connector.",
    "constraints": "Add the missing uncategorized_file field to match the standard evidence structure.",
    "error_handling_pattern": "Ensure all evidence structs have consistent field definitions across connectors.",
    "expected_output": "    pub additional_evidence_file: Option<String>,\n    pub uncategorized_file: Option<String>,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "Evidence"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/checkout/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_057",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn files_delete_core(\n    state: SessionState,\n    platform: domain::Platform,\n    req: api::FileId,\n) -> RouterResponse<serde_json::Value> {\n    helpers::delete_file_using_file_id(&state, req.file_id.clone(), &platform).await?;\n    state\n        .store\n        .as_ref()\n        .delete_file_metadata_by_merchant_id_file_id(\n            platform.get_processor().get_account().get_id(),\n            &req.file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Unable to delete file_metadata\")?;\n    Ok(ApplicationResponse::StatusOk)\n}",
    "buggy_code": "    helpers::delete_file_using_file_id(&state, req.file_id.clone(), &platform).await?;",
    "prompt": "The file deletion function deletes the file from storage first, then attempts to delete the metadata. If the metadata deletion fails, the file is already deleted but the operation returns an error, leaving the system in an inconsistent state.",
    "constraints": "Ensure atomic deletion of both file and metadata or proper rollback mechanism.",
    "error_handling_pattern": "Implement transaction-like behavior for file deletion operations.",
    "expected_output": "    let file_id = req.file_id.clone();\n    // Delete metadata first to maintain consistency\n    state\n        .store\n        .as_ref()\n        .delete_file_metadata_by_merchant_id_file_id(\n            platform.get_processor().get_account().get_id(),\n            &file_id,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Unable to delete file_metadata\")?;\n    \n    // Delete actual file after metadata is successfully deleted\n    helpers::delete_file_using_file_id(&state, file_id, &platform).await?;",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "files_delete_core",
        "delete_file_using_file_id"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/router/src/core/files/helpers.rs"
      ]
    }
  },
  {
    "id": "debug_058",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    platform: &domain::Platform,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();",
    "buggy_code": "            .ok_or(errors::ApiErrorResponse::InternalServerError)",
    "prompt": "The error handling for missing file upload provider uses a generic InternalServerError. This should use a more specific error code to help with debugging.",
    "constraints": "Use a more specific error type for missing provider information.",
    "error_handling_pattern": "Provide specific error codes for different failure scenarios.",
    "expected_output": "            .ok_or(errors::ApiErrorResponse::MissingRequiredField { field_name: \"file_upload_provider\".to_string() })",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "retrieve_file_from_connector"
      ],
      "related_files": [
        "crates/router/src/core/files/helpers.rs"
      ]
    }
  },
  {
    "id": "debug_059",
    "file_path": "crates/kgraph_utils/benches/evaluation.rs",
    "task_type": "code_debugging",
    "context_code": "for _ in (0..total_enabled) {\n        pms_enabled.push(RequestPaymentMethodTypes {\n            payment_method_type: api_enums::PaymentMethodType::Credit,\n            payment_experience: None,\n            card_networks: Some(vec![\n                api_enums::CardNetwork::Visa,\n                api_enums::CardNetwork::Mastercard,\n            ]),\n            accepted_currencies: Some(AcceptedCurrencies::EnableOnly(vec![\n                api_enums::Currency::USD,\n                api_enums::Currency::INR,\n            ])),\n            accepted_countries: None,\n            minimum_amount: Some(MinorUnit::new(100)),\n            maximum_amount: Some(MinorUnit::new(10000)),\n            recurring_enabled: Some(true),\n            installment_payment_enabled: Some(true),\n        });\n    }",
    "buggy_code": "    for _ in (0..total_enabled) {",
    "prompt": "The benchmark loop uses incorrect range syntax with parentheses. Rust range syntax should use `..` without parentheses for inclusive ranges or `0..total_enabled` for exclusive ranges.",
    "constraints": "Fix the range syntax to use proper Rust iteration.",
    "error_handling_pattern": "Use correct Rust range syntax for loops.",
    "expected_output": "    for _ in 0..total_enabled {",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "build_test_data"
      ],
      "related_files": [
        "crates/kgraph_utils/benches/evaluation.rs"
      ]
    }
  },
  {
    "id": "debug_060",
    "file_path": "crates/router/src/core/disputes/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn get_dispute_evidence_vec(\n    state: &SessionState,\n    platform: domain::Platform,\n    dispute_evidence: DisputeEvidence,\n) -> CustomResult<Vec<api_models::disputes::DisputeEvidenceBlock>, errors::ApiErrorResponse> {\n    let mut dispute_evidence_blocks: Vec<api_models::disputes::DisputeEvidenceBlock> = vec![];",
    "buggy_code": "    platform: domain::Platform,",
    "prompt": "The platform parameter is passed by value, which is inefficient since Platform is likely a large struct. It should be passed by reference to avoid unnecessary cloning.",
    "constraints": "Change the parameter to pass by reference instead of by value.",
    "error_handling_pattern": "Use references for large struct parameters to avoid unnecessary copying.",
    "expected_output": "    platform: &domain::Platform,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_dispute_evidence_vec"
      ],
      "related_files": [
        "crates/router/src/core/disputes/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_061",
    "file_path": "crates/hyperswitch_connectors/src/connectors/adyen/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "fn get_content(item: Vec<u8>) -> String {\n    String::from_utf8_lossy(&item).to_string()\n}",
    "buggy_code": "fn get_content(item: Vec<u8>) -> String {",
    "prompt": "The get_content function takes ownership of the Vec<u8> but only needs to read it. This causes unnecessary data movement. The function should take a reference instead.",
    "constraints": "Change the parameter to take a reference to avoid unnecessary ownership transfer.",
    "error_handling_pattern": "Use references for read-only parameters to avoid unnecessary cloning.",
    "expected_output": "fn get_content(item: &[u8]) -> String {",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_content"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/adyen/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_062",
    "file_path": "crates/router/src/types/transformers.rs",
    "task_type": "code_debugging",
    "context_code": "impl ForeignTryFrom<domain::MerchantConnectorAccount>\n    for api_models::admin::MerchantConnectorListResponse\n{\n    type Error = error_stack::Report<errors::ApiErrorResponse>;\n    fn foreign_try_from(item: domain::MerchantConnectorAccount) -> Result<Self, Self::Error> {",
    "buggy_code": "    fn foreign_try_from(item: domain::MerchantConnectorAccount) -> Result<Self, Self::Error> {",
    "prompt": "The foreign_try_from implementation takes the MerchantConnectorAccount by value, which is expensive for large structs. It should take a reference to avoid unnecessary cloning.",
    "constraints": "Change the parameter to take a reference while maintaining the same functionality.",
    "error_handling_pattern": "Use references for transformation functions to avoid unnecessary data copying.",
    "expected_output": "    fn foreign_try_from(item: &domain::MerchantConnectorAccount) -> Result<Self, Self::Error> {",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ForeignTryFrom::foreign_try_from"
      ],
      "related_files": [
        "crates/router/src/types/transformers.rs"
      ]
    }
  },
  {
    "id": "debug_063",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn get_routing_algorithm(\n    merchant_account: &domain::MerchantAccount,\n    payment_method_type: api_enums::PaymentMethodType,\n    country_code: Option<api_enums::CountryAlpha2>,\n    currency: Option<api_enums::Currency>,\n) -> CustomResult<domain::RoutingAlgorithm, errors::ApiErrorResponse> {\n    let routing_config = merchant_account\n        .routing_config\n        .as_ref()\n        .ok_or(errors::ApiErrorResponse::MissingRequiredField {\n            field_name: \"routing_config\".to_string(),\n        })?;",
    "buggy_code": "        .ok_or(errors::ApiErrorResponse::MissingRequiredField {",
    "prompt": "The error handling for missing routing config uses a generic MissingRequiredField error. This should use a more specific error code for routing configuration issues.",
    "constraints": "Use a more specific error type for missing routing configuration.",
    "error_handling_pattern": "Provide specific error codes for different failure scenarios.",
    "expected_output": "        .ok_or(errors::ApiErrorResponse::RoutingConfigurationMissing)?;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_routing_algorithm"
      ],
      "related_files": [
        "crates/router/src/core/routing.rs"
      ]
    }
  },
  {
    "id": "debug_064",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_debugging",
    "context_code": "pub fn get_routing_algorithm(\n    merchant_account: &domain::MerchantAccount,\n    payment_method_type: api_enums::PaymentMethodType,\n    country_code: Option<api_enums::CountryAlpha2>,\n    currency: Option<api_enums::Currency>,\n) -> CustomResult<domain::RoutingAlgorithm, errors::ApiErrorResponse> {\n    let routing_config = merchant_account\n        .routing_config\n        .as_ref()\n        .ok_or(errors::ApiErrorResponse::MissingRequiredField {\n            field_name: \"routing_config\".to_string(),\n        })?;",
    "buggy_code": "        .ok_or(errors::ApiErrorResponse::MissingRequiredField {",
    "prompt": "The error handling for missing routing config uses a generic MissingRequiredField error. This should use a more specific error code for routing configuration issues.",
    "constraints": "Use a more specific error type for missing routing configuration.",
    "error_handling_pattern": "Provide specific error codes for different failure scenarios.",
    "expected_output": "        .ok_or(errors::ApiErrorResponse::RoutingConfigurationMissing)?;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_routing_algorithm"
      ],
      "related_files": [
        "crates/router/src/core/routing.rs"
      ]
    }
  },
  {
    "id": "debug_065",
    "file_path": "crates/router/src/core/refunds.rs",
    "task_type": "code_debugging",
    "context_code": "pub async fn process_refund(\n    state: &SessionState,\n    refund_data: payments::RefundRequest,\n) -> RouterResponse<payments::RefundResponse> {\n    let payment_intent = state\n        .store\n        .find_payment_intent_by_payment_id(&refund_data.payment_id)\n        .await\n        .change_context(errors::ApiErrorResponse::PaymentNotFound)?;",
    "buggy_code": "        .change_context(errors::ApiErrorResponse::PaymentNotFound)?;",
    "prompt": "The error handling uses a generic PaymentNotFound error for refund processing. This should use a more specific error for refund-related failures to provide better context.",
    "constraints": "Use a more specific error type for refund operations.",
    "error_handling_pattern": "Provide specific error codes for different operation types.",
    "expected_output": "        .change_context(errors::ApiErrorResponse::RefundPaymentNotFound)?;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "process_refund"
      ],
      "related_files": [
        "crates/router/src/core/refunds.rs"
      ]
    }
  },
  {
    "id": "gen_001",
    "file_path": "crates/storage_impl/src/payments/payment_intent.rs",
    "task_type": "code_generation",
    "context_code": "let storage_scheme = Box::pin(decide_storage_scheme::<_, DieselPaymentIntent>(\n    self,\n    storage_scheme,\n    Op::Insert,\n))\n.await;\nmatch storage_scheme {\n    MerchantStorageScheme::PostgresOnly => {\n        // TODO: Implement PostgresOnly path\n    }\n    MerchantStorageScheme::RedisKv => {\n        // TODO: Implement RedisKv path\n    }\n}",
    "prompt": "Complete the `PostgresOnly` branch to insert a payment intent directly into the database without using Redis KV store.",
    "constraints": "Use the existing `router_store.insert_payment_intent()` method. Pass all required parameters including state, payment_intent, merchant_key_store, and storage_scheme.",
    "expected_output": "MerchantStorageScheme::PostgresOnly => {\n    self.router_store\n        .insert_payment_intent(\n            state,\n            payment_intent,\n            merchant_key_store,\n            storage_scheme,\n        )\n        .await\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "decide_storage_scheme",
        "insert_payment_intent"
      ],
      "related_files": [
        "crates/router/src/db.rs",
        "crates/diesel_models/src/payment_intent.rs"
      ]
    }
  },
  {
    "id": "gen_002",
    "file_path": "crates/router/src/core/payments/flows/approve_flow.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"v1\")]\nasync fn construct_router_data<'a>(\n    &self,\n    state: &SessionState,\n    connector_id: &str,\n    merchant_context: &domain::MerchantContext,\n    customer: &Option<domain::Customer>,\n    merchant_connector_account: &helpers::MerchantConnectorAccountType,\n    merchant_recipient_data: Option<types::MerchantRecipientData>,\n    header_payload: Option<hyperswitch_domain_models::payments::HeaderPayload>,\n    _payment_method: Option<common_enums::PaymentMethod>,\n    _payment_method_type: Option<common_enums::PaymentMethodType>,\n) -> RouterResult<types::PaymentsApproveRouterData> {\n    // TODO: Complete implementation\n}",
    "prompt": "Complete the v1 implementation of `construct_router_data` for the approve flow. Use the `transformers::construct_payment_router_data` helper function with appropriate type parameters.",
    "constraints": "Follow the pattern used in other flow implementations. Use Box::pin for the async call. Pass None for the last two payment method parameters since they're not used in v1.",
    "expected_output": "Box::pin(transformers::construct_payment_router_data::<\n    api::Approve,\n    types::PaymentsApproveData,\n>(\n    state,\n    self.clone(),\n    connector_id,\n    merchant_context,\n    customer,\n    merchant_connector_account,\n    merchant_recipient_data,\n    header_payload,\n    None,\n    None,\n))\n.await",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "construct_payment_router_data",
        "PaymentData"
      ],
      "related_files": [
        "crates/router/src/core/payments/transformers.rs",
        "crates/router/src/core/payments/flows/authorize_flow.rs"
      ]
    }
  },
  {
    "id": "gen_003",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?;\n    // TODO: Complete the connector data retrieval and file fetch logic\n}",
    "prompt": "Complete the file retrieval logic by getting the connector data, constructing router data, and executing the connector processing step.",
    "constraints": "Use `api::ConnectorData::get_connector_by_name()`, `utils::construct_retrieve_file_router_data()`, and `services::execute_connector_processing_step()`. Handle the dispute lookup if dispute_id is provided.",
    "expected_output": "let connector_data = api::ConnectorData::get_connector_by_name(\n    &state.conf.connectors,\n    connector,\n    api::GetToken::Connector,\n    file_metadata.merchant_connector_id.clone(),\n)?;\n\nlet dispute = match dispute_id {\n    Some(dispute) => Some(\n        state\n            .store\n            .find_dispute_by_merchant_id_dispute_id(\n                merchant_context.get_merchant_account().get_id(),\n                &dispute,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound {\n                dispute_id: dispute,\n            })?,\n    ),\n    None => None,\n};\n\nlet connector_integration: services::BoxedFilesConnectorIntegrationInterface<\n    api::Retrieve,\n    types::RetrieveFileRequestData,\n    types::RetrieveFileResponse,\n> = connector_data.connector.get_connector_integration();\n\nlet router_data = utils::construct_retrieve_file_router_data(\n    state,\n    merchant_context,\n    &file_metadata,\n    dispute,\n    connector,\n)\n.await\n.change_context(errors::ApiErrorResponse::InternalServerError)\n.attach_printable(\"Failed constructing the retrieve file router data\")?;\n\nlet response = services::execute_connector_processing_step(\n    state,\n    connector_integration,\n    &router_data,\n    payments::CallConnectorAction::Trigger,\n    None,\n    None,\n)\n.await\n.to_files_failed_response()\n.attach_printable(\"Failed while calling retrieve file connector api\")?;\n\nlet retrieve_file_response = response\n    .response\n    .map_err(|err| errors::ApiErrorResponse::ExternalConnectorError {\n        code: err.code,\n        message: err.message,\n        connector: connector.to_string(),\n        status_code: err.status_code,\n        reason: err.reason,\n    })?;\n\nOk(retrieve_file_response.file_data)",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "get_connector_by_name",
        "construct_retrieve_file_router_data",
        "execute_connector_processing_step"
      ],
      "related_files": [
        "crates/router/src/types/api.rs",
        "crates/router/src/services.rs",
        "crates/router/src/core/payments.rs"
      ]
    }
  },
  {
    "id": "gen_004",
    "file_path": "crates/hyperswitch_connectors/src/connectors/tesouro.rs",
    "task_type": "code_generation",
    "context_code": "use common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse hyperswitch_domain_models::{\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n        PaymentsSyncRouterData, RefreshTokenRouterData, RefundSyncRouterData, RefundsRouterData,\n    },\n};",
    "prompt": "Notice that tesouro uses `FloatMajorUnit` instead of `StringMajorUnit`. Implement a helper function that converts a payment amount to the connector's required format.",
    "constraints": "Use the `AmountConvertor` trait and handle the conversion from `MinorUnit` to `FloatMajorUnit`. Return a `CustomResult`.",
    "expected_output": "fn convert_payment_amount(\n    amount_converter: &dyn AmountConvertor,\n    minor_amount: MinorUnit,\n    currency: enums::Currency,\n) -> CustomResult<FloatMajorUnit, errors::ConnectorError> {\n    amount_converter\n        .convert(minor_amount, currency)\n        .change_context(errors::ConnectorError::RequestEncodingFailed)\n        .attach_printable(\"Failed to convert amount to float major unit\")\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "AmountConvertor::convert",
        "FloatMajorUnitForConnector"
      ],
      "related_files": [
        "crates/common_utils/src/types.rs",
        "crates/hyperswitch_interfaces/src/errors.rs"
      ]
    }
  },
  {
    "id": "gen_005",
    "file_path": "crates/euclid_wasm/src/lib.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"v1\")]\n#[wasm_bindgen(js_name = seedKnowledgeGraph)]\npub fn seed_knowledge_graph(mcas: JsValue) -> JsResult {\n    let mcas: Vec<api_models::admin::MerchantConnectorResponse> = serde_wasm_bindgen::from_value(mcas)?;\n    let connectors: Vec<ast::ConnectorChoice> = mcas\n        .iter()\n        .map(|mca| {\n            Ok::<_, strum::ParseError>(ast::ConnectorChoice {\n                connector: RoutableConnectors::from_str(&mca.connector_name)?,\n            })\n        })\n        .collect::<Result<_, _>>()\n        .map_err(|_| \"invalid connector name received\")\n        .err_to_js()?;\n    let pm_filter = kgraph_utils::types::PaymentMethodFilters(HashMap::new());\n    let config = kgraph_utils::types::CountryCurrencyFilter {\n        connector_configs: HashMap::new(),\n        default_configs: Some(pm_filter),\n    };\n    let mca_graph = kgraph_utils::mca::make_mca_graph(mcas, &config).err_to_js()?;\n    let analysis_graph = hyperswitch_constraint_graph::ConstraintGraph::combine(\n        &mca_graph,\n        &dssa::truth::ANALYSIS_GRAPH,\n    ).err_to_js()?;",
    "prompt": "Complete the function by storing the analysis_graph and connectors in SEED_DATA. Handle the case where the knowledge graph has already been seeded.",
    "constraints": "Use the SEED_DATA static variable and return JsValue::NULL on success. Return an error if already seeded.",
    "expected_output": "SEED_DATA\n    .set(SeedData {\n        cgraph: analysis_graph,\n        connectors,\n    })\n    .map_err(|_| \"Knowledge Graph has been already seeded\".to_string())\n    .err_to_js()?;\n\nOk(JsValue::NULL)",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "make_mca_graph",
        "ConstraintGraph::combine",
        "err_to_js"
      ],
      "related_files": [
        "crates/kgraph_utils/src/mca.rs",
        "crates/hyperswitch_constraint_graph/src/lib.rs"
      ]
    }
  },
  {
    "id": "gen_006",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_generation",
    "context_code": "impl TryFrom<&types::PaymentsAuthorizeRouterData> for StripePaymentIntentRequest {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(item: &types::PaymentsAuthorizeRouterData) -> Result<Self, Self::Error> {\n        // TODO: Implement conversion logic\n    }\n}",
    "prompt": "Complete the TryFrom implementation to convert PaymentsAuthorizeRouterData into StripePaymentIntentRequest. Extract the amount, currency, and payment method details from the router data.",
    "constraints": "Use the amount_converter from RouterData. Handle the payment method data using pattern matching on PaymentMethodData. Return appropriate connector errors for missing fields.",
    "expected_output": "fn try_from(item: &types::PaymentsAuthorizeRouterData) -> Result<Self, Self::Error> {\n    let amount = item.request.minor_amount;\n    let currency = item.request.currency;\n    \n    let payment_method_data = match &item.request.payment_method_data {\n        domain::PaymentMethodData::Card(card) => {\n            StripePaymentMethodData::Card(StripeCardData {\n                number: card.card_number.clone(),\n                exp_month: card.card_exp_month.clone(),\n                exp_year: card.card_exp_year.clone(),\n                cvc: card.card_cvc.clone(),\n            })\n        }\n        _ => Err(errors::ConnectorError::NotImplemented(\"Payment method not supported\".into()))?,\n    };\n    \n    Ok(Self {\n        amount,\n        currency,\n        payment_method_data,\n        confirm: true,\n        return_url: item.request.router_return_url.clone(),\n    })\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "PaymentMethodData",
        "StripePaymentIntentRequest"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/payment_method_data.rs",
        "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs"
      ]
    }
  },
  {
    "id": "gen_007",
    "file_path": "crates/router/src/core/payments/operations/payment_create.rs",
    "task_type": "code_generation",
    "context_code": "async fn make_pm_data<'a>(\n    state: &'a SessionState,\n    payment_data: &mut PaymentData<F>,\n    merchant_key_store: &domain::MerchantKeyStore,\n) -> RouterResult<(\n    Option<domain::PaymentMethodData>,\n    Option<String>,\n)> {\n    // TODO: Implement payment method data extraction and validation\n}",
    "prompt": "Complete the make_pm_data function to extract and validate payment method data from the payment request. Handle both new payment methods and stored payment method tokens.",
    "constraints": "Check if payment_method_data exists in the request. If not, retrieve it from the payment_token using vault service. Validate customer_id matches between token and payment intent. Return appropriate errors for missing or invalid data.",
    "expected_output": "async fn make_pm_data<'a>(\n    state: &'a SessionState,\n    payment_data: &mut PaymentData<F>,\n    merchant_key_store: &domain::MerchantKeyStore,\n) -> RouterResult<(\n    Option<domain::PaymentMethodData>,\n    Option<String>,\n)> {\n    match &payment_data.payment_method_data {\n        Some(pm_data) => Ok((Some(pm_data.clone()), None)),\n        None => {\n            let payment_token = payment_data\n                .payment_attempt\n                .payment_token\n                .as_ref()\n                .ok_or(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n            \n            let (pm_data, supplementary_data) = vault::Vault::get_payment_method_data_from_locker(\n                state,\n                payment_token,\n                merchant_key_store,\n            )\n            .await\n            .attach_printable(\"Failed to retrieve payment method from vault\")?;\n            \n            // Validate customer_id matches\n            if supplementary_data.customer_id != payment_data.payment_intent.customer_id {\n                return Err(errors::ApiErrorResponse::PreconditionFailed {\n                    message: \"customer associated with payment method and customer passed in payment are not same\".into()\n                }.into());\n            }\n            \n            Ok((pm_data, Some(payment_token.clone())))\n        }\n    }\n}",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "vault::Vault::get_payment_method_data_from_locker"
      ],
      "related_files": [
        "crates/router/src/core/payment_methods/vault.rs",
        "crates/router/src/core/payments/helpers.rs"
      ]
    }
  },
  {
    "id": "gen_008",
    "file_path": "crates/hyperswitch_connectors/src/connectors/adyen/transformers.rs",
    "task_type": "code_generation",
    "context_code": "impl TryFrom<&AdyenPaymentResponse> for types::PaymentsResponseData {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(response: &AdyenPaymentResponse) -> Result<Self, Self::Error> {\n        // TODO: Map Adyen response to standard PaymentsResponseData\n    }\n}",
    "prompt": "Complete the response transformation from Adyen's payment response to Hyperswitch's standard PaymentsResponseData format. Handle different result codes and map them to appropriate payment statuses.",
    "constraints": "Map Adyen's resultCode to IntentStatus. Extract connector_transaction_id from pspReference. Handle 3DS redirect scenarios by checking for action field.",
    "expected_output": "fn try_from(response: &AdyenPaymentResponse) -> Result<Self, Self::Error> {\n    let status = match response.result_code.as_str() {\n        \"Authorised\" => enums::IntentStatus::Succeeded,\n        \"Refused\" | \"Cancelled\" => enums::IntentStatus::Failed,\n        \"Pending\" | \"Received\" => enums::IntentStatus::Processing,\n        \"RedirectShopper\" => enums::IntentStatus::RequiresCustomerAction,\n        _ => enums::IntentStatus::Failed,\n    };\n    \n    let redirection_data = response.action.as_ref().and_then(|action| {\n        action.url.as_ref().map(|url| {\n            services::RedirectForm::from((\n                url.clone(),\n                services::Method::Get,\n            ))\n        })\n    });\n    \n    Ok(Self::TransactionResponse {\n        resource_id: types::ResponseId::ConnectorTransactionId(\n            response.psp_reference.clone()\n        ),\n        redirection_data,\n        mandate_reference: None,\n        connector_metadata: None,\n        network_txn_id: None,\n        connector_response_reference_id: Some(response.psp_reference.clone()),\n        incremental_authorization_allowed: None,\n        charge_id: None,\n    })\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ResponseId::ConnectorTransactionId",
        "RedirectForm::from"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_response_types.rs",
        "crates/router/src/services.rs"
      ]
    }
  },
  {
    "id": "gen_009",
    "file_path": "crates/router/src/core/webhooks.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn verify_webhook_source<W: webhooks::IncomingWebhook>(\n    state: &SessionState,\n    merchant_context: &domain::MerchantContext,\n    connector_name: &str,\n    request: &actix_web::HttpRequest,\n    body: &[u8],\n) -> CustomResult<bool, errors::ConnectorError> {\n    // TODO: Implement webhook signature verification\n}",
    "prompt": "Complete the webhook signature verification function. Get the connector instance, extract signature from headers, and verify it against the webhook body using the connector's verification method.",
    "constraints": "Use api::ConnectorData::get_connector_by_name to get connector. Extract signature from request headers. Call the connector's verify_webhook_source method. Return true if verification succeeds.",
    "expected_output": "pub async fn verify_webhook_source<W: webhooks::IncomingWebhook>(\n    state: &SessionState,\n    merchant_context: &domain::MerchantContext,\n    connector_name: &str,\n    request: &actix_web::HttpRequest,\n    body: &[u8],\n) -> CustomResult<bool, errors::ConnectorError> {\n    let connector = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector_name,\n        api::GetToken::Connector,\n        None,\n    )?;\n    \n    let signature = request\n        .headers()\n        .get(\"stripe-signature\")\n        .and_then(|h| h.to_str().ok())\n        .ok_or(errors::ConnectorError::WebhookSignatureNotFound)?;\n    \n    let merchant_secret = merchant_context\n        .get_merchant_connector_account()\n        .connector_webhook_details\n        .as_ref()\n        .and_then(|d| d.merchant_secret.as_ref())\n        .ok_or(errors::ConnectorError::WebhookVerificationSecretNotFound)?;\n    \n    let verification_result = connector\n        .connector\n        .verify_webhook_source(\n            request,\n            body,\n            merchant_secret,\n            signature,\n        )\n        .await?;\n    \n    Ok(verification_result)\n}",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "get_connector_by_name",
        "verify_webhook_source"
      ],
      "related_files": [
        "crates/router/src/types/api.rs",
        "crates/hyperswitch_interfaces/src/webhooks.rs"
      ]
    }
  },
  {
    "id": "gen_010",
    "file_path": "crates/router/src/core/refunds.rs",
    "task_type": "code_generation",
    "context_code": "async fn validate_refund_amount(\n    payment_attempt: &storage::PaymentAttempt,\n    refund_amount: MinorUnit,\n    existing_refunds: &[storage::Refund],\n) -> RouterResult<()> {\n    // TODO: Validate that refund amount doesn't exceed available amount\n}",
    "prompt": "Complete the refund amount validation logic. Calculate total refunded amount from existing refunds, ensure new refund doesn't exceed the original payment amount.",
    "constraints": "Sum up amounts from existing successful refunds. Compare total with payment_attempt.amount. Return RefundAmountExceedsPaymentAmount error if validation fails.",
    "expected_output": "async fn validate_refund_amount(\n    payment_attempt: &storage::PaymentAttempt,\n    refund_amount: MinorUnit,\n    existing_refunds: &[storage::Refund],\n) -> RouterResult<()> {\n    let total_refunded: i64 = existing_refunds\n        .iter()\n        .filter(|r| matches!(\n            r.refund_status,\n            storage_enums::RefundStatus::Success | storage_enums::RefundStatus::Pending\n        ))\n        .map(|r| r.refund_amount.get_amount_as_i64())\n        .sum();\n    \n    let payment_amount = payment_attempt.amount.get_amount_as_i64();\n    let new_refund_amount = refund_amount.get_amount_as_i64();\n    \n    if total_refunded + new_refund_amount > payment_amount {\n        return Err(errors::ApiErrorResponse::RefundAmountExceedsPaymentAmount {\n            payment_amount,\n            refund_amount: total_refunded + new_refund_amount,\n        }\n        .into());\n    }\n    \n    Ok(())\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_amount_as_i64",
        "RefundStatus"
      ],
      "related_files": [
        "crates/diesel_models/src/refund.rs",
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "gen_011",
    "file_path": "crates/router/src/core/admin.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn create_merchant_account(\n    state: &SessionState,\n    req: api::MerchantAccountCreate,\n) -> RouterResponse<api::MerchantAccountResponse> {\n    let key = services::generate_aes256_key()?;\n    let master_key = state.store.get_master_key();\n    // TODO: Encrypt and store merchant key\n}",
    "prompt": "Complete the merchant key encryption and storage logic. Use the crypto_operation function to encrypt the merchant key with the master key, then insert it into the merchant_key_store table.",
    "constraints": "Use domain_types::crypto_operation with CryptoOperation::Encrypt. Create a MerchantKeyStore instance with the encrypted key. Handle KeyManager transfer if enabled.",
    "expected_output": "let key_manager_state = &state.into();\nlet identifier = Identifier::Merchant(merchant_id.clone());\n\nif key_manager_state.enabled {\n    let transfer_key_request = services::EncryptionTransferRequest {\n        identifier: identifier.clone(),\n        key: key.clone(),\n    };\n    services::transfer_key_to_key_manager(\n        state,\n        transfer_key_request,\n    )\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to transfer key to key manager\")?;\n}\n\nlet encrypted_key = domain_types::crypto_operation(\n    key_manager_state,\n    domain_types::type_name!(domain::MerchantKeyStore),\n    domain_types::CryptoOperation::Encrypt(key.to_vec().into()),\n    identifier.clone(),\n    master_key.peek(),\n)\n.await\n.change_context(errors::ApiErrorResponse::InternalServerError)\n.attach_printable(\"Failed to encrypt merchant key\")?;\n\nlet key_store = domain::MerchantKeyStore {\n    merchant_id: merchant_id.clone(),\n    key: encrypted_key.into(),\n    created_at: common_utils::date_time::now(),\n};\n\nstate.store\n    .insert_merchant_key_store(key_store, &merchant_id.get_string_repr())\n    .await\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to insert merchant key store\")?;",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "generate_aes256_key",
        "crypto_operation",
        "transfer_key_to_key_manager"
      ],
      "related_files": [
        "crates/common_utils/src/encryption.rs",
        "crates/hyperswitch_domain_models/src/merchant_key_store.rs"
      ]
    }
  },
  {
    "id": "gen_012",
    "file_path": "crates/router/src/core/payment_methods/cards.rs",
    "task_type": "code_generation",
    "context_code": "async fn create_encrypted_data(\n    key_manager_state: &KeyManagerState,\n    key_store: &domain::MerchantKeyStore,\n    pm_data: PaymentMethodsData,\n) -> Result<Encryption, errors::ApiErrorResponse> {\n    // TODO: Implement encryption of payment method data\n}",
    "prompt": "Complete the payment method data encryption function. Encode the payment method data to JSON, then encrypt it using the merchant's key from the key store.",
    "constraints": "Use Encode::encode_to_value() for JSON serialization. Call crypto_operation with the merchant key. Return the encrypted Encryption type.",
    "expected_output": "let key = key_store.key.get_inner().peek();\nlet identifier = Identifier::Merchant(key_store.merchant_id.clone());\n\nlet encoded_data = pm_data\n    .encode_to_value()\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to encode payment method data\")?;\n\nlet encrypted = domain_types::crypto_operation(\n    key_manager_state,\n    type_name!(payment_method::PaymentMethod),\n    CryptoOperation::EncryptOptional(Some(encoded_data)),\n    identifier,\n    key,\n)\n.await\n.change_context(errors::ApiErrorResponse::InternalServerError)\n.attach_printable(\"Failed to encrypt payment method data\")?;\n\nOk(encrypted)",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "encode_to_value",
        "crypto_operation",
        "CryptoOperation::EncryptOptional"
      ],
      "related_files": [
        "crates/common_utils/src/types/keymanager.rs",
        "crates/hyperswitch_domain_models/src/type_encryption.rs"
      ]
    }
  },
  {
    "id": "gen_013",
    "file_path": "crates/router/src/core/payment_methods/vault.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn store_payment_method_data_in_locker(\n    state: &SessionState,\n    payment_method: PaymentMethodsData,\n    merchant_id: &id_type::MerchantId,\n    customer_id: &id_type::CustomerId,\n) -> RouterResult<String> {\n    // TODO: Create JWE encrypted request and send to locker\n}",
    "prompt": "Complete the locker storage function. Create a StoreLockerReq with the payment method data, encrypt it using JWE with the vault's public key, and send it to the locker service.",
    "constraints": "Use transformers::create_jwe_encrypted_payload() for JWE encryption. Build the locker request with merchant_id, customer_id, and ttl. Return the locker token ID from the response.",
    "expected_output": "let locker_req = match payment_method {\n    PaymentMethodsData::Card(card) => {\n        StoreLockerReq::LockerCard(StoreCardReq {\n            merchant_id: merchant_id.clone(),\n            merchant_customer_id: customer_id.clone(),\n            card: card.clone(),\n            ttl: state.conf.locker.ttl_for_storage_in_secs,\n            requestor_card_reference: None,\n        })\n    }\n    _ => {\n        let enc_data = transformers::create_jwe_encrypted_payload(\n            &state.conf.jwekey.vault_encryption_key,\n            payment_method,\n        )?;\n        StoreLockerReq::LockerGeneric(StoreGenericReq {\n            merchant_id: merchant_id.clone(),\n            merchant_customer_id: customer_id.clone(),\n            enc_data,\n            ttl: state.conf.locker.ttl_for_storage_in_secs,\n        })\n    }\n};\n\nlet response = services::call_locker_service(\n    state,\n    &locker_req,\n    \"/store\",\n).await?;\n\nOk(response.card_reference)",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "create_jwe_encrypted_payload",
        "call_locker_service",
        "StoreLockerReq"
      ],
      "related_files": [
        "crates/router/src/core/payment_methods/transformers.rs",
        "crates/router/src/services.rs"
      ]
    }
  },
  {
    "id": "gen_014",
    "file_path": "crates/router/src/core/payments/routing/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn perform_straight_through_routing(\n    routing_algorithm: &api::RoutingAlgorithm,\n    payment_data: &PaymentData,\n    merchant_context: &domain::MerchantContext,\n) -> RouterResult<Vec<api::ConnectorChoice>> {\n    // TODO: Execute routing algorithm and return connector choices\n}",
    "prompt": "Complete the straight-through routing function. Parse the routing algorithm, evaluate it against payment data constraints, and return the ordered list of connector choices.",
    "constraints": "Use euclid::execute() to run the routing algorithm. Pass payment amount, currency, payment method type as inputs. Filter results based on merchant connector accounts.",
    "expected_output": "let routing_input = euclid::types::RoutingInput {\n    payment_amount: payment_data.amount.get_amount_as_i64(),\n    payment_currency: payment_data.currency,\n    payment_method: payment_data.payment_method,\n    payment_method_type: payment_data.payment_method_type,\n    card_network: payment_data.card_network.clone(),\n    capture_method: payment_data.capture_method,\n};\n\nlet routing_output = euclid::execute(\n    &routing_algorithm.algorithm,\n    &routing_input,\n)\n.change_context(errors::ApiErrorResponse::RoutingFailed)\n.attach_printable(\"Failed to execute routing algorithm\")?;\n\nlet merchant_connector_accounts = merchant_context\n    .get_merchant_connector_accounts();\n\nlet connector_choices: Vec<api::ConnectorChoice> = routing_output\n    .connectors\n    .into_iter()\n    .filter_map(|connector| {\n        merchant_connector_accounts\n            .iter()\n            .find(|mca| mca.connector_name == connector.to_string())\n            .map(|mca| api::ConnectorChoice {\n                connector: connector.clone(),\n                merchant_connector_id: Some(mca.get_id().clone()),\n            })\n    })\n    .collect();\n\nOk(connector_choices)",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "euclid::execute",
        "get_merchant_connector_accounts",
        "RoutingInput"
      ],
      "related_files": [
        "crates/euclid/src/backend.rs",
        "crates/router/src/types/api.rs"
      ]
    }
  },
  {
    "id": "gen_015",
    "file_path": "crates/router/src/core/webhooks.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn process_webhook_event(\n    state: &SessionState,\n    merchant_context: &domain::MerchantContext,\n    webhook_payload: &[u8],\n    connector_name: &str,\n) -> RouterResult<api::WebhookEventResponse> {\n    // TODO: Parse webhook, update payment status, trigger outgoing webhooks\n}",
    "prompt": "Complete the webhook processing function. Deserialize the webhook payload, extract the payment ID, update the payment status in the database, and trigger merchant webhooks.",
    "constraints": "Use the connector's webhook parser to deserialize. Call update_payment_intent_status(). Trigger outgoing webhooks via webhooks::trigger_merchant_webhook(). Handle webhook deduplication.",
    "expected_output": "let connector = api::ConnectorData::get_connector_by_name(\n    &state.conf.connectors,\n    connector_name,\n    api::GetToken::Connector,\n    None,\n)?;\n\nlet webhook_event = connector\n    .connector\n    .parse_webhook_payload(webhook_payload)\n    .change_context(errors::ApiErrorResponse::WebhookProcessingFailed)?;\n\nlet payment_id = webhook_event.payment_id.clone();\n\nlet existing_webhook = state\n    .store\n    .find_webhook_event_by_merchant_id_event_id(\n        merchant_context.get_merchant_account().get_id(),\n        &webhook_event.event_id,\n    )\n    .await;\n\nif existing_webhook.is_ok() {\n    return Ok(api::WebhookEventResponse {\n        status: \"duplicate\".to_string(),\n    });\n}\n\nlet payment_intent = state\n    .store\n    .update_payment_intent_status(\n        &payment_id,\n        webhook_event.status,\n        merchant_context.get_merchant_account().get_id(),\n    )\n    .await?;\n\nwebhooks::trigger_merchant_webhook(\n    state,\n    merchant_context,\n    &payment_intent,\n    webhook_event.event_type,\n)\n.await?;\n\nOk(api::WebhookEventResponse {\n    status: \"processed\".to_string(),\n})",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "parse_webhook_payload",
        "update_payment_intent_status",
        "trigger_merchant_webhook"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/webhooks.rs",
        "crates/router/src/core/payments.rs"
      ]
    }
  },
  {
    "id": "gen_016",
    "file_path": "crates/external_services/build.rs",
    "task_type": "code_generation",
    "context_code": "#[allow(clippy::expect_used)]\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    #[cfg(feature = \"revenue_recovery\")]\n    {\n        let proto_base_path = router_env::workspace_path().join(\"proto\");\n        let out_dir = std::path::PathBuf::from(std::env::var(\"OUT_DIR\")?);\n        let recovery_proto_files = [proto_base_path.join(\"recovery_decider.proto\")];\n        // TODO: Complete the tonic_build configuration\n    }\n    Ok(())\n}",
    "prompt": "Complete the tonic_build configuration for compiling the revenue_recovery proto files. Configure it to output to out_dir, compile well-known types, and use external path mapping for Timestamp.",
    "constraints": "Use tonic_build::configure() with appropriate settings. Follow the pattern used in the dynamic_routing feature block. Handle the proto compilation with proper error handling.",
    "expected_output": "tonic_build::configure()\n    .out_dir(&out_dir)\n    .compile_well_known_types(true)\n    .extern_path(\".google.protobuf.Timestamp\", \"::prost_types::Timestamp\")\n    .compile_protos(&recovery_proto_files, &[&proto_base_path])\n    .expect(\"Failed to compile revenue-recovery proto files\");",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "tonic_build::configure",
        "compile_protos"
      ],
      "related_files": [
        "proto/recovery_decider.proto",
        "crates/router_env/src/lib.rs"
      ]
    }
  },
  {
    "id": "gen_017",
    "file_path": "crates/router/src/utils/db_utils.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn try_redis_get_else_try_database_get<F, RFut, DFut, T>(\n    redis_fut: RFut,\n    database_call_closure: F,\n) -> error_stack::Result<T, errors::StorageError>\nwhere\n    F: FnOnce() -> DFut,\n    RFut: futures::Future<Output = error_stack::Result<T, redis_interface::errors::RedisError>>,\n    DFut: futures::Future<Output = error_stack::Result<T, errors::StorageError>>,\n{\n    let redis_output = redis_fut.await;\n    match redis_output {\n        Ok(output) => Ok(output),\n        Err(redis_error) => match redis_error.current_context() {\n            redis_interface::errors::RedisError::NotFound => {\n                // TODO: Add metrics tracking and database fallback\n            }\n            _ => Err(redis_error.to_redis_failed_response(\"\")),\n        },\n    }\n}",
    "prompt": "Complete the NotFound error handling branch. Add KV_MISS metrics tracking and execute the database fallback closure.",
    "constraints": "Use metrics::KV_MISS.add() to track cache misses. Call the database_call_closure and await its result. Follow the existing error handling pattern.",
    "expected_output": "metrics::KV_MISS.add(1, &[]);\ndatabase_call_closure().await",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "KV_MISS",
        "to_redis_failed_response"
      ],
      "related_files": [
        "crates/router/src/routes/metrics.rs",
        "crates/redis_interface/src/errors.rs"
      ]
    }
  },
  {
    "id": "gen_018",
    "file_path": "crates/router/src/types/domain.rs",
    "task_type": "code_generation",
    "context_code": "pub mod behaviour {\n    pub use hyperswitch_domain_models::behaviour::{Conversion, ReverseConversion};\n}\n\nmod payment_attempt {\n    pub use hyperswitch_domain_models::payments::payment_attempt::*;\n}\n\nmod merchant_account {\n    pub use hyperswitch_domain_models::merchant_account::*;\n}\n\n#[cfg(feature = \"v2\")]\nmod business_profile {\n    pub use hyperswitch_domain_models::business_profile::{\n        Profile, ProfileGeneralUpdate, ProfileSetter, ProfileUpdate,\n    };\n}\n\n#[cfg(feature = \"v1\")]\nmod business_profile {\n    // TODO: Add v1-specific business profile imports\n}",
    "prompt": "Complete the v1 business_profile module imports. Import Profile, ProfileGeneralUpdate, ProfileSetter, ProfileUpdate, and ExternalVaultDetails from hyperswitch_domain_models::business_profile.",
    "constraints": "Follow the same pattern as the v2 feature block. Include ExternalVaultDetails which is v1-specific.",
    "expected_output": "pub use hyperswitch_domain_models::business_profile::{\n    ExternalVaultDetails, Profile, ProfileGeneralUpdate, ProfileSetter, ProfileUpdate,\n};",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "Profile",
        "ProfileUpdate"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/business_profile.rs"
      ]
    }
  },
  {
    "id": "gen_019",
    "file_path": "crates/common_utils/src/id_type/global_id/payment.rs",
    "task_type": "code_generation",
    "context_code": "impl GlobalPaymentId {\n    /// Get string representation of the id\n    pub fn get_string_repr(&self) -> &str {\n        self.0.get_string_repr()\n    }\n\n    /// Generate a new GlobalPaymentId from a cell id\n    pub fn generate(cell_id: &crate::id_type::CellId) -> Self {\n        let global_id = super::GlobalId::generate(cell_id, super::GlobalEntity::Payment);\n        Self(global_id)\n    }\n\n    // TODO: Add method to generate refund ID from payment ID\n}",
    "prompt": "Complete the implementation by adding a method `get_refund_id` that generates a refund ID string from the payment ID. The format should be 'refund_{payment_id}'.",
    "constraints": "Follow the existing pattern of other ID generation methods. Return a String type.",
    "expected_output": "/// Generate a refund ID from the payment ID\npub fn get_refund_id(&self) -> String {\n    format!(\"refund_{}\", self.get_string_repr())\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_string_repr",
        "get_execute_revenue_recovery_id"
      ],
      "related_files": [
        "crates/common_utils/src/id_type/global_id/mod.rs"
      ]
    }
  },
  {
    "id": "gen_020",
    "file_path": "justfile",
    "task_type": "code_generation",
    "context_code": "fmt_flags := '--all'\n\n# Run formatter\nfmt *FLAGS:\n    cargo +nightly fmt {{ fmt_flags }} {{ FLAGS }}\n\ncheck_flags := '--all-targets'\nv2_lints:= '-D warnings -Aunused -Aclippy::todo -Aclippy::diverging_sub_expression'\n\n# TODO: Add a recipe to run tests with v2 features",
    "prompt": "Complete the justfile by adding a recipe called 'test_v2' that runs tests with v2 features enabled. It should exclude v1 features and use the v2_lints configuration.",
    "constraints": "Follow the pattern used in clippy_v2 recipe. Use cargo test with appropriate feature flags. Include the v2_lints in RUSTFLAGS.",
    "expected_output": "# Run tests with v2 features\ntest_v2 *FLAGS:\n    #! /usr/bin/env bash\n    set -euo pipefail\n\n    FEATURES=\"$(cargo metadata --all-features --format-version 1 --no-deps | \\\n        jq -r '\n            [ ( .workspace_members | sort ) as $package_ids\n            | .packages[] | select( IN(.id; $package_ids[]) ) | .features | keys[] ] | unique\n            | del( .[] | select( . == (\"default\", \"v1\") ) )\n            | join(\",\")\n    ')\"\n\n    set -x\n    RUSTFLAGS=\"{{ v2_lints }}\" cargo test --no-default-features --features \"${FEATURES}\" {{ FLAGS }}\n    set +x",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "clippy_v2",
        "check_v2"
      ],
      "related_files": [
        "Cargo.toml"
      ]
    }
  },
  {
    "id": "gen_021",
    "file_path": "add_connector.md",
    "task_type": "code_generation",
    "context_code": "### 2. **Download the OpenAPI Specification from your connector**\n\nFirst, obtain the OpenAPI specification from your payment processor's developer documentation.\n\n```bash\ncurl -o <ConnectorName>-openapi.json <schema-url>\n```\n\n# TODO: Add command to generate Rust types from OpenAPI spec",
    "prompt": "Complete the documentation by adding the openapi-generator command that generates Rust types from the downloaded OpenAPI specification. The output should go to a temp.rs file in the connector directory.",
    "constraints": "Use openapi-generator with the rust generator. Set the output directory to crates/hyperswitch_connectors/src/connectors/{CONNECTOR_NAME}/. Use environment variables CONNECTOR_NAME and SCHEMA_PATH.",
    "expected_output": "```bash\n# Generate Rust types from OpenAPI specification\nopenapi-generator generate \\\n  -i \"${SCHEMA_PATH}\" \\\n  -g rust \\\n  -o \"crates/hyperswitch_connectors/src/connectors/${CONNECTOR_NAME}\" \\\n  --additional-properties=packageName=${CONNECTOR_NAME} \\\n  --global-property=models,supportingFiles=temp.rs\n```",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "openapi-generator"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/"
      ]
    }
  },
  {
    "id": "gen_022",
    "file_path": "cypress-tests/README.md",
    "task_type": "code_generation",
    "context_code": "## Adding tests\n\n### Addition of test for a new connector\n\n1. Include the connector details in the `creds.json` file\n\n2. Add the new connector details to the ConnectorUtils folder\n\n# TODO: Add step 3 for creating the test spec file",
    "prompt": "Complete the documentation by adding step 3 that explains how to create a test spec file for a new connector. The file should be placed in cypress/e2e/spec/Payment/ directory.",
    "constraints": "Follow the naming convention shown in the directory structure. Reference the Stripe example for guidance.",
    "expected_output": "3. Create a test specification file in `cypress/e2e/spec/Payment/` directory:\n   \n   **File Naming:** Create a new file named `<connector_name>.cy.js` for your connector's test scenarios.\n   \n   **Test Structure:** Import the connector utilities and define test cases for different payment flows:\n   ```javascript\n   import * as fixtures from \"../../fixtures/fixture.json\";\n   import * as utils from \"../PaymentUtils/<ConnectorName>.js\";\n   \n   describe(\"[Payment] <ConnectorName>\", () => {\n     it(\"should create payment\", () => {\n       cy.createPaymentIntentTest(fixtures.createPaymentBody, utils);\n     });\n     \n     it(\"should capture payment\", () => {\n       cy.captureCallTest(fixtures.captureBody, utils);\n     });\n   });\n   ```",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "createPaymentIntentTest",
        "captureCallTest"
      ],
      "related_files": [
        "cypress-tests/cypress/e2e/PaymentUtils/Stripe.js",
        "cypress-tests/cypress/fixtures/fixture.json"
      ]
    }
  },
  {
    "id": "gen_023",
    "file_path": "crates/router/src/core/disputes/transformers.rs",
    "task_type": "code_generation",
    "context_code": "pub fn update_dispute_evidence(\n    dispute_evidence: DisputeEvidence,\n    evidence_type: api::EvidenceType,\n    file_id: String,\n) -> DisputeEvidence {\n    match evidence_type {\n        api::EvidenceType::CancellationPolicy => DisputeEvidence {\n            cancellation_policy: Some(file_id),\n            ..dispute_evidence\n        },\n        // TODO: Add remaining evidence types\n    }\n}",
    "prompt": "Complete the match statement by adding cases for CustomerCommunication, CustomerSignature, and Receipt evidence types.",
    "constraints": "Follow the same pattern as CancellationPolicy. Each case should update the corresponding field in DisputeEvidence with the file_id.",
    "expected_output": "api::EvidenceType::CustomerCommunication => DisputeEvidence {\n    customer_communication: Some(file_id),\n    ..dispute_evidence\n},\napi::EvidenceType::CustomerSignature => DisputeEvidence {\n    customer_signature: Some(file_id),\n    ..dispute_evidence\n},\napi::EvidenceType::Receipt => DisputeEvidence {\n    receipt: Some(file_id),\n    ..dispute_evidence\n},",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "delete_evidence_file",
        "get_dispute_evidence_block"
      ],
      "related_files": [
        "crates/api_models/src/disputes.rs",
        "crates/diesel_models/src/dispute.rs"
      ]
    }
  },
  {
    "id": "gen_024",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn delete_file_using_file_id(\n    state: &SessionState,\n    file_key: String,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    let file_metadata_object = state\n        .store\n        .find_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &file_key,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::FileNotFound)?;\n    // TODO: Extract provider and provider_file_id, validate availability\n}",
    "prompt": "Complete the file deletion logic by extracting the provider and provider_file_id from file_metadata_object, validating that the file is available, and handling the case where any of these fields are missing.",
    "constraints": "Use pattern matching on the tuple (file_upload_provider, provider_file_id, available). Return FileNotAvailable error if any field is None or available is false.",
    "expected_output": "let (provider, provider_file_id) = match (\n    file_metadata_object.file_upload_provider,\n    file_metadata_object.provider_file_id,\n    file_metadata_object.available,\n) {\n    (Some(provider), Some(provider_file_id), true) => (provider, provider_file_id),\n    _ => Err(errors::ApiErrorResponse::FileNotAvailable)\n        .attach_printable(\"File not available\")?,\n};",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_file_metadata_by_merchant_id_file_id",
        "delete_file"
      ],
      "related_files": [
        "crates/diesel_models/src/file.rs",
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "gen_025",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();\n    // TODO: Get connector data and retrieve dispute if dispute_id is provided\n}",
    "prompt": "Complete the connector data retrieval and optional dispute lookup. Use get_connector_by_name to get connector data, then conditionally fetch the dispute if dispute_id is Some.",
    "constraints": "Use api::ConnectorData::get_connector_by_name with the connector string. For dispute lookup, use find_dispute_by_merchant_id_dispute_id and convert errors to DisputeNotFound.",
    "expected_output": "let connector_data = api::ConnectorData::get_connector_by_name(\n    &state.conf.connectors,\n    connector,\n    api::GetToken::Connector,\n    file_metadata.merchant_connector_id.clone(),\n)?;\n\nlet dispute = match dispute_id {\n    Some(dispute) => Some(\n        state\n            .store\n            .find_dispute_by_merchant_id_dispute_id(\n                merchant_context.get_merchant_account().get_id(),\n                &dispute,\n            )\n            .await\n            .to_not_found_response(errors::ApiErrorResponse::DisputeNotFound {\n                dispute_id: dispute,\n            })?,\n    ),\n    None => None,\n};",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_connector_by_name",
        "find_dispute_by_merchant_id_dispute_id",
        "construct_retrieve_file_router_data"
      ],
      "related_files": [
        "crates/router/src/types/api.rs",
        "crates/diesel_models/src/dispute.rs"
      ]
    }
  },
  {
    "id": "gen_026",
    "file_path": "crates/router/src/routes/files.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::RetrieveFile))]\npub async fn files_retrieve(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    path: web::Path<String>,\n) -> HttpResponse {\n    let flow = Flow::RetrieveFile;\n    let file_id = files::FileId {\n        file_id: path.into_inner(),\n    };\n    // TODO: Implement the server_wrap call with proper authentication\n}",
    "prompt": "Complete the files_retrieve endpoint implementation. Use Box::pin with api::server_wrap, passing the flow, state, request, file_id, and a closure that calls files_retrieve_core. Use ApiKeyAuth for authentication.",
    "constraints": "Follow the same pattern as files_create and files_delete. Create merchant_context from auth data. Use DashboardNoPermissionAuth as the second auth type.",
    "expected_output": "Box::pin(api::server_wrap(\n    flow,\n    state,\n    &req,\n    file_id,\n    |state, auth: auth::AuthenticationData, req, _| {\n        let merchant_context = domain::MerchantContext::NormalMerchant(Box::new(\n            domain::Context(auth.merchant_account, auth.key_store),\n        ));\n        files_retrieve_core(state, merchant_context, req)\n    },\n    auth::auth_type(\n        &auth::HeaderAuth(auth::ApiKeyAuth {\n            is_connected_allowed: false,\n            is_platform_allowed: false,\n        }),\n        &auth::DashboardNoPermissionAuth,\n        req.headers(),\n    ),\n    api_locking::LockAction::NotApplicable,\n))\n.await",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "files_create",
        "files_delete",
        "files_retrieve_core"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/router/src/services/authentication.rs"
      ]
    }
  },
  {
    "id": "gen_027",
    "file_path": "crates/router/src/core/revenue_recovery/types.rs",
    "task_type": "code_generation",
    "context_code": "match self {\n    Self::Succeeded => {\n        // finish psync task as the payment was a success\n        db.as_scheduler()\n            .finish_process_with_business_status(\n                process_tracker,\n                business_status::PSYNC_WORKFLOW_COMPLETE,\n            )\n            .await?;\n\n        let event_status = common_enums::EventType::PaymentSucceeded;\n        // TODO: Publish revenue recovery event to Kafka\n    }\n}",
    "prompt": "Complete the Kafka event publishing logic for successful revenue recovery payments. Call publish_revenue_recovery_event_to_kafka with the recovery_payment_tuple and retry_count+1.",
    "constraints": "Use RecoveryPaymentTuple::publish_revenue_recovery_event_to_kafka. Handle errors by logging them with router_env::logger::error. Don't propagate the error.",
    "expected_output": "if let Err(e) = recovery_incoming_flow::RecoveryPaymentTuple::publish_revenue_recovery_event_to_kafka(\n    state,\n    &recovery_payment_tuple,\n    Some(retry_count+1)\n)\n.await{\n    router_env::logger::error!(\n        \"Failed to publish revenue recovery event to kafka: {:?}\",\n        e\n    );\n};",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "publish_revenue_recovery_event_to_kafka",
        "finish_process_with_business_status"
      ],
      "related_files": [
        "crates/router/src/core/revenue_recovery/incoming_flow.rs",
        "crates/router/src/events/kafka.rs"
      ]
    }
  },
  {
    "id": "gen_028",
    "file_path": "crates/external_services/build.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"dynamic_routing\")]\n{\n    let proto_path = router_env::workspace_path().join(\"proto\");\n    let success_rate_proto_file = proto_path.join(\"success_rate.proto\");\n    let contract_routing_proto_file = proto_path.join(\"contract_routing.proto\");\n    let elimination_proto_file = proto_path.join(\"elimination_rate.proto\");\n    let health_check_proto_file = proto_path.join(\"health_check.proto\");\n    let out_dir = std::path::PathBuf::from(std::env::var(\"OUT_DIR\")?);\n    // TODO: Configure tonic_build to compile these proto files\n}",
    "prompt": "Complete the tonic_build configuration to compile the dynamic routing proto files. Set the output directory and compile all four proto files.",
    "constraints": "Use tonic_build::configure() with out_dir(). Compile all proto files in a single compile_protos call. Pass proto_path as the include directory.",
    "expected_output": "tonic_build::configure()\n    .out_dir(out_dir)\n    .compile_protos(\n        &[\n            success_rate_proto_file,\n            health_check_proto_file,\n            elimination_proto_file,\n            contract_routing_proto_file,\n        ],\n        &[proto_path],\n    )\n    .expect(\"Failed to compile proto files\");",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "tonic_build::configure",
        "compile_protos"
      ],
      "related_files": [
        "proto/success_rate.proto",
        "proto/contract_routing.proto"
      ]
    }
  },
  {
    "id": "gen_029",
    "file_path": "crates/common_utils/src/tokenization.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\npub struct TokenizationResponse {\n    pub token: String,\n    pub token_type: TokenType,\n    pub expires_at: Option<i64>,\n}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl TokenizationResponse {\n    // TODO: Add a constructor method\n}",
    "prompt": "Add a constructor method 'new' for TokenizationResponse that takes token, token_type, and an optional expires_at parameter.",
    "constraints": "Make expires_at an Option<i64> parameter. Return Self. Keep the method simple and straightforward.",
    "expected_output": "pub fn new(token: String, token_type: TokenType, expires_at: Option<i64>) -> Self {\n    Self {\n        token,\n        token_type,\n        expires_at,\n    }\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "TokenType"
      ],
      "related_files": [
        "crates/common_utils/src/lib.rs"
      ]
    }
  },
  {
    "id": "gen_030",
    "file_path": "crates/hyperswitch_domain_models/src/router_flow_types.rs",
    "task_type": "code_generation",
    "context_code": "pub mod access_token_auth;\npub mod authentication;\npub mod dispute;\npub mod files;\npub mod fraud_check;\npub mod mandate_revoke;\npub mod payments;\npub mod payouts;\npub mod refunds;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\npub mod vault;\npub mod webhooks;\n// TODO: Add re-exports for authentication module",
    "prompt": "Add the missing re-export statement for the authentication module. Follow the pattern used for other modules.",
    "constraints": "Use 'pub use authentication::*;' to re-export all items from the authentication module.",
    "expected_output": "pub use authentication::*;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_flow_types/authentication.rs"
      ]
    }
  },
  {
    "id": "gen_031",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn delete_file_using_file_id(\n    state: &SessionState,\n    file_key: String,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    let file_metadata_object = state\n        .store\n        .find_file_metadata_by_merchant_id_file_id(\n            merchant_context.get_merchant_account().get_id(),\n            &file_key,\n        )\n        .await\n        .change_context(errors::ApiErrorResponse::FileNotFound)?;\n    // TODO: Call delete_file_from_connector and handle the response\n}",
    "prompt": "Complete the file deletion logic by calling delete_file_from_connector with the appropriate parameters and handling any errors that may occur.",
    "constraints": "Use helpers::delete_file_from_connector(). Pass state, file_metadata_object, and merchant_context. Handle errors by converting them to ApiErrorResponse.",
    "expected_output": "helpers::delete_file_from_connector(\n    state,\n    file_metadata_object,\n    &merchant_context,\n)\n.await\n.change_context(errors::ApiErrorResponse::InternalServerError)\n.attach_printable(\"Failed to delete file from connector\")?;\n\nOk(())",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "delete_file_from_connector",
        "find_file_metadata_by_merchant_id_file_id"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "gen_032",
    "file_path": "crates/external_services/build.rs",
    "task_type": "code_generation",
    "context_code": "#[allow(clippy::expect_used)]\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    #[cfg(feature = \"revenue_recovery\")]\n    {\n        let proto_base_path = router_env::workspace_path().join(\"proto\");\n        let out_dir = std::path::PathBuf::from(std::env::var(\"OUT_DIR\")?);\n        let recovery_proto_files = [proto_base_path.join(\"recovery_decider.proto\")];\n        // TODO: Configure tonic_build for revenue recovery proto compilation\n    }\n    Ok(())\n}",
    "prompt": "Complete the tonic_build configuration for compiling revenue recovery proto files. Set output directory, enable well-known types compilation, and configure external path mapping for Timestamp.",
    "constraints": "Use tonic_build::configure() with out_dir(), compile_well_known_types(), and extern_path(). Follow the pattern from dynamic_routing feature.",
    "expected_output": "tonic_build::configure()\n    .out_dir(&out_dir)\n    .compile_well_known_types(true)\n    .extern_path(\".google.protobuf.Timestamp\", \"::prost_types::Timestamp\")\n    .compile_protos(&recovery_proto_files, &[&proto_base_path])\n    .expect(\"Failed to compile revenue-recovery proto files\");",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "tonic_build::configure",
        "compile_protos"
      ],
      "related_files": [
        "proto/recovery_decider.proto",
        "crates/router_env/src/lib.rs"
      ]
    }
  },
  {
    "id": "gen_033",
    "file_path": "crates/diesel_models/src/schema_v2.rs",
    "task_type": "code_generation",
    "context_code": "diesel::table! {\n    use diesel::sql_types::*;\n    use crate::enums::diesel_exports::*;\n\n    incremental_authorization (authorization_id, merchant_id) {\n        #[max_length = 64]\n        authorization_id -> Varchar,\n        #[max_length = 64]\n        merchant_id -> Varchar,\n        #[max_length = 64]\n        payment_id -> Varchar,\n        amount -> Int8,\n        created_at -> Timestamp,\n        modified_at -> Timestamp,\n        // TODO: Add remaining fields for incremental authorization\n    }\n}",
    "prompt": "Complete the incremental_authorization table schema by adding the status, error_code, error_message, connector_authorization_id, and previously_authorized_amount fields.",
    "constraints": "Follow the existing field patterns. Use appropriate max_length constraints for varchar fields. Make error fields nullable.",
    "expected_output": "#[max_length = 64]\nstatus -> Varchar,\n#[max_length = 255]\nerror_code -> Nullable<Varchar>,\nerror_message -> Nullable<Text>,\n#[max_length = 64]\nconnector_authorization_id -> Nullable<Varchar>,\npreviously_authorized_amount -> Int8,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/diesel_models/src/incremental_authorization.rs"
      ]
    }
  },
  {
    "id": "gen_034",
    "file_path": "crates/hyperswitch_interfaces/src/lib.rs",
    "task_type": "code_generation",
    "context_code": "//! Hyperswitch interface\n#![warn(missing_docs, missing_debug_implementations)]\n\npub mod api;\n/// API client interface module\npub mod api_client;\npub mod authentication;\n/// Configuration related functionalities\npub mod configs;\n/// Connector integration interface module\npub mod connector_integration_interface;\n/// definition of the new connector integration trait\npub mod connector_integration_v2;\n// TODO: Add module declarations for remaining interfaces",
    "prompt": "Add the missing module declarations for consts, conversion_impls, disputes, encryption_interface, errors, events, helpers, integrity, metrics, secrets_interface, types, unified_connector_service, webhooks, and crm.",
    "constraints": "Follow the existing documentation pattern. Add doc comments for modules that need them.",
    "expected_output": "/// Constants used throughout the application\npub mod consts;\n/// Conversion implementations\npub mod conversion_impls;\npub mod disputes;\npub mod encryption_interface;\npub mod errors;\n/// Event handling interface\npub mod events;\n/// helper utils\npub mod helpers;\n/// connector integrity check interface\npub mod integrity;\npub mod metrics;\npub mod secrets_interface;\npub mod types;\n/// ucs handlers\npub mod unified_connector_service;\npub mod webhooks;\n\n/// Crm interface\npub mod crm;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/hyperswitch_interfaces/src/api.rs",
        "crates/hyperswitch_interfaces/src/errors.rs"
      ]
    }
  },
  {
    "id": "gen_035",
    "file_path": "crates/common_utils/src/tokenization.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\npub struct TokenizationResponse {\n    pub token: String,\n    pub token_type: TokenType,\n    pub expires_at: Option<i64>,\n}\n\n#[cfg(all(feature = \"v2\", feature = \"tokenization_v2\"))]\nimpl TokenizationResponse {\n    // TODO: Add validation method to check if token is expired\n}",
    "prompt": "Add a method `is_expired` that checks if the token has expired based on the current timestamp. Return true if expired or if expires_at is None.",
    "constraints": "Use common_utils::date_time::now() to get current timestamp. Compare with expires_at field. Handle the Option type appropriately.",
    "expected_output": "pub fn is_expired(&self) -> bool {\n    match self.expires_at {\n        Some(expiry) => {\n            let current_time = common_utils::date_time::now().assume_utc().unix_timestamp();\n            current_time >= expiry\n        }\n        None => true,\n    }\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "date_time::now"
      ],
      "related_files": [
        "crates/common_utils/src/date_time.rs"
      ]
    }
  },
  {
    "id": "gen_036",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "# Add enum for this connector in test folder\nsed -i'' -e \"s/mod utils;/mod ${payment_gateway};\\nmod utils;/\" ${tests}/main.rs\nsed -i'' -e \"s/    pub $previous_connector: \\(.*\\)/\\tpub $previous_connector: \\1\\n\\tpub ${payment_gateway}: Option<HeaderKey>,/\" ${test_utils}/connector_auth.rs\n# TODO: Add connector configuration to sample_auth.toml",
    "prompt": "Complete the script by adding the connector configuration entry to sample_auth.toml. The entry should include a section header and an api_key field.",
    "constraints": "Use echo to append to the file. Follow the TOML format with section header [connector_name] and api_key field.",
    "expected_output": "echo \"\\n\\n[${payment_gateway}]\\napi_key=\\\"API Key\\\"\" >> ${tests}/sample_auth.toml",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/router/tests/connectors/sample_auth.toml"
      ]
    }
  },
  {
    "id": "gen_037",
    "file_path": "crates/hyperswitch_domain_models/Cargo.toml",
    "task_type": "code_generation",
    "context_code": "[features]\ndefault = [\"olap\", \"frm\"]\nencryption_service = []\nolap = []\npayouts = [\"api_models/payouts\"]\nfrm = [\"api_models/frm\"]\nv2 = [\"api_models/v2\", \"diesel_models/v2\", \"common_utils/v2\", \"common_types/v2\"]\nv1 = [\"api_models/v1\", \"diesel_models/v1\", \"common_utils/v1\", \"common_types/v1\"]\ntokenization_v2 = [\"api_models/tokenization_v2\", \"diesel_models/tokenization_v2\"]\ndummy_connector = []\n# TODO: Add revenue_recovery feature",
    "prompt": "Add the revenue_recovery feature flag. It should be an empty feature (no dependencies).",
    "constraints": "Follow the same pattern as dummy_connector and encryption_service features.",
    "expected_output": "revenue_recovery = []",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/hyperswitch_connectors/Cargo.toml"
      ]
    }
  },
  {
    "id": "gen_038",
    "file_path": "crates/router/src/core/revenue_recovery/types.rs",
    "task_type": "code_generation",
    "context_code": "match self {\n    Self::Succeeded => {\n        // finish psync task as the payment was a success\n        db.as_scheduler()\n            .finish_process_with_business_status(\n                process_tracker,\n                business_status::PSYNC_WORKFLOW_COMPLETE,\n            )\n            .await?;\n\n        let event_status = common_enums::EventType::PaymentSucceeded;\n        // TODO: Update payment processor token error code in Redis\n    }\n}",
    "prompt": "Complete the token error code update logic. Call update_payment_processor_token_error_code_from_process_tracker with appropriate parameters for a successful payment.",
    "constraints": "Use RedisTokenManager::update_payment_processor_token_error_code_from_process_tracker. Pass None for error_code and Some(false) for is_hard_decline since payment succeeded. Handle the result by assigning to _update_error_code.",
    "expected_output": "let _update_error_code = storage::revenue_recovery_redis_operation::RedisTokenManager::update_payment_processor_token_error_code_from_process_tracker(\n    state,\n    &connector_customer_id,\n    &None,\n    &Some(false),\n    used_token.as_deref(),\n)\n.await;",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "update_payment_processor_token_error_code_from_process_tracker",
        "unlock_connector_customer_status"
      ],
      "related_files": [
        "crates/storage_impl/src/redis/revenue_recovery.rs"
      ]
    }
  },
  {
    "id": "gen_039",
    "file_path": "add_connector.md",
    "task_type": "code_generation",
    "context_code": "### 2. **Download the OpenAPI Specification from your connector**\n\nFirst, obtain the OpenAPI specification from your payment processor's developer documentation.\n\n```bash\ncurl -o <ConnectorName>-openapi.json <schema-url>\n```\n\n# TODO: Add openapi-generator command to generate Rust types",
    "prompt": "Add the openapi-generator command that generates Rust types from the OpenAPI specification. Use environment variables CONNECTOR_NAME and SCHEMA_PATH.",
    "constraints": "Use openapi-generator with rust generator. Set output directory to crates/hyperswitch_connectors/src/connectors/${CONNECTOR_NAME}/. Generate only models and supporting files.",
    "expected_output": "```bash\n# Generate Rust types from OpenAPI specification\nopenapi-generator generate \\\n  -i \"${SCHEMA_PATH}\" \\\n  -g rust \\\n  -o \"crates/hyperswitch_connectors/src/connectors/${CONNECTOR_NAME}\" \\\n  --additional-properties=packageName=${CONNECTOR_NAME} \\\n  --global-property=models,supportingFiles=temp.rs\n```",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/"
      ]
    }
  },
  {
    "id": "gen_040",
    "file_path": "crates/router/src/routes/files.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"v1\")]\n#[instrument(skip_all, fields(flow = ?Flow::CreateFile))]\npub async fn files_create(\n    state: web::Data<AppState>,\n    req: HttpRequest,\n    payload: Multipart,\n) -> HttpResponse {\n    let flow = Flow::CreateFile;\n    let create_file_request_result = transformers::get_create_file_request(payload).await;\n    // TODO: Add error handling for invalid multipart data\n}",
    "prompt": "Complete the error handling for the multipart file upload. Check if create_file_request_result is an error and return an appropriate error response using api::log_and_return_error_response.",
    "constraints": "Use pattern matching on create_file_request_result. Return early if there's an error. Store the valid request in create_file_request variable.",
    "expected_output": "let create_file_request = match create_file_request_result {\n    Ok(valid_request) => valid_request,\n    Err(err) => return api::log_and_return_error_response(err),\n};",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "get_create_file_request",
        "log_and_return_error_response"
      ],
      "related_files": [
        "crates/router/src/routes/files/transformers.rs",
        "crates/router/src/services/api.rs"
      ]
    }
  },
  {
    "id": "gen_041",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn files_create_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    create_file_request: api::CreateFileRequest,\n) -> RouterResponse<files::CreateFileResponse> {\n    helpers::validate_file_upload(\n        &state,\n        merchant_context.clone(),\n        create_file_request.clone(),\n    )\n    .await?;\n    let file_id = common_utils::generate_id(consts::ID_LENGTH, \"file\");\n    // TODO: Create file_key by combining merchant_id and file_id\n}",
    "prompt": "Complete the file_key generation logic. Combine the merchant ID from merchant_context with the file_id using a forward slash separator.",
    "constraints": "Use format! macro. Get merchant_id using merchant_context.get_merchant_account().get_id().get_string_repr().",
    "expected_output": "let file_key = format!(\n    \"{}/{}\",\n    merchant_context\n        .get_merchant_account()\n        .get_id()\n        .get_string_repr(),\n    file_id\n);",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "generate_id",
        "get_merchant_account"
      ],
      "related_files": [
        "crates/common_utils/src/lib.rs",
        "crates/hyperswitch_domain_models/src/merchant_account.rs"
      ]
    }
  },
  {
    "id": "gen_042",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();\n    let connector_data = api::ConnectorData::get_connector_by_name(\n        &state.conf.connectors,\n        connector,\n        api::GetToken::Connector,\n        file_metadata.merchant_connector_id.clone(),\n    )?;\n    // TODO: Extract file_data from retrieve_file_response and return it\n}",
    "prompt": "Complete the file retrieval by extracting the response, handling errors, and returning the file_data. The response is stored in retrieve_file_response variable and contains a Result with file_data field.",
    "constraints": "Use map_err to convert connector errors to ApiErrorResponse::ExternalConnectorError. Include code, message, connector name, status_code, and reason in the error. Return retrieve_file_response.file_data.",
    "expected_output": "let retrieve_file_response =\n    response\n        .response\n        .map_err(|err| errors::ApiErrorResponse::ExternalConnectorError {\n            code: err.code,\n            message: err.message,\n            connector: connector.to_string(),\n            status_code: err.status_code,\n            reason: err.reason,\n        })?;\nOk(retrieve_file_response.file_data)",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "execute_connector_processing_step",
        "to_files_failed_response"
      ],
      "related_files": [
        "crates/router/src/services/api.rs",
        "crates/router/src/core/errors.rs"
      ]
    }
  },
  {
    "id": "gen_043",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe.rs",
    "task_type": "code_generation",
    "context_code": "impl ConnectorCommon for Stripe {\n    fn id(&self) -> &'static str {\n        \"stripe\"\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/x-www-form-urlencoded\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.stripe.base_url.as_ref()\n    }\n\n    fn get_auth_header(\n        &self,\n        auth_type: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, Maskable<String>)>, ConnectorError> {\n        let auth = stripe::StripeAuthType::try_from(auth_type)\n            .change_context(ConnectorError::FailedToObtainAuthType)?;\n        Ok(vec![\n            (\n                AUTHORIZATION.to_string(),\n                format!(\"Bearer {}\", auth.api_key.peek()).into_masked(),\n            ),\n            (\n                auth_headers::STRIPE_API_VERSION.to_string(),\n                auth_headers::STRIPE_VERSION.to_string().into_masked(),\n            ),\n        ])\n    }\n}",
    "prompt": "Implement the `build_error_response` function for a new connector named `TestConnector` that uses a similar error response structure to Stripe. The error response should include `status_code`, `code`, `message`, `reason`, `attempt_status`, `connector_transaction_id`, `network_advice_code`, `network_decline_code`, and `network_error_message`.",
    "constraints": "The error response structure should be `TestConnectorErrorResponse` with fields `error.code`, `error.message`, `error.payment_intent.id`, `error.network_advice_code`, `error.network_decline_code`, and `error.decline_code`.",
    "expected_output": "fn build_error_response(\n    &self,\n    res: Response,\n    event_builder: Option<&mut ConnectorEvent>,\n) -> CustomResult<ErrorResponse, ConnectorError> {\n    use hyperswitch_interfaces::consts::NO_ERROR_CODE;\n\n    let response: testconnector::TestConnectorErrorResponse = res\n        .response\n        .parse_struct(\"TestConnectorErrorResponse\")\n        .change_context(ConnectorError::ResponseDeserializationFailed)?;\n    event_builder.map(|i| i.set_error_response_body(&response));\n    router_env::logger::info!(connector_response=?response);\n    Ok(ErrorResponse {\n        status_code: res.status_code,\n        code: response\n            .error\n            .code\n            .unwrap_or_else(|| NO_ERROR_CODE.to_string()),\n        message: response\n            .error\n            .message\n            .clone()\n            .unwrap_or_else(|| consts::NO_ERROR_MESSAGE.to_string()),\n        reason: response.error.message,\n        attempt_status: None,\n        connector_transaction_id: response.error.payment_intent.map(|pi| pi.id),\n        network_advice_code: response.error.network_advice_code,\n        network_decline_code: response.error.network_decline_code,\n        network_error_message: response.error.decline_code.or(response.error.advice_code),\n        connector_metadata: None,\n    })\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "build_error_response",
        "parse_struct"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/stripe.rs",
      "crates/hyperswitch_interfaces/src/api.rs",
      "add_connector.md"
    ]
  },
  {
    "id": "gen_044",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"/pub ${previous_connector}: Option<ConnectorTomlConfig>,/a\\\n    pub ${payment_gateway}: Option<ConnectorTomlConfig>,\n\" crates/connector_configs/src/connector.rs",
    "prompt": "Add a new `sed` command to `scripts/add_connector.sh` that inserts a new connector's `ConnectorParams` into `crates/hyperswitch_domain_models/src/connector_endpoints.rs`.",
    "constraints": "The new connector's name should be represented by the shell variable `${payment_gateway}` and the previous connector by `${previous_connector}`. The insertion should happen after the line containing `pub ${previous_connector}: ConnectorParams,`.",
    "expected_output": "sed -i'' -e \"/pub ${previous_connector}: ConnectorParams,/a\\\n    pub ${payment_gateway}: ConnectorParams,\n\" crates/hyperswitch_domain_models/src/connector_endpoints.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/hyperswitch_domain_models/src/connector_endpoints.rs"
    ]
  },
  {
    "id": "gen_045",
    "file_path": "crates/hyperswitch_connectors/src/connectors/fiservemea.rs",
    "task_type": "code_generation",
    "context_code": "impl ConnectorCommon for Fiservemea {\n    fn id(&self) -> &'static str {\n        \"fiservemea\"\n    }\n\n    fn get_currency_unit(&self) -> api::CurrencyUnit {\n        api::CurrencyUnit::Base\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn base_url<'a>(&self, connectors: &'a Connectors) -> &'a str {\n        connectors.fiservemea.base_url.as_ref()\n    }\n\n    fn build_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        let response: fiservemea::FiservemeaErrorResponse = res\n            .response\n            .parse_struct(\"FiservemeaErrorResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n        event_builder.map(|i| i.set_response_body(&response));\n        router_env::logger::info!(connector_response=?response);\n\n        match response.error {\n            Some(error) => {\n                let details = error.details.map(|details| {\n                    details\n                        .iter()\n                        .map(|detail| {\n                            format!(\n                                \"{}: {}\",\n                                detail\n                                    .field\n                                    .clone()\n                                    .unwrap_or(\"No Field Provided\".to_string()),\n                                detail\n                                    .message\n                                    .clone()\n                                    .unwrap_or(\"No Message Provided\".to_string())\n                            )\n                        })\n                        .collect::<Vec<String>>()\n                        .join(\", \")\n                });\n                Ok(ErrorResponse {\n                    status_code: res.status_code,\n                    code: error.code.unwrap_or(consts::NO_ERROR_CODE.to_string()),\n                    message: response\n                        .response_type\n                        .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n                    reason: match details {\n                        Some(details) => Some(format!(\n                            \"{} {}\",\n                            error.message.unwrap_or(\"\".to_string()),\n                            details\n                        )),\n                        None => error.message,\n                    },\n                    attempt_status: None,\n                    connector_transaction_id: None,\n                    network_advice_code: None,\n                    network_decline_code: None,\n                    network_error_message: None,\n                    connector_metadata: None,\n                })\n            }\n            None => Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: consts::NO_ERROR_CODE.to_string(),\n                message: response\n                    .response_type\n                    .clone()\n                    .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n                reason: response.response_type,\n                attempt_status: None,\n                connector_transaction_id: None,\n                network_advice_code: None,\n                network_decline_code: None,\n                network_error_message: None,\n                connector_metadata: None,\n            }),\n        }\n    }\n}",
    "prompt": "Modify the `build_error_response` function for `Fiservemea` to include `network_advice_code`, `network_decline_code`, and `network_error_message` from the `FiservemeaErrorResponse` if available.",
    "constraints": "The `FiservemeaErrorResponse` should have fields `error.network_advice_code`, `error.network_decline_code`, and `error.network_error_message`.",
    "expected_output": "fn build_error_response(\n    &self,\n    res: Response,\n    event_builder: Option<&mut ConnectorEvent>,\n) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n    let response: fiservemea::FiservemeaErrorResponse = res\n        .response\n        .parse_struct(\"FiservemeaErrorResponse\")\n        .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n\n    event_builder.map(|i| i.set_response_body(&response));\n    router_env::logger::info!(connector_response=?response);\n\n    match response.error {\n        Some(error) => {\n            let details = error.details.map(|details| {\n                details\n                    .iter()\n                    .map(|detail| {\n                        format!(\n                            \"{}: {}\",\n                            detail\n                                .field\n                                .clone()\n                                .unwrap_or(\"No Field Provided\".to_string()),\n                            detail\n                                .message\n                                .clone()\n                                .unwrap_or(\"No Message Provided\".to_string())\n                        )\n                    })\n                    .collect::<Vec<String>>()\n                    .join(\", \")\n            });\n            Ok(ErrorResponse {\n                status_code: res.status_code,\n                code: error.code.unwrap_or(consts::NO_ERROR_CODE.to_string()),\n                message: response\n                    .response_type\n                    .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n                reason: match details {\n                    Some(details) => Some(format!(\n                        \"{} {}\",\n                        error.message.unwrap_or(\"\".to_string()),\n                        details\n                    )),\n                    None => error.message,\n                },\n                attempt_status: None,\n                connector_transaction_id: None,\n                network_advice_code: error.network_advice_code,\n                network_decline_code: error.network_decline_code,\n                network_error_message: error.network_error_message,\n                connector_metadata: None,\n            })\n        }\n        None => Ok(ErrorResponse {\n            status_code: res.status_code,\n            code: consts::NO_ERROR_CODE.to_string(),\n            message: response\n                .response_type\n                .clone()\n                .unwrap_or(consts::NO_ERROR_MESSAGE.to_string()),\n            reason: response.response_type,\n            attempt_status: None,\n            connector_transaction_id: None,\n            network_advice_code: None,\n            network_decline_code: None,\n            network_error_message: None,\n            connector_metadata: None,\n        }),\n    }\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "build_error_response",
        "parse_struct"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/fiservemea.rs",
      "crates/hyperswitch_interfaces/src/api.rs"
    ]
  },
  {
    "id": "gen_046",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|pub mod $previous_connector;|pub mod $previous_connector;\\npub mod ${payment_gateway};|\" $conn.rs",
    "prompt": "Add a new `sed` command to insert a new connector module declaration after an existing one in `crates/hyperswitch_connectors/src/connectors.rs`.",
    "constraints": "The new connector is named `testconnector` and the previous connector is `previous_connector`. The `payment_gateway` variable holds `testconnector`.",
    "expected_output": "sed -i'' -e \"s|pub mod previous_connector;|pub mod previous_connector;\\npub mod testconnector;|\" $conn.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_047",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/};/ ${payment_gateway}::${payment_gateway_camelcase},\\n};/\" $conn.rs",
    "prompt": "Modify the `sed` command to correctly insert a new connector's camelcase enum variant into `crates/hyperswitch_connectors/src/connectors.rs`.",
    "constraints": "The new connector is `testconnector` and its camelcase variant is `Testconnector`. The `payment_gateway` variable holds `testconnector` and `payment_gateway_camelcase` holds `Testconnector`.",
    "expected_output": "sed -i'' -e \"s/};/ testconnector::Testconnector,\\n};/\" $conn.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_048",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "prompt": "Generate a `sed` command to add a new connector's base URL to the development configuration files.",
    "constraints": "The new connector is `testconnector` with base URL `https://test.testconnector.com`. The `payment_gateway` variable holds `testconnector` and `base_url` holds `https://test.testconnector.com`. The `previous_connector` is `adyen`.",
    "expected_output": "sed -i'' -e \"s|adyen.base_url \\(.*\\)|adyen.base_url \\1\\ntestconnector.base_url = \\\"https://test.testconnector.com\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "config/development.toml",
      "config/docker_compose.toml",
      "config/config.example.toml"
    ]
  },
  {
    "id": "gen_049",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/api_models/src/connector_enums.rs",
    "prompt": "Add a new `sed` command to insert a new connector's camelcase enum variant into `crates/api_models/src/connector_enums.rs`.",
    "constraints": "The new connector is `testconnector` and its camelcase variant is `Testconnector`. The `payment_gateway_camelcase` variable holds `Testconnector`.",
    "expected_output": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\tTestconnector,/\" crates/api_models/src/connector_enums.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/api_models/src/connector_enums.rs"
    ]
  },
  {
    "id": "gen_050",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs",
    "prompt": "Generate a `sed` command to add a new connector to the `default_imp_for_connector_request_id!` macro in `crates/router/src/core/payments/flows.rs`.",
    "constraints": "The new connector is `testconnector` and its camelcase variant is `Testconnector`. The `payment_gateway_camelcase` variable holds `Testconnector`.",
    "expected_output": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::Testconnector,/\" $src/core/payments/flows.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/src/core/payments/flows.rs"
    ]
  },
  {
    "id": "gen_051",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"/pub ${previous_connector}: Option<ConnectorTomlConfig>,/a\\n    pub ${payment_gateway}: Option<ConnectorTomlConfig>,\\n\" crates/connector_configs/src/connector.rs",
    "prompt": "Generate a `sed` command to add a new connector's `ConnectorTomlConfig` field to the `Connectors` struct in `crates/connector_configs/src/connector.rs`.",
    "constraints": "The new connector is `testconnector` and the previous connector is `previous_connector`. The `payment_gateway` variable holds `testconnector`.",
    "expected_output": "sed -i'' -e \"/pub previous_connector: Option<ConnectorTomlConfig>,/a\\n    pub testconnector: Option<ConnectorTomlConfig>,\\n\" crates/connector_configs/src/connector.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/connector_configs/src/connector.rs"
    ]
  },
  {
    "id": "gen_052",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"/mod utils;/ s/mod utils;/mod ${payment_gateway};\\nmod utils;/\" crates/router/tests/connectors/main.rs",
    "prompt": "Generate a `sed` command to add a new connector's test module declaration to `crates/router/tests/connectors/main.rs`.",
    "constraints": "The new connector is `testconnector`. The `payment_gateway` variable holds `testconnector`.",
    "expected_output": "sed -i'' -e \"/mod utils;/ s/mod utils;/mod testconnector;\\nmod utils;/\" crates/router/tests/connectors/main.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/tests/connectors/main.rs"
    ]
  },
  {
    "id": "gen_053",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/    pub $previous_connector: \\(.*\\)/\\tpub $previous_connector: \\1\\n\\tpub ${payment_gateway}: Option<HeaderKey>,/\" ${test_utils}/connector_auth.rs",
    "prompt": "Generate a `sed` command to add a new connector's authentication configuration to `crates/test_utils/src/connector_auth.rs`.",
    "constraints": "The new connector is `testconnector` and the previous connector is `previous_connector`. The `payment_gateway` variable holds `testconnector`.",
    "expected_output": "sed -i'' -e \"s/    pub previous_connector: \\(.*\\)/\\tpub previous_connector: \\1\\n\\tpub testconnector: Option<HeaderKey>,/\" ${test_utils}/connector_auth.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/test_utils/src/connector_auth.rs"
    ]
  },
  {
    "id": "gen_054",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "echo \"\\n\\n[${payment_gateway}]\\napi_key=\\\"API Key\\\"\" >> ${tests}/sample_auth.toml",
    "prompt": "Generate a `sed` command to append a new connector's basic authentication configuration to `crates/router/tests/connectors/sample_auth.toml`.",
    "constraints": "The new connector is `testconnector`. The `payment_gateway` variable holds `testconnector`.",
    "expected_output": "echo \"\\n\\n[testconnector]\\napi_key=\\\"API Key\\\"\" >> ${tests}/sample_auth.toml",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/tests/connectors/sample_auth.toml"
    ]
  },
  {
    "id": "gen_055",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/^default_imp_for_fraud_check!(/default_imp_for_fraud_check!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs",
    "prompt": "Generate a `sed` command to add a new connector to the `default_imp_for_fraud_check!` macro in `crates/router/src/core/payments/flows.rs`.",
    "constraints": "The new connector is `testconnector` and its camelcase variant is `Testconnector`. The `payment_gateway_camelcase` variable holds `Testconnector`.",
    "expected_output": "sed -i'' -e \"s/^default_imp_for_fraud_check!(/default_imp_for_fraud_check!(\\n    connectors::Testconnector,/\" $src/core/payments/flows.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/src/core/payments/flows.rs"
    ]
  },
  {
    "id": "gen_056",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "connectors=(aci adyen adyenplatform affirm airwallex amazonpay applepay archipel authipay authorizedotnet bambora bamboraapac bankofamerica barclaycard billwerk bitpay blackhawknetwork bluesnap boku braintree breadpay calida cashtocode celero chargebee checkbook checkout coinbase cryptopay ctp_visa custombilling cybersource datatrans deutschebank digitalvirgo dlocal dummyconnector dwolla ebanx elavon envoy facilitapay finix fiserv fiservemea fiuu flexiti forte getnet gigadat globalpay globepay gocardless gpayments helcim hipay hyperswitch_vault hyperwallet iatapay inespay itaubank jpmorgan juspaythreedsserver katapult klarna loonio mifinity mollie moneris mpgs multisafepay netcetera nexinets nexixpay nomupay noon nordea novalnet nuvei opayo opennode paybox payeezy payjustnow paymentwall paypal payu payone paysafecard paytm payu payzen placetopay plaid powertranz prophetpay rapyd razorpay redsys riskified shift4 signifyd square stax stripe taxjar threedsecureio thunes tillpayments trustpay tsys unified_authentication_service volt wellsfargo wise worldline worldpay xendit zen zsl)",
    "prompt": "Add a new connector named 'testconnector' to the `connectors` array in `scripts/add_connector.sh`.",
    "constraints": "The new connector should be added in alphabetical order.",
    "expected_output": "connectors=(aci adyen adyenplatform affirm airwallex amazonpay applepay archipel authipay authorizedotnet bambora bamboraapac bankofamerica barclaycard billwerk bitpay blackhawknetwork bluesnap boku braintree breadpay calida cashtocode celero chargebee checkbook checkout coinbase cryptopay ctp_visa custombilling cybersource datatrans deutschebank digitalvirgo dlocal dummyconnector dwolla ebanx elavon envoy facilitapay finix fiserv fiservemea fiuu flexiti forte getnet gigadat globalpay globepay gocardless gpayments helcim hipay hyperswitch_vault hyperwallet iatapay inespay itaubank jpmorgan juspaythreedsserver katapult klarna loonio mifinity mollie moneris mpgs multisafepay netcetera nexinets nexixpay nomupay noon nordea novalnet nuvei opayo opennode paybox payeezy payjustnow paymentwall paypal payu payone paysafecard paytm payu payzen placetopay plaid powertranz prophetpay rapyd razorpay redsys riskified shift4 signifyd square stax stripe taxjar testconnector threedsecureio thunes tillpayments trustpay tsys unified_authentication_service volt wellsfargo wise worldline worldpay xendit zen zsl)",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "find_prev_connector"
      ]
    },
    "related_files": [
      "scripts/add_connector.sh"
    ]
  },
  {
    "id": "gen_057",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|pub mod $previous_connector;|pub mod $previous_connector;\\npub mod ${payment_gateway};|\" $conn.rs",
    "prompt": "Modify the `sed` command to insert `pub mod newconnector;` after `pub mod existingconnector;` in `$conn.rs`.",
    "constraints": "The `sed` command should use the `previous_connector` and `payment_gateway` variables.",
    "expected_output": "sed -i'' -e \"s|pub mod existingconnector;|pub mod existingconnector;\\npub mod newconnector;|\" $conn.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_058",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "prompt": "Add a new base URL entry for 'newconnector' with the URL 'https://api.newconnector.com' in `config/development.toml` and other configuration files, following the pattern of `previous_connector`.",
    "constraints": "The `sed` command should use the `previous_connector`, `payment_gateway`, and `base_url` variables.",
    "expected_output": "sed -i'' -e \"s|existingconnector.base_url \\(.*\\)|existingconnector.base_url \\1\\nnewconnector.base_url = \\\"https://api.newconnector.com\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "config/development.toml",
      "config/docker_compose.toml",
      "config/config.example.toml"
    ]
  },
  {
    "id": "gen_059",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/api_models/src/connector_enums.rs",
    "prompt": "Add a new enum variant `NewConnector` to the `Connector` enum in `crates/api_models/src/connector_enums.rs`.",
    "constraints": "The `sed` command should use the `payment_gateway_camelcase` variable.",
    "expected_output": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\tNewConnector,/\" crates/api_models/src/connector_enums.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/api_models/src/connector_enums.rs"
    ]
  },
  {
    "id": "gen_060",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/euclid/src/enums.rs",
    "prompt": "Add a new enum variant `NewConnector` to the `Connector` enum in `crates/euclid/src/enums.rs`.",
    "constraints": "The `sed` command should use the `payment_gateway_camelcase` variable.",
    "expected_output": "sed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\tNewConnector,/\" crates/euclid/src/enums.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/euclid/src/enums.rs"
    ]
  },
  {
    "id": "gen_061",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs",
    "prompt": "Add `connectors::NewConnector,` to the `default_imp_for_connector_request_id!` macro in `$src/core/payments/flows.rs`.",
    "constraints": "The `sed` command should use the `payment_gateway_camelcase` variable.",
    "expected_output": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::NewConnector,/\" $src/core/payments/flows.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/src/core/payments/flows.rs"
    ]
  },
  {
    "id": "gen_062",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"/pub ${previous_connector}: Option<ConnectorTomlConfig>,/a\\n    pub ${payment_gateway}: Option<ConnectorTomlConfig>,\n\" crates/connector_configs/src/connector.rs",
    "prompt": "Add a new field `pub newconnector: Option<ConnectorTomlConfig>,` after `pub existingconnector: Option<ConnectorTomlConfig>,` in `crates/connector_configs/src/connector.rs`.",
    "constraints": "The `sed` command should use the `previous_connector` and `payment_gateway` variables.",
    "expected_output": "sed -i'' -e \"/pub existingconnector: Option<ConnectorTomlConfig>,/a\\n    pub newconnector: Option<ConnectorTomlConfig>,\n\" crates/connector_configs/src/connector.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/connector_configs/src/connector.rs"
    ]
  },
  {
    "id": "gen_063",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"/pub ${previous_connector}: ConnectorParams,/a\\n    pub ${payment_gateway}: ConnectorParams,\n\" crates/hyperswitch_domain_models/src/connector_endpoints.rs",
    "prompt": "Add a new field `pub newconnector: ConnectorParams,` after `pub existingconnector: ConnectorParams,` in `crates/hyperswitch_domain_models/src/connector_endpoints.rs`.",
    "constraints": "The `sed` command should use the `previous_connector` and `payment_gateway` variables.",
    "expected_output": "sed -i'' -e \"/pub existingconnector: ConnectorParams,/a\\n    pub newconnector: ConnectorParams,\n\" crates/hyperswitch_domain_models/src/connector_endpoints.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/hyperswitch_domain_models/src/connector_endpoints.rs"
    ]
  },
  {
    "id": "gen_064",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/mod utils;/mod ${payment_gateway};\\nmod utils;/\" ${tests}/main.rs",
    "prompt": "Add `mod newconnector;` before `mod utils;` in `${tests}/main.rs`.",
    "constraints": "The `sed` command should use the `payment_gateway` variable.",
    "expected_output": "sed -i'' -e \"s/mod utils;/mod newconnector;\\nmod utils;/\" ${tests}/main.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/tests/connectors/main.rs"
    ]
  },
  {
    "id": "gen_065",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/    pub $previous_connector: \\(.*\\)/\\tpub $previous_connector: \\1\\n\\tpub ${payment_gateway}: Option<HeaderKey>,/\" ${test_utils}/connector_auth.rs",
    "prompt": "Add a new field `pub newconnector: Option<HeaderKey>,` after `pub existingconnector: Option<HeaderKey>,` in `${test_utils}/connector_auth.rs`.",
    "constraints": "The `sed` command should use the `previous_connector` and `payment_gateway` variables.",
    "expected_output": "sed -i'' -e \"s/    pub existingconnector: \\(.*\\)/\\tpub existingconnector: \\1\\n\\tpub newconnector: Option<HeaderKey>,/\" ${test_utils}/connector_auth.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/test_utils/src/connector_auth.rs"
    ]
  },
  {
    "id": "gen_066",
    "file_path": "crates/router/src/core/payments/operations/payment_create.rs",
    "task_type": "code_generation",
    "context_code": "#[instrument(skip_all)]\nasync fn add_task_to_process_tracker<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_attempt: &PaymentAttempt,\n    _requeue: bool,\n    _schedule_time: Option<PrimitiveDateTime>,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    Ok(())\n}\n\nasync fn get_connector<'a>(\n    &'a self,\n    _merchant_context: &domain::MerchantContext,\n    state: &SessionState,\n    request: &api::PaymentsRequest,\n    _payment_intent: &storage::PaymentIntent,\n) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n    helpers::get_connector_default(state, request.routing.clone()).await\n}\n\n#[instrument(skip_all)]\nasync fn guard_payment_against_blocklist<'a>(\n    &'a self,\n    _state: &SessionState,\n    _merchant_context: &domain::MerchantContext,\n    _payment_data: &mut PaymentData<F>,\n) -> CustomResult<bool, errors::ApiErrorResponse> {\n    Ok(false)\n}",
    "prompt": "Modify the `guard_payment_against_blocklist` function to return `true` if the payment data's `payment_method_data` is of type `Card` and the card number is present.",
    "constraints": "Ensure the change is backward-compatible and uses existing `PaymentData` fields. Do not introduce new dependencies.",
    "expected_output": "#[instrument(skip_all)]\nasync fn guard_payment_against_blocklist<'a>(\n    &'a self,\n    _state: &SessionState,\n    _merchant_context: &domain::MerchantContext,\n    _payment_data: &mut PaymentData<F>,\n) -> CustomResult<bool, errors::ApiErrorResponse> {\n    if let Some(api::PaymentMethodData::Card(card)) = &_payment_data.payment_method_data {\n        if card.card_number.is_some() {\n            return Ok(true);\n        }\n    }\n    Ok(false)\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "add_task_to_process_tracker",
        "get_connector"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_create.rs",
      "crates/router/src/types/api.rs",
      "crates/api_models/src/payments.rs"
    ]
  },
  {
    "id": "gen_067",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_generation",
    "context_code": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{",
    "prompt": "Add a new struct `PaymentUpdateData` that mirrors `PaymentIntentUpdateFields` but includes an optional `metadata` field of type `Option<serde_json::Value>`.",
    "constraints": "The new struct should be `Debug`, `Clone`, `Serialize`, and `Deserialize`.",
    "expected_output": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\nuse serde::{Deserialize, Serialize};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{\n    types::api,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PaymentUpdateData {\n    pub amount: Option<i64>,\n    pub currency: Option<common_enums::Currency>,\n    pub customer_id: Option<common_utils::id_type::CustomerId>,\n    pub email: Option<Email>,\n    pub phone: Option<masking::Secret<String>>,\n    pub description: Option<String>,\n    pub return_url: Option<String>,\n    pub setup_future_usage: Option<common_enums::FutureUsage>,\n    pub statement_descriptor_name: Option<String>,\n    pub statement_descriptor_suffix: Option<String>,\n    pub metadata: Option<serde_json::Value>,\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/hyperswitch_domain_models/src/payments/payment_intent.rs",
      "crates/api_models/src/payments.rs"
    ]
  },
  {
    "id": "gen_068",
    "file_path": "crates/router/tests/connectors/main.rs",
    "task_type": "code_generation",
    "context_code": "mod helcim;\nmod hipay;\nmod hyperswitch_vault;\nmod hyperwallet;\nmod iatapay;\nmod inespay;\nmod itaubank;\nmod jpmorgan;\nmod juspaythreedsserver;\nmod katapult;\nmod loonio;\nmod mifinity;\nmod mollie;\nmod moneris;\nmod mpgs;\nmod multisafepay;\nmod netcetera;\nmod nexinets;\nmod nexixpay;\nmod nmi;\nmod nomupay;\nmod noon;\nmod nordea;\nmod novalnet;\nmod nuvei;\n#[cfg(feature = \"dummy_connector\")]\nmod opayo;\nmod opennode;\nmod paybox;\n#[cfg(feature = \"dummy_connector\")]\nmod payeezy;\nmod payjustnow;\nmod payload;\nmod payme;\nmod payone;\nmod paypal;\nmod paysafe;\nmod paystack;\nmod paytm;\nmod payu;\nmod peachpayments;\nmod phonepe;\nmod placetopay;\nmod plaid;\nmod powertranz;\n#[cfg(feature = \"dummy_connector\")]\nmod prophetpay;\nmod rapyd;\nmod razorpay;\nmod redsys;\nmod santander;\nmod shift4;\nmod sift;\nmod silverflow;\nmod square;\nmod stax;\nmod stripe;\nmod stripebilling;\nmod taxjar;",
    "prompt": "Add a new connector module named `testconnector` to the list of connector modules.",
    "constraints": "The new module should be added alphabetically.",
    "expected_output": "mod helcim;\nmod hipay;\nmod hyperswitch_vault;\nmod hyperwallet;\nmod iatapay;\nmod inespay;\nmod itaubank;\nmod jpmorgan;\nmod juspaythreedsserver;\nmod katapult;\nmod loonio;\nmod mifinity;\nmod mollie;\nmod moneris;\nmod mpgs;\nmod multisafepay;\nmod netcetera;\nmod nexinets;\nmod nexixpay;\nmod nmi;\nmod nomupay;\nmod noon;\nmod nordea;\nmod novalnet;\nmod nuvei;\n#[cfg(feature = \"dummy_connector\")]\nmod opayo;\nmod opennode;\nmod paybox;\n#[cfg(feature = \"dummy_connector\")]\nmod payeezy;\nmod payjustnow;\nmod payload;\nmod payme;\nmod payone;\nmod paypal;\nmod paysafe;\nmod paystack;\nmod paytm;\nmod payu;\nmod peachpayments;\nmod phonepe;\nmod placetopay;\nmod plaid;\nmod powertranz;\n#[cfg(feature = \"dummy_connector\")]\nmod prophetpay;\nmod rapyd;\nmod razorpay;\nmod redsys;\nmod santander;\nmod shift4;\nmod sift;\nmod silverflow;\nmod square;\nmod stax;\nmod stripe;\nmod stripebilling;\nmod taxjar;\nmod testconnector;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/tests/connectors/main.rs"
    ]
  },
  {
    "id": "gen_069",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "connectors=(aci adyen adyenplatform affirm airwallex amazonpay applepay archipel authipay authorizedotnet bambora bamboraapac bankofamerica barclaycard billwerk bitpay blackhawknetwork bluesnap boku braintree breadpay calida cashtocode celero chargebee checkbook checkout coinbase cryptopay ctp_visa custombilling cybersource datatrans deutschebank digitalvirgo dlocal dummyconnector dwolla ebanx elavon envoy facilitapay finix fiserv fiservemea fiuu flexiti forte getnet gigadat globalpay globepay gocardless gpayments helcim hipay hyperswitch_vault hyperwallet iatapay inespay itaubank jpmorgan juspaythreedsserver katapult klarna loonio mifinity mollie moneris mpgs multisafepay netcetera nexinets nexixpay nomupay noon nordea novalnet nuvei opayo opennode paybox payeezy payjustnow paymentwall paypal payu payone paysafecard paytm payu payzen placetopay plaid powertranz prophetpay rapyd razorpay redsys riskified shift4 signifyd square stax stripe taxjar threedsecureio thunes tillpayments trustpay tsys unified_authentication_service volt wellsfargo wise worldline worldpay xendit zen zsl)",
    "prompt": "Add a new connector named 'testconnector' to the `connectors` array in the `add_connector.sh` script, ensuring it is inserted in alphabetical order.",
    "constraints": "The new connector name should be 'testconnector'. Maintain alphabetical order within the array. The script should correctly identify the previous connector for insertion.",
    "expected_output": "connectors=(aci adyen adyenplatform affirm airwallex amazonpay applepay archipel authipay authorizedotnet bambora bamboraapac bankofamerica barclaycard billwerk bitpay blackhawknetwork bluesnap boku braintree breadpay calida cashtocode celero chargebee checkbook checkout coinbase cryptopay ctp_visa custombilling cybersource datatrans deutschebank digitalvirgo dlocal dummyconnector dwolla ebanx elavon envoy facilitapay finix fiserv fiservemea fiuu flexiti forte getnet gigadat globalpay globepay gocardless gpayments helcim hipay hyperswitch_vault hyperwallet iatapay inespay itaubank jpmorgan juspaythreedsserver katapult klarna loonio mifinity mollie moneris mpgs multisafepay netcetera nexinets nexixpay nomupay noon nordea novalnet nuvei opayo opennode paybox payeezy payjustnow paymentwall paypal payu payone paysafecard paytm payu payzen placetopay plaid powertranz prophetpay rapyd razorpay redsys riskified shift4 signifyd square stax stripe taxjar testconnector threedsecureio thunes tillpayments trustpay tsys unified_authentication_service volt wellsfargo wise worldline worldpay xendit zen zsl)",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "find_prev_connector"
      ]
    },
    "related_files": [
      "scripts/add_connector.sh"
    ]
  },
  {
    "id": "gen_070",
    "file_path": "crates/router/src/core/payment_methods.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn add_payment_method_status_update_task(\n    db: &dyn StorageInterface,\n    payment_method: &domain::PaymentMethod,\n    prev_status: enums::PaymentMethodStatus,\n    curr_status: enums::PaymentMethodStatus,\n    merchant_id: &id_type::MerchantId,\n) -> Result<(), ProcessTrackerError> {\n    let created_at = payment_method.created_at;\n    let schedule_time =\n        created_at.saturating_add(Duration::seconds(consts::DEFAULT_SESSION_EXPIRY));",
    "prompt": "Modify the `add_payment_method_status_update_task` function to include a new parameter `profile_id` of type `&id_type::ProfileId` and pass it to the `PaymentMethodStatusTrackingData` struct.",
    "constraints": "The new parameter `profile_id` must be added to the function signature and used when creating `PaymentMethodStatusTrackingData`.",
    "expected_output": "pub async fn add_payment_method_status_update_task(\n    db: &dyn StorageInterface,\n    payment_method: &domain::PaymentMethod,\n    prev_status: enums::PaymentMethodStatus,\n    curr_status: enums::PaymentMethodStatus,\n    merchant_id: &id_type::MerchantId,\n    profile_id: &id_type::ProfileId,\n) -> Result<(), ProcessTrackerError> {\n    let created_at = payment_method.created_at;\n    let schedule_time =\n        created_at.saturating_add(Duration::seconds(consts::DEFAULT_SESSION_EXPIRY));\n\n    let tracking_data = storage::PaymentMethodStatusTrackingData {\n        payment_method_id: payment_method.get_id().clone(),\n        prev_status,\n        curr_status,\n        merchant_id: merchant_id.to_owned(),\n        profile_id: profile_id.to_owned(),\n    };",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "generate_task_id_for_payment_method_status_update_workflow"
      ]
    },
    "related_files": [
      "crates/router/src/core/payment_methods.rs"
    ]
  },
  {
    "id": "gen_071",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_generation",
    "context_code": "let is_success_rate_based = matches!(\n    payment_attempt.routing_approach,\n    Some(enums::RoutingApproach::SuccessRateExploitation)\n        | Some(enums::RoutingApproach::SuccessRateExploration)\n);\n\nif should_route_to_open_router && is_success_rate_based {\n    routing_helpers::update_gateway_score_helper_with_open_router(\n        &state,\n        &payment_attempt,\n        &profile_id,",
    "prompt": "Add a new condition to the `if` statement to check if `payment_attempt.connector_request_reference_id` is `Some` before calling `update_gateway_score_helper_with_open_router`.",
    "constraints": "The new condition should be `payment_attempt.connector_request_reference_id.is_some()`.",
    "expected_output": "let is_success_rate_based = matches!(\n    payment_attempt.routing_approach,\n    Some(enums::RoutingApproach::SuccessRateExploitation)\n        | Some(enums::RoutingApproach::SuccessRateExploration)\n);\n\nif should_route_to_open_router && is_success_rate_based && payment_attempt.connector_request_reference_id.is_some() {\n    routing_helpers::update_gateway_score_helper_with_open_router(\n        &state,\n        &payment_attempt,\n        &profile_id,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "update_gateway_score_helper_with_open_router"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs"
    ]
  },
  {
    "id": "gen_072",
    "file_path": "crates/router/tests/connectors/main.rs",
    "task_type": "code_generation",
    "context_code": "mod aci;\nmod adyen;\nmod adyenplatform;\nmod affirm;\nmod airwallex;\nmod amazonpay;\nmod authorizedotnet;\nmod bambora;\nmod bamboraapac;\n#[cfg(feature = \"dummy_connector\")]\nmod bankofamerica;\nmod barclaycard;\n#[cfg(feature = \"dummy_connector\")]\nmod billwerk;\nmod bitpay;\nmod blackhawknetwork;\nmod bluesnap;\nmod boku;\nmod breadpay;\nmod calida;\nmod cashtocode;\nmod celero;",
    "prompt": "Add a new module `mod test_connector;` to the list of connector modules in `crates/router/tests/connectors/main.rs`, maintaining alphabetical order.",
    "constraints": "The new module name is `test_connector`. It must be inserted alphabetically.",
    "expected_output": "mod aci;\nmod adyen;\nmod adyenplatform;\nmod affirm;\nmod airwallex;\nmod amazonpay;\nmod authorizedotnet;\nmod bambora;\nmod bamboraapac;\n#[cfg(feature = \"dummy_connector\")]\nmod bankofamerica;\nmod barclaycard;\n#[cfg(feature = \"dummy_connector\")]\nmod billwerk;\nmod bitpay;\nmod blackhawknetwork;\nmod bluesnap;\nmod boku;\nmod breadpay;\nmod calida;\nmod cashtocode;\nmod celero;\nmod test_connector;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/tests/connectors/main.rs"
    ]
  },
  {
    "id": "gen_073",
    "file_path": "crates/router/src/core/payments/operations/payment_status.rs",
    "task_type": "code_generation",
    "context_code": "async fn make_pm_data<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_data: &mut PaymentData<F>,\n    _storage_scheme: enums::MerchantStorageScheme,\n    _merchant_key_store: &domain::MerchantKeyStore,\n    _customer: &Option<domain::Customer>,\n    _business_profile: &domain::Profile,\n    _should_retry_with_pan: bool,\n) -> RouterResult<(\n    PaymentStatusOperation<'a, F, api::PaymentsRequest>,\n    Option<domain::PaymentMethodData>,\n    Option<String>,\n)> {\n    Ok((Box::new(self), None, None))\n}",
    "prompt": "Modify the `make_pm_data` function to return `Some(domain::PaymentMethodData::Card(card_data))` if `_should_retry_with_pan` is true, otherwise return `None` for the payment method data. Assume `card_data` is available from `_payment_data`.",
    "constraints": "The function should conditionally return `Some(domain::PaymentMethodData::Card(card_data))` based on `_should_retry_with_pan`. You can assume `card_data` can be extracted from `_payment_data` for this exercise.",
    "expected_output": "async fn make_pm_data<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_data: &mut PaymentData<F>,\n    _storage_scheme: enums::MerchantStorageScheme,\n    _merchant_key_store: &domain::MerchantKeyStore,\n    _customer: &Option<domain::Customer>,\n    _business_profile: &domain::Profile,\n    _should_retry_with_pan: bool,\n) -> RouterResult<(\n    PaymentStatusOperation<'a, F, api::PaymentsRequest>,\n    Option<domain::PaymentMethodData>,\n    Option<String>,\n)> {\n    let payment_method_data = if _should_retry_with_pan {\n        _payment_data.payment_method_data.clone()\n    } else {\n        None\n    };\n    Ok((Box::new(self), payment_method_data, None))\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "helpers::create_customer_if_not_exist"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_status.rs"
    ]
  },
  {
    "id": "gen_074",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_generation",
    "context_code": "use masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};",
    "prompt": "Add a new struct `CalidaAuthType` that implements `TryFrom<&ConnectorAuthType>` for authentication. It should extract `api_key` from `ConnectorAuthType::HeaderKey`.",
    "constraints": "The struct `CalidaAuthType` should have a field `api_key` of type `Secret<String>`. It must implement `TryFrom<&ConnectorAuthType>` and return `errors::ConnectorError::FailedToObtainAuthType` for unsupported auth types.",
    "expected_output": "use masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};\n\npub struct CalidaAuthType {\n    pub api_key: Secret<String>,\n}\n\nimpl TryFrom<&ConnectorAuthType> for CalidaAuthType {\n    type Error = error_stack::Report<errors::ConnectorError>;\n    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n        match auth_type {\n            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n                api_key: api_key.to_owned(),\n            }),\n            _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n        }\n    }\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ConnectorAuthType"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/calida.rs"
    ]
  },
  {
    "id": "gen_075",
    "file_path": "crates/hyperswitch_connectors/src/connectors.rs",
    "task_type": "code_generation",
    "context_code": "pub mod chargebee;\npub mod checkbook;\npub mod checkout;\npub mod coinbase;\npub mod coingate;\npub mod cryptopay;\npub mod ctp_mastercard;",
    "prompt": "Add a new public module `pub mod custom_connector;` to the list of connector modules in `crates/hyperswitch_connectors/src/connectors.rs`, maintaining alphabetical order.",
    "constraints": "The new module name is `custom_connector`. It must be inserted alphabetically.",
    "expected_output": "pub mod chargebee;\npub mod checkbook;\npub mod checkout;\npub mod coinbase;\npub mod coingate;\npub mod cryptopay;\npub mod ctp_mastercard;\npub mod custom_connector;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_076",
    "file_path": "crates/hyperswitch_connectors/src/default_implementations.rs",
    "task_type": "code_generation",
    "context_code": "    connectors::Novalnet,\n    connectors::Nexinets,\n    connectors::Nexixpay,\n    connectors::Opayo,\n    connectors::Opennode,",
    "prompt": "Add `connectors::NewConnector,` to the `default_imp_for_connector_request_id!` macro in `crates/hyperswitch_connectors/src/default_implementations.rs`, maintaining alphabetical order.",
    "constraints": "The new connector is `NewConnector`. It must be inserted alphabetically within the macro.",
    "expected_output": "    connectors::NewConnector,\n    connectors::Novalnet,\n    connectors::Nexinets,\n    connectors::Nexixpay,\n    connectors::Opayo,\n    connectors::Opennode,",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "default_imp_for_connector_request_id!"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/default_implementations.rs"
    ]
  },
  {
    "id": "gen_077",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_generation",
    "context_code": "use hyperswitch_domain_models::{router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData}, router_flow_types::{access_token_auth::AccessTokenAuth, payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void}, refunds::{Execute, RSync}}, router_request_types::{AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData}, router_response_types::{ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt}, types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData},};",
    "prompt": "Add the necessary `router_flow_types` and `router_request_types` for handling `CompleteAuthorize` and `PreProcessing` payment flows to the `use` statement.",
    "constraints": "Ensure that the new types are correctly imported and follow the existing naming conventions.",
    "expected_output": "use hyperswitch_domain_models::{router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData}, router_flow_types::{access_token_auth::AccessTokenAuth, payments::{Authorize, Capture, CompleteAuthorize, PSync, PaymentMethodToken, PreProcessing, Session, SetupMandate, Void}, refunds::{Execute, RSync}}, router_request_types::{AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData, PaymentsCancelData, PaymentsCaptureData, PaymentsCompleteAuthorizeData, PaymentsPreProcessingData, PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData}, router_response_types::{ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt}, types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData},};",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/calida.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs"
    ]
  },
  {
    "id": "gen_078",
    "file_path": "crates/router/src/core/payments/operations/payment_create.rs",
    "task_type": "code_generation",
    "context_code": "#[instrument(skip_all)]\nasync fn add_task_to_process_tracker<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_attempt: &PaymentAttempt,\n    _requeue: bool,\n    _schedule_time: Option<PrimitiveDateTime>,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    Ok(())\n}",
    "prompt": "Modify the `add_task_to_process_tracker` function to actually add a task to the process tracker. The task should be for a payment attempt and scheduled for a given `_schedule_time`.",
    "constraints": "The function should use the `ProcessTrackerNew` and `insert_process` methods from the `storage` module. The `process_tracker_id` should be generated using `generate_task_id_for_payment_attempt_workflow` and the `tracking_data` should be `PaymentAttemptWorkflowTrackingData`.",
    "expected_output": "#[instrument(skip_all)]\nasync fn add_task_to_process_tracker<'a>(\n    &'a self,\n    state: &'a SessionState,\n    payment_attempt: &PaymentAttempt,\n    requeue: bool,\n    schedule_time: Option<PrimitiveDateTime>,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    let tracking_data = storage::PaymentAttemptWorkflowTrackingData {\n        payment_id: payment_attempt.payment_id.clone(),\n        merchant_id: payment_attempt.merchant_id.clone(),\n        attempt_id: payment_attempt.attempt_id.clone(),\n        business_enc_id: payment_attempt.business_enc_id.clone(),\n        requeue,\n    };\n    let process_tracker_id = storage::generate_task_id_for_payment_attempt_workflow(\n        &payment_attempt.payment_id,\n        &payment_attempt.attempt_id,\n        payment_attempt.business_enc_id.as_ref(),\n    );\n    let process_tracker_entry = storage::ProcessTrackerNew::new(\n        process_tracker_id,\n        \"PAYMENT_ATTEMPT_WORKFLOW\",\n        storage::ProcessTrackerRunner::PaymentAttemptWorkflow,\n        &[\"PAYMENT_ATTEMPT_WORKFLOW\"],\n        tracking_data,\n        None,\n        schedule_time,\n        common_types::consts::API_VERSION,\n    )\n    .change_context(errors::ApiErrorResponse::InternalServerError)\n    .attach_printable(\"Failed to construct PaymentAttemptWorkflow process tracker task\")?;\n\n    state\n        .store\n        .insert_process(process_tracker_entry)\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError)\n        .attach_printable(\"Failed while inserting PaymentAttemptWorkflow reminder to process_tracker\")?;\n    Ok(())\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "storage::ProcessTrackerNew::new",
        "storage::generate_task_id_for_payment_attempt_workflow",
        "StorageInterface::insert_process"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_create.rs",
      "crates/router/src/db/process_tracker.rs",
      "crates/router/src/types/storage.rs"
    ]
  },
  {
    "id": "gen_079",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_generation",
    "context_code": "pub mod api;\npub mod authentication;\npub mod connector_transformers;\npub mod domain;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\npub mod payment_methods;\npub mod pm_auth;\nuse masking::Secret;\npub mod storage;\npub mod transformers;",
    "prompt": "Add a new module `mandate` to the `crates/router/src/types.rs` file.",
    "constraints": "The new module should be named `mandate` and follow the existing module declaration pattern.",
    "expected_output": "pub mod api;\npub mod authentication;\npub mod connector_transformers;\npub mod domain;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\npub mod mandate;\npub mod payment_methods;\npub mod pm_auth;\nuse masking::Secret;\npub mod storage;\npub mod transformers;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs"
    ]
  },
  {
    "id": "gen_080",
    "file_path": "crates/hyperswitch_connectors/src/connectors.rs",
    "task_type": "code_generation",
    "context_code": "pub mod celero;\npub mod chargebee;\npub mod checkbook;\npub mod checkout;\npub mod coinbase;\npub mod coingate;\npub mod cryptopay;",
    "prompt": "Add a new connector module named `clearhaus` to the `crates/hyperswitch_connectors/src/connectors.rs` file, maintaining alphabetical order.",
    "constraints": "The new module should be named `clearhaus` and follow the existing `pub mod` declaration pattern. It must be inserted in alphabetical order.",
    "expected_output": "pub mod celero;\npub mod chargebee;\npub mod checkbook;\npub mod checkout;\npub mod clearhaus;\npub mod coinbase;\npub mod coingate;\npub mod cryptopay;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_081",
    "file_path": "crates/hyperswitch_interfaces/src/api/payments.rs",
    "task_type": "code_generation",
    "context_code": "pub trait PaymentSync:\n    api::ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>\n{\n}",
    "prompt": "Add a new trait `PaymentVoid` for the `Void` flow, similar to `PaymentSync`.",
    "constraints": "The new trait should be named `PaymentVoid` and implement `api::ConnectorIntegration` for the `Void` flow with `PaymentsCancelData` as the request data and `PaymentsResponseData` as the response data.",
    "expected_output": "pub trait PaymentSync:\n    api::ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>\n{\n}\n\npub trait PaymentVoid:\n    api::ConnectorIntegration<Void, PaymentsCancelData, PaymentsResponseData>\n{\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs"
    ]
  },
  {
    "id": "gen_082",
    "file_path": "crates/router/src/core/payments/flows/approve_flow.rs",
    "task_type": "code_generation",
    "context_code": "#[cfg(feature = \"v2\")]\nasync fn construct_router_data<'a>(\n    &self,\n    state: &SessionState,\n    connector_id: &str,\n    merchant_context: &domain::MerchantContext,\n    customer: &Option<domain::Customer>,\n    merchant_connector_account: &domain::MerchantConnectorAccountTypeDetails,\n    merchant_recipient_data: Option<types::MerchantRecipientData>,\n    header_payload: Option<hyperswitch_domain_models::payments::HeaderPayload>,\n) -> RouterResult<types::PaymentsApproveRouterData> {\n    todo!()\n}",
    "prompt": "Implement the `construct_router_data` function for `v2` feature. This function should construct `PaymentsApproveRouterData` using `transformers::construct_payment_router_data`.",
    "constraints": "The implementation should use `transformers::construct_payment_router_data` and pass all the provided arguments. The `payment_method` and `payment_method_type` should be `None`.",
    "expected_output": "#[cfg(feature = \"v2\")]\nasync fn construct_router_data<'a>(\n    &self,\n    state: &SessionState,\n    connector_id: &str,\n    merchant_context: &domain::MerchantContext,\n    customer: &Option<domain::Customer>,\n    merchant_connector_account: &domain::MerchantConnectorAccountTypeDetails,\n    merchant_recipient_data: Option<types::MerchantRecipientData>,\n    header_payload: Option<hyperswitch_domain_models::payments::HeaderPayload>,\n) -> RouterResult<types::PaymentsApproveRouterData> {\n    Box::pin(transformers::construct_payment_router_data::<api::Approve, types::PaymentsApproveData>(\n        state,\n        self.clone(),\n        connector_id,\n        merchant_context,\n        customer,\n        merchant_connector_account,\n        merchant_recipient_data,\n        header_payload,\n        None,\n        None,\n    ))\n    .await\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "transformers::construct_payment_router_data"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/flows/approve_flow.rs",
      "crates/router/src/core/payments/transformers.rs"
    ]
  },
  {
    "id": "gen_083",
    "file_path": "crates/router/src/core/payment_methods.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn add_payment_method_status_update_task(\n    db: &dyn StorageInterface,\n    payment_method: &domain::PaymentMethod,\n    prev_status: enums::PaymentMethodStatus,\n    curr_status: enums::PaymentMethodStatus,\n    merchant_id: &id_type::MerchantId,\n) -> Result<(), ProcessTrackerError> {\n    let created_at = payment_method.created_at;\n    let schedule_time =\n        created_at.saturating_add(Duration::seconds(consts::DEFAULT_SESSION_EXPIRY));",
    "prompt": "Modify the `add_payment_method_status_update_task` function to use `common_utils::date_time::now_plus_duration` for `schedule_time` calculation instead of `saturating_add`.",
    "constraints": "The `schedule_time` should be calculated using `common_utils::date_time::now_plus_duration` with `consts::DEFAULT_SESSION_EXPIRY` as the duration.",
    "expected_output": "pub async fn add_payment_method_status_update_task(\n    db: &dyn StorageInterface,\n    payment_method: &domain::PaymentMethod,\n    prev_status: enums::PaymentMethodStatus,\n    curr_status: enums::PaymentMethodStatus,\n    merchant_id: &id_type::MerchantId,\n) -> Result<(), ProcessTrackerError> {\n    let schedule_time = common_utils::date_time::now_plus_duration(\n        std::time::Duration::from_secs(\n            consts::DEFAULT_SESSION_EXPIRY.try_into().unwrap_or_default()\n        )\n    );",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "common_utils::date_time::now_plus_duration"
      ]
    },
    "related_files": [
      "crates/router/src/core/payment_methods.rs",
      "crates/common_utils/src/date_time.rs"
    ]
  },
  {
    "id": "gen_084",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/^default_imp_for_new_connector_integration_payouts!(/default_imp_for_new_connector_integration_payouts!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_frm!(/default_imp_for_new_connector_integration_frm!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_connector_authentication!(/default_imp_for_new_connector_integration_connector_authentication!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs",
    "prompt": "Modify the `add_connector.sh` script to include a new `sed` command that adds the newly generated connector to the `default_imp_for_new_connector_integration_disputes!` macro in `crates/router/src/core/payments/connector_integration_v2_impls.rs`.",
    "constraints": "The new `sed` command should follow the existing pattern for adding connectors to macros. Ensure the `payment_gateway_camelcase` variable is correctly used.",
    "expected_output": "sed -i'' -e \"s/^default_imp_for_new_connector_integration_payouts!(/default_imp_for_new_connector_integration_payouts!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_frm!(/default_imp_for_new_connector_integration_frm!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_connector_authentication!(/default_imp_for_new_connector_integration_connector_authentication!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_disputes!(/default_imp_for_new_connector_integration_disputes!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/router/src/core/payments/connector_integration_v2_impls.rs"
    ]
  },
  {
    "id": "gen_085",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_generation",
    "context_code": "let should_route_to_open_router =\n    state.conf.open_router.dynamic_routing_enabled;\nlet is_success_rate_based = matches!(\n    payment_attempt.routing_approach,\n    Some(enums::RoutingApproach::SuccessRateExploitation)\n        | Some(enums::RoutingApproach::SuccessRateExploration)\n);\n\nif should_route_to_open_router && is_success_rate_based {",
    "prompt": "Add a new condition to the `if` statement to also check if `payment_attempt.connector_request_reference_id` is `None`. This ensures that the routing logic only proceeds if there isn't an existing connector request reference ID.",
    "constraints": "The new condition should be `payment_attempt.connector_request_reference_id.is_none()` and should be combined with the existing conditions using a logical AND.",
    "expected_output": "let should_route_to_open_router =\n    state.conf.open_router.dynamic_routing_enabled;\nlet is_success_rate_based = matches!(\n    payment_attempt.routing_approach,\n    Some(enums::RoutingApproach::SuccessRateExploitation)\n        | Some(enums::RoutingApproach::SuccessRateExploration)\n);\n\nif should_route_to_open_router && is_success_rate_based && payment_attempt.connector_request_reference_id.is_none() {",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "update_gateway_score_helper_with_open_router"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs"
    ]
  },
  {
    "id": "gen_086",
    "file_path": "crates/router/src/core/payment_methods.rs",
    "task_type": "code_generation",
    "context_code": "pub async fn retrieve_payment_method_with_token(\n    _state: &SessionState,\n    _merchant_key_store: &domain::MerchantKeyStore,\n    _token_data: &storage::PaymentTokenData,\n    _payment_intent: &PaymentIntent,\n    _card_token_data: Option<&domain::CardToken>,\n    _customer: &Option<domain::Customer>,\n    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n    _mandate_id: Option<api_models::payments::MandateIds>,\n    _payment_method_info: Option<domain::PaymentMethod>,\n    _business_profile: &domain::Profile,\n) -> RouterResult<storage::PaymentMethodDataWithId> {\n    todo!()\n}",
    "prompt": "Implement the `retrieve_payment_method_with_token` function for `v2` feature. This function should return a `RouterResult` containing `storage::PaymentMethodDataWithId` or an error. For now, return a placeholder error indicating that the feature is not yet implemented.",
    "constraints": "The function must be `async` and return `RouterResult<storage::PaymentMethodDataWithId>`. Use `Err(report!(errors::ApiErrorResponse::NotImplemented).into())` as a placeholder error.",
    "expected_output": "pub async fn retrieve_payment_method_with_token(\n    _state: &SessionState,\n    _merchant_key_store: &domain::MerchantKeyStore,\n    _token_data: &storage::PaymentTokenData,\n    _payment_intent: &PaymentIntent,\n    _card_token_data: Option<&domain::CardToken>,\n    _customer: &Option<domain::Customer>,\n    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n    _mandate_id: Option<api_models::payments::MandateIds>,\n    _payment_method_info: Option<domain::PaymentMethod>,\n    _business_profile: &domain::Profile,\n) -> RouterResult<storage::PaymentMethodDataWithId> {\n    Err(report!(errors::ApiErrorResponse::NotImplemented).into())\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/core/payment_methods.rs"
    ]
  },
  {
    "id": "gen_087",
    "file_path": "crates/router/src/core/payments/flows.rs",
    "task_type": "code_generation",
    "context_code": "async fn call_preprocessing_through_unified_connector_service<'a>(\n    self,\n    _state: &SessionState,\n    _header_payload: &domain_payments::HeaderPayload,\n    _lineage_ids: &grpc_client::LineageIds,\n    #[cfg(feature = \"v1\")] _merchant_connector_account: helpers::MerchantConnectorAccountType,\n    #[cfg(feature = \"v2\")]\n    _merchant_connector_account: domain::MerchantConnectorAccountTypeDetails,\n    _merchant_context: &domain::MerchantContext,\n    _connector_data: &api::ConnectorData,\n    _unified_connector_service_execution_mode: ExecutionMode,\n    _merchant_order_reference_id: Option<String>,\n) -> RouterResult<(Self, bool)>\nwhere\n    F: Clone,\n    Self: Sized,\n    dyn api::Connector: services::ConnectorIntegration<F, T, types::PaymentsResponseData>,\n{\n    // Default behaviour is to do nothing and continue further\n    Ok((self, true))\n}",
    "prompt": "Modify the `call_preprocessing_through_unified_connector_service` function to accept an additional argument `_payment_method_id: Option<String>` after `_merchant_order_reference_id`.",
    "constraints": "The new argument should be named `_payment_method_id` and be of type `Option<String>`.",
    "expected_output": "async fn call_preprocessing_through_unified_connector_service<'a>(\n    self,\n    _state: &SessionState,\n    _header_payload: &domain_payments::HeaderPayload,\n    _lineage_ids: &grpc_client::LineageIds,\n    #[cfg(feature = \"v1\")] _merchant_connector_account: helpers::MerchantConnectorAccountType,\n    #[cfg(feature = \"v2\")]\n    _merchant_connector_account: domain::MerchantConnectorAccountTypeDetails,\n    _merchant_context: &domain::MerchantContext,\n    _connector_data: &api::ConnectorData,\n    _unified_connector_service_execution_mode: ExecutionMode,\n    _merchant_order_reference_id: Option<String>,\n    _payment_method_id: Option<String>,\n) -> RouterResult<(Self, bool)>\nwhere\n    F: Clone,\n    Self: Sized,\n    dyn api::Connector: services::ConnectorIntegration<F, T, types::PaymentsResponseData>,\n{\n    // Default behaviour is to do nothing and continue further\n    Ok((self, true))\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/core/payments/flows.rs",
      "crates/router/src/core/payments/flows/complete_authorize_flow.rs"
    ]
  },
  {
    "id": "gen_088",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_generation",
    "context_code": "pub mod transformers;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};",
    "prompt": "Add a new `pub mod` declaration for `payouts` in `crates/hyperswitch_connectors/src/connectors/calida.rs`.",
    "constraints": "The new module should be named `payouts` and follow the existing module declaration pattern.",
    "expected_output": "pub mod transformers;\npub mod payouts;\n\nuse std::sync::LazyLock;\n\nuse common_enums::enums;\nuse common_utils::{\n    crypto,\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};\nuse hyperswitch_interfaces::{\n    api::{\n        self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications,\n        ConnectorValidation,\n    },\n    configs::Connectors,\n    consts, errors,\n    events::connector_api_logs::ConnectorEvent,\n    types::{self, Response},\n    webhooks,\n};\nuse masking::{ExposeInterface, Mask, Secret};\nuse ring::hmac;\nuse serde_json::Value;\nuse transformers as calida;\n\nuse crate::{constants::headers, types::ResponseRouterData, utils};",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/calida.rs",
      "crates/hyperswitch_connectors/src/connectors/worldpay.rs"
    ]
  },
  {
    "id": "gen_089",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml\nsed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/api_models/src/connector_enums.rs\nsed -i '' -e \"/\\/\\/ Add Separate authentication support for connectors/{N;s/\\(.*\\)\\n/\\1\\n\\t\\t\\t| Self::${payment_gateway_camelcase}\\n/;}\" crates/api_models/src/connector_enums.rs\nsed -i '' -e \"s/\\(match connector_name {\\)/\\1\\n\\t\\tapi_enums::Connector::${payment_gateway_camelcase} => {${payment_gateway}::transformers::${payment_gateway_camelcase}AuthType::try_from(val)?;Ok(())}/\" $src/core/admin.rs\nsed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/euclid/src/enums.rs",
    "prompt": "Modify the `add_connector.sh` script to include a new `sed` command that adds the new connector's camel case name to the `Connector` enum in `crates/common_enums/src/connector_enums.rs`.",
    "constraints": "The new `sed` command should follow the existing pattern for adding enum variants. The `payment_gateway_camelcase` variable should be used.",
    "expected_output": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml\nsed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/api_models/src/connector_enums.rs\nsed -i '' -e \"/\\/\\/ Add Separate authentication support for connectors/{N;s/\\(.*\\)\\n/\\1\\n\\t\\t\\t| Self::${payment_gateway_camelcase}\\n/;}\" crates/api_models/src/connector_enums.rs\nsed -i '' -e \"s/\\(match connector_name {\\)/\\1\\n\\t\\tapi_enums::Connector::${payment_gateway_camelcase} => {${payment_gateway}::transformers::${payment_gateway_camelcase}AuthType::try_from(val)?;Ok(())}/\" $src/core/admin.rs\nsed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/euclid/src/enums.rs\nsed -i '' -e \"s/\\(pub enum Connector {\\)/\\1\\n\\t${payment_gateway_camelcase},/\" crates/common_enums/src/connector_enums.rs",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "crates/api_models/src/connector_enums.rs",
      "crates/euclid/src/enums.rs",
      "crates/common_enums/src/connector_enums.rs"
    ]
  },
  {
    "id": "gen_090",
    "file_path": "crates/router/src/core/payments/operations/payment_create.rs",
    "task_type": "code_generation",
    "context_code": "#[instrument(skip_all)]\nasync fn add_task_to_process_tracker<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_attempt: &PaymentAttempt,\n    _requeue: bool,\n    _schedule_time: Option<PrimitiveDateTime>,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    Ok(())\n}\n\nasync fn get_connector<'a>(\n    &'a self,\n    _merchant_context: &domain::MerchantContext,\n    state: &SessionState,\n    request: &api::PaymentsRequest,\n    _payment_intent: &storage::PaymentIntent,\n) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n    helpers::get_connector_default(state, request.routing.clone()).await\n}",
    "prompt": "Implement the `guard_payment_against_blocklist` function for `PaymentCreate` operation. This function should always return `Ok(false)` as blocklist checks are handled elsewhere.",
    "constraints": "The function signature must match the `guard_payment_against_blocklist` trait method. It should be `async` and return `CustomResult<bool, errors::ApiErrorResponse>`.",
    "expected_output": "#[instrument(skip_all)]\nasync fn add_task_to_process_tracker<'a>(\n    &'a self,\n    _state: &'a SessionState,\n    _payment_attempt: &PaymentAttempt,\n    _requeue: bool,\n    _schedule_time: Option<PrimitiveDateTime>,\n) -> CustomResult<(), errors::ApiErrorResponse> {\n    Ok(())\n}\n\nasync fn get_connector<'a>(\n    &'a self,\n    _merchant_context: &domain::MerchantContext,\n    state: &SessionState,\n    request: &api::PaymentsRequest,\n    _payment_intent: &storage::PaymentIntent,\n) -> CustomResult<api::ConnectorChoice, errors::ApiErrorResponse> {\n    helpers::get_connector_default(state, request.routing.clone()).await\n}\n\n#[instrument(skip_all)]\nasync fn guard_payment_against_blocklist<'a>(\n    &'a self,\n    _state: &SessionState,\n    _merchant_context: &domain::MerchantContext,\n    _payment_data: &mut PaymentData<F>,\n) -> CustomResult<bool, errors::ApiErrorResponse> {\n    Ok(false)\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "helpers::get_connector_default"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_create.rs",
      "crates/router/src/core/payments/operations.rs"
    ]
  },
  {
    "id": "gen_091",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_generation",
    "context_code": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails, payments::RequestSurchargeDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{",
    "prompt": "Add `PaymentOperation` derive macro to the `PaymentUpdate` struct. This macro is essential for defining the payment operation's behavior.",
    "constraints": "The `PaymentUpdate` struct should be defined and the macro should be placed directly above it.",
    "expected_output": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails, payments::RequestSurchargeDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{};\n\n#[derive(PaymentOperation)]\npub struct PaymentUpdate<F> {\n    phantom_data: PhantomData<F>,\n}",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/router_derive/src/lib.rs"
    ]
  },
  {
    "id": "gen_092",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_generation",
    "context_code": "pub mod api;\npub mod authentication;\npub mod connector_transformers;\npub mod domain;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\npub mod payment_methods;\npub mod pm_auth;\nuse masking::Secret;\npub mod storage;\npub mod transformers;\nuse std::marker::PhantomData;\n\npub use api_models::{enums::Connector, mandates};\n#[cfg(feature = \"payouts\")]\npub use api_models::{enums::PayoutConnectors, payouts as payout_types};\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::CustomResult;\npub use common_utils::{pii, pii::Email, request::RequestContent, types::MinorUnit};\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\n#[cfg(feature = \"frm\")]",
    "prompt": "Add a new public module `verify_connector` to the `crates/router/src/types.rs` file. This module will contain types related to connector verification.",
    "constraints": "The new module should be declared as `pub mod verify_connector;` and placed logically with other module declarations.",
    "expected_output": "pub mod api;\npub mod authentication;\npub mod connector_transformers;\npub mod domain;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\npub mod payment_methods;\npub mod pm_auth;\nuse masking::Secret;\npub mod storage;\npub mod transformers;\npub mod verify_connector;\nuse std::marker::PhantomData;\n\npub use api_models::{enums::Connector, mandates};\n#[cfg(feature = \"payouts\")]\npub use api_models::{enums::PayoutConnectors, payouts as payout_types};\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::CustomResult;\npub use common_utils::{pii, pii::Email, request::RequestContent, types::MinorUnit};\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\n#[cfg(feature = \"frm\")]",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/router/src/types/api.rs"
    ]
  },
  {
    "id": "gen_093",
    "file_path": "crates/router/tests/connectors/main.rs",
    "task_type": "code_generation",
    "context_code": "mod celero;\nmod chargebee;\nmod checkbook;\nmod checkout;\nmod coinbase;\nmod cryptopay;\nmod cybersource;\nmod datatrans;\nmod deutschebank;\nmod dlocal;\n#[cfg(feature = \"dummy_connector\")]\nmod dummyconnector;\nmod dwolla;\nmod ebanx;\nmod elavon;\nmod envoy;\nmod facilitapay;\nmod finix;\nmod fiserv;\nmod fiservemea;\nmod fiuu;\nmod flexiti;\nmod forte;\nmod getnet;\nmod gigadat;\nmod globalpay;\nmod globepay;\nmod gocardless;\nmod gpayments;\nmod helcim;",
    "prompt": "Add a new connector module named `hyperswitch` to the `crates/router/tests/connectors/main.rs` file. This module will contain tests for the Hyperswitch connector.",
    "constraints": "The new module declaration should follow the existing pattern `mod <connector_name>;` and be placed alphabetically.",
    "expected_output": "mod celero;\nmod chargebee;\nmod checkbook;\nmod checkout;\nmod coinbase;\nmod cryptopay;\nmod cybersource;\nmod datatrans;\nmod deutschebank;\nmod dlocal;\n#[cfg(feature = \"dummy_connector\")]\nmod dummyconnector;\nmod dwolla;\nmod ebanx;\nmod elavon;\nmod envoy;\nmod facilitapay;\nmod finix;\nmod fiserv;\nmod fiservemea;\nmod fiuu;\nmod flexiti;\nmod forte;\nmod getnet;\nmod gigadat;\nmod globalpay;\nmod globepay;\nmod gocardless;\nmod gpayments;\nmod helcim;\nmod hyperswitch;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/tests/connectors/main.rs",
      "crates/hyperswitch_connectors/src/connectors.rs"
    ]
  },
  {
    "id": "gen_094",
    "file_path": "crates/router/src/connector/utils.rs",
    "task_type": "code_generation",
    "context_code": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{payments,\n};\nuse base64::Engine;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{",
    "prompt": "Add `time::PrimitiveDateTime` to the imports in `crates/router/src/connector/utils.rs`. This type is often used for date and time handling.",
    "constraints": "The import should be added to the `common_utils` block.",
    "expected_output": "use std::{\n    collections::{HashMap, HashSet},\n    ops::Deref,\n    str::FromStr,\n    sync::LazyLock,\n};\n\nuse api_models::{payments,\n};\nuse base64::Engine;\nuse common_utils::{\n    date_time,\n    errors::{ParsingError, ReportSwitchExt},\n    ext_traits::StringExt,\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};\nuse diesel_models::{enums, types::OrderDetailsWithAmount};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::{",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/connector/utils.rs",
      "crates/common_utils/src/lib.rs"
    ]
  },
  {
    "id": "gen_095",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "prompt": "Modify the `add_connector.sh` script to include a new `payout_base_url` for the newly added connector in all relevant configuration files, similar to how `base_url` is added.",
    "constraints": "The new `payout_base_url` should be added immediately after the `base_url` entry for the connector. The script should handle all specified configuration files.",
    "expected_output": "sed -i'' -e \"s|$previous_connector.base_url \\(.*\\)|$previous_connector.base_url \\1\\n${payment_gateway}.base_url = \\\"$base_url\\\"\\n${payment_gateway}.payout_base_url = \\\"$payout_base_url\\\"|\" config/development.toml config/docker_compose.toml config/config.example.toml loadtest/config/development.toml config/deployments/integration_test.toml config/deployments/production.toml config/deployments/sandbox.toml",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_prev_connector"
      ],
      "related_files": [
        "config/development.toml",
        "config/config.example.toml"
      ]
    }
  },
  {
    "id": "gen_096",
    "file_path": "crates/hyperswitch_connectors/src/connectors/nexixpay.rs",
    "task_type": "code_generation",
    "context_code": "pub struct Nexixpay;\n\nimpl api::ConnectorCommon for Nexixpay {\n    fn id(&self) -> &'static str {\n        \"nexixpay\"\n    }\n\n    fn get_currency_kind(&self) -> hyperswitch_interfaces::api::CurrencyKind {\n        hyperswitch_interfaces::api::CurrencyKind::Minor\n    }\n\n    fn common_get_content_type(&self) -> &'static str {\n        \"application/json\"\n    }\n\n    fn common_get_headers(\n        &self,\n        _router_data: &dyn common_utils::request::RequestContent,\n        _auth: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        Ok(vec![])\n    }\n\n    fn common_get_uri(&self) -> CustomResult<&'static str, errors::ConnectorError> {\n        Ok(\"/\")\n    }\n\n    fn get_error_response(\n        &self,\n        res: Response,\n        event_builder: Option<&mut ConnectorEvent>,\n    ) -> CustomResult<ErrorResponse, errors::ConnectorError> {\n        self.build_error_response(res, event_builder)\n    }\n}",
    "prompt": "Implement the `ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>` trait for the `Nexixpay` connector. This implementation should define how to build the authorization request, handle the response, and specify the URL for authorization.",
    "constraints": "The implementation should use `transformers::NexixpayPaymentsRequest` for the request body and `transformers::NexixpayPaymentsResponse` for the response. The URL should be `/payments/authorize`. Use `common_get_headers` and `common_get_uri` from `ConnectorCommon`.",
    "expected_output": "impl api::ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData> for Nexixpay {\n    fn get_headers(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _auth: &ConnectorAuthType,\n    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n        self.common_get_headers(req, _auth)\n    }\n\n    fn get_content_type(&self) -> &'static str {\n        self.common_get_content_type()\n    }\n\n    fn get_url(\n        &self,\n        _req: &PaymentsAuthorizeRouterData,\n        connector_configs: &Connectors,\n    ) -> CustomResult<String, errors::ConnectorError> {\n        Ok(format!(\"{}{}\", connector_configs.nexixpay.base_url, \"/payments/authorize\"))\n    }\n\n    fn get_request_body(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _call_connector_action: common_utils::core::CallConnectorAction,\n    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n        let connector_req = transformers::NexixpayPaymentsRequest::try_from(req)?;\n        Ok(RequestContent::Json(Box::new(connector_req)))\n    }\n\n    fn build_request(\n        &self,\n        req: &PaymentsAuthorizeRouterData,\n        _auth: &ConnectorAuthType,\n        connector_configs: &Connectors,\n    ) -> CustomResult<Request, errors::ConnectorError> {\n        Ok(self\n            .request_builder(req, _auth, connector_configs)?\n            .method(Method::Post)\n            .build())\n    }\n\n    fn handle_response(\n        &self,\n        res: Response,\n        req: &PaymentsAuthorizeRouterData,\n    ) -> CustomResult<PaymentsAuthorizeRouterData, errors::ConnectorError> {\n        let response: transformers::NexixpayPaymentsResponse = res\n            .response\n            .bytes()\n            .parse_struct(\"NexixpayPaymentsResponse\")\n            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n        Ok(req.response_handler(response, res.status_code))\n    }\n}",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "ConnectorCommon::common_get_headers",
        "ConnectorCommon::common_get_content_type",
        "PaymentsAuthorizeRouterData::response_handler"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/nexixpay/transformers.rs",
        "crates/hyperswitch_interfaces/src/api.rs"
      ]
    }
  },
  {
    "id": "gen_097",
    "file_path": "crates/router/tests/connectors/main.rs",
    "task_type": "code_generation",
    "context_code": "mod opayo;\nmod opennode;\nmod paybox;",
    "prompt": "Add a new connector module named `newconnector` to the `crates/router/tests/connectors/main.rs` file, ensuring it follows the existing alphabetical order.",
    "constraints": "The new module should be added as `mod newconnector;` and maintain the alphabetical sorting of existing modules.",
    "expected_output": "mod opayo;\nmod opennode;\nmod paybox;\nmod newconnector;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": []
    }
  },
  {
    "id": "gen_098",
    "file_path": "crates/hyperswitch_connectors/src/connectors.rs",
    "task_type": "code_generation",
    "context_code": "pub mod nexinets;\npub mod nexixpay;\npub mod nmi;",
    "prompt": "Add a new public module `newconnector` to the `crates/hyperswitch_connectors/src/connectors.rs` file, maintaining alphabetical order.",
    "constraints": "The new module should be `pub mod newconnector;` and be inserted in the correct alphabetical position.",
    "expected_output": "pub mod nexinets;\npub mod nexixpay;\npub mod newconnector;\npub mod nmi;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": []
    }
  },
  {
    "id": "gen_099",
    "file_path": "crates/hyperswitch_interfaces/src/api/payments.rs",
    "task_type": "code_generation",
    "context_code": "pub trait PaymentsPostProcessing:\n    api::ConnectorIntegration<PostProcessing, PaymentsPostProcessingData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentsCreateOrder\npub trait PaymentsCreateOrder:\n    api::ConnectorIntegration<CreateOrder, CreateOrderRequestData, PaymentsResponseData>\n{\n}",
    "prompt": "Define a new trait `PaymentsRefund` for refund operations, similar to existing payment traits. It should integrate with `RefundsData` and `RefundsResponseData`.",
    "constraints": "The trait should be named `PaymentsRefund` and use `api::ConnectorIntegration<Refund, RefundsData, RefundsResponseData>`.",
    "expected_output": "pub trait PaymentsPostProcessing:\n    api::ConnectorIntegration<PostProcessing, PaymentsPostProcessingData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentsCreateOrder\npub trait PaymentsCreateOrder:\n    api::ConnectorIntegration<CreateOrder, CreateOrderRequestData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentsRefund\npub trait PaymentsRefund:\n    api::ConnectorIntegration<Refund, RefundsData, RefundsResponseData>\n{\n}",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ConnectorIntegration"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_request_types.rs",
        "crates/hyperswitch_domain_models/src/router_response_types.rs"
      ]
    }
  },
  {
    "id": "gen_100",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_generation",
    "context_code": "use hyperswitch_interfaces::{api::{self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation}, configs::Connectors, consts, errors, events::connector_api_logs::ConnectorEvent, types::{self, Response}, webhooks};",
    "prompt": "Add `lazy_static` to the imports in `crates/hyperswitch_connectors/src/connectors/calida.rs`.",
    "constraints": "The import should be `use lazy_static::lazy_static;` and placed with other `use` statements.",
    "expected_output": "use hyperswitch_interfaces::{api::{self, ConnectorCommon, ConnectorCommonExt, ConnectorIntegration, ConnectorSpecifications, ConnectorValidation}, configs::Connectors, consts, errors, events::connector_api_logs::ConnectorEvent, types::{self, Response}, webhooks};\nuse lazy_static::lazy_static;",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": []
    }
  },
  {
    "id": "gen_101",
    "file_path": "add_connector.md",
    "task_type": "code_generation",
    "context_code": "```bash\ncurl -o <ConnectorName>-openapi.json <schema-url>\n```",
    "prompt": "Update the `add_connector.md` documentation to include an example of generating Rust types from an OpenAPI specification using `openapi-generator-cli`.",
    "constraints": "The example should show how to generate Rust types into a `temp.rs` file within the connector's `transformers` directory. It should use the `CONNECTOR_NAME` and `SCHEMA_PATH` environment variables.",
    "expected_output": "```bash\ncurl -o <ConnectorName>-openapi.json <schema-url>\n```\n\n```bash\nopenapi-generator-cli generate -i \"$SCHEMA_PATH\" -g rust -o \"crates/hyperswitch_connectors/src/connectors/$CONNECTOR_NAME/transformers\" --additional-properties=packageName=temp\n```",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": []
    }
  },
  {
    "id": "gen_102",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_generation",
    "context_code": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs\nsed -i'' -e \"s/^default_imp_for_fraud_check!(/default_imp_for_fraud_check!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs\nsed -i'' -e \"s/^default_imp_for_connector_authentication!(/default_imp_for_connector_authentication!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs",
    "prompt": "Add a new `sed` command to the `add_connector.sh` script to include the newly added connector in the `default_imp_for_new_connector_integration_payments_session!` macro in `crates/router/src/core/payments/connector_integration_v2_impls.rs`.",
    "constraints": "The new `sed` command should follow the pattern of existing `default_imp_for_new_connector_integration_*` commands and insert `connector::${payment_gateway_camelcase},` into the macro.",
    "expected_output": "sed -i'' -e \"s/^default_imp_for_connector_request_id!(/default_imp_for_connector_request_id!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs\nsed -i'' -e \"s/^default_imp_for_fraud_check!(/default_imp_for_fraud_check!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs\nsed -i'' -e \"s/^default_imp_for_connector_authentication!(/default_imp_for_connector_authentication!(\\n    connectors::${payment_gateway_camelcase},/\" $src/core/payments/flows.rs\nsed -i'' -e \"s/^default_imp_for_new_connector_integration_payments_session!(/default_imp_for_new_connector_integration_payments_session!(\\n    connector::${payment_gateway_camelcase},/\" crates/router/src/core/payments/connector_integration_v2_impls.rs",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": [
        "crates/router/src/core/payments/connector_integration_v2_impls.rs"
      ]
    }
  },
  {
    "id": "exp_001",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_understanding",
    "context_code": "payment_intent = db\n    .find_payment_intent_by_payment_id_merchant_id(\n        key_manager_state,\n        &payment_id,\n        merchant_id,\n        merchant_context.get_merchant_key_store(),\n        storage_scheme,\n    )\n    .await\n    .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;",
    "prompt": "Explain the purpose of the `to_not_found_response()` method in this payment retrieval flow. What error handling pattern does it implement?",
    "constraints": "Describe how this method transforms database errors into API responses.",
    "expected_output": "The `to_not_found_response()` method is an extension trait method that converts storage layer errors into API-level error responses. When the database query fails to find a payment intent, it transforms the `StorageError` into an `ApiErrorResponse::PaymentNotFound` error. This pattern provides a clean separation between storage layer errors and API layer errors, ensuring that internal database errors are properly mapped to user-facing HTTP error responses. The `?` operator then propagates this error up the call stack as a `RouterResult`.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "find_payment_intent_by_payment_id_merchant_id",
        "to_not_found_response"
      ],
      "related_files": [
        "crates/router/src/core/errors.rs",
        "crates/storage_impl/src/payments/payment_intent.rs"
      ]
    }
  },
  {
    "id": "exp_002",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_understanding",
    "context_code": "helpers::validate_payment_status_against_allowed_statuses(\n    payment_intent.status,\n    &[\n        storage_enums::IntentStatus::RequiresPaymentMethod,\n        storage_enums::IntentStatus::RequiresConfirmation,\n    ],\n    \"update\",\n)?;",
    "prompt": "Why does the payment update operation only allow updates when the payment is in `RequiresPaymentMethod` or `RequiresConfirmation` status? What would happen if we tried to update a payment in `Succeeded` status?",
    "constraints": "Explain the state machine logic and why certain statuses are terminal.",
    "expected_output": "The payment update operation restricts updates to `RequiresPaymentMethod` and `RequiresConfirmation` statuses because these are the only states where the payment is still being configured and hasn't been processed yet. Once a payment reaches terminal states like `Succeeded`, `Failed`, or `Cancelled`, it represents a completed transaction that should not be modified to maintain data integrity and audit trails. If you tried to update a payment in `Succeeded` status, the `validate_payment_status_against_allowed_statuses()` function would return an error indicating that the operation is not allowed for the current payment status. This implements a state machine pattern where only specific state transitions are permitted.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "validate_payment_status_against_allowed_statuses",
        "get_trackers"
      ],
      "related_files": [
        "crates/router/src/core/payments/helpers.rs",
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "exp_003",
    "file_path": "crates/router/src/core/payments/flows/authorize_flow.rs",
    "task_type": "code_understanding",
    "context_code": "async fn construct_router_data<'a>(\n    &self,\n    state: &SessionState,\n    connector_id: &str,\n    merchant_context: &domain::MerchantContext,\n    customer: &Option<domain::Customer>,\n    merchant_connector_account: &domain::MerchantConnectorAccountTypeDetails,\n    merchant_recipient_data: Option<types::MerchantRecipientData>,\n    header_payload: Option<domain_payments::HeaderPayload>,\n) -> RouterResult<\n    types::RouterData<\n        api::Authorize,\n        types::PaymentsAuthorizeData,\n        types::PaymentsResponseData,\n    >,\n>",
    "prompt": "Explain the purpose of the `construct_router_data` method in the authorize flow. What is `RouterData` and why does it need to be constructed before calling a connector?",
    "constraints": "Describe the role of generic type parameters and how RouterData standardizes connector communication.",
    "expected_output": "`construct_router_data` is a critical method that transforms payment-specific data (`PaymentConfirmData`) into a standardized `RouterData` structure that connectors can understand. `RouterData<F, T, R>` is a generic container where F is the flow type (Authorize), T is the request data type (PaymentsAuthorizeData), and R is the response data type (PaymentsResponseData). This method aggregates all necessary information including merchant context, customer details, connector account credentials, and payment method data into a single structure. The construction is necessary because different connectors have different API requirements, but RouterData provides a unified interface. The method calls `transformers::construct_payment_router_data_for_authorize()` which handles the complex logic of extracting and formatting data from various sources (payment intent, payment attempt, customer records) into the format expected by connector implementations.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "construct_payment_router_data_for_authorize",
        "get_merchant_recipient_data"
      ],
      "related_files": [
        "crates/router/src/core/payments/transformers.rs",
        "crates/hyperswitch_domain_models/src/router_data.rs",
        "crates/router/src/types.rs"
      ]
    }
  },
  {
    "id": "exp_004",
    "file_path": ".github/CODEOWNERS",
    "task_type": "code_understanding",
    "context_code": "* @juspay/hyperswitch-maintainers\n\nconfig/ @juspay/hyperswitch-framework\ncrates/ @juspay/hyperswitch-framework\n\nscripts/add_connector.sh @juspay/hyperswitch-connector\nconnector-template/ @juspay/hyperswitch-connector\ncrates/hyperswitch_connectors/ @juspay/hyperswitch-connector\n\ncrates/router/src/core/ @juspay/hyperswitch-core",
    "prompt": "Explain the purpose of the CODEOWNERS file and how team ownership is organized in Hyperswitch. What happens when someone creates a PR that modifies connector code?",
    "constraints": "Describe the GitHub CODEOWNERS mechanism and the team structure.",
    "expected_output": "The CODEOWNERS file defines which teams are responsible for reviewing changes to different parts of the Hyperswitch codebase. It follows a hierarchical pattern where more specific paths override general ones. When someone creates a PR that modifies connector code (e.g., files in crates/hyperswitch_connectors/), GitHub automatically requests review from @juspay/hyperswitch-connector team members. The file shows clear separation of concerns: the framework team owns core infrastructure (config/, crates/, routes/), the connector team owns all connector-related code (add_connector.sh, connector-template/, hyperswitch_connectors/), the core team owns business logic (crates/router/src/core/), and the analytics team owns event and analytics modules. The wildcard at the top (*) ensures that @juspay/hyperswitch-maintainers are notified of all changes as a fallback, providing oversight across the entire codebase.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        ".github/workflows/",
        "docs/CONTRIBUTING.md"
      ]
    }
  },
  {
    "id": "exp_005",
    "file_path": "crates/router/src/core/revenue_recovery/types.rs",
    "task_type": "code_understanding",
    "context_code": "Self::Succeeded => {\n    // finish psync task as the payment was a success\n    db.as_scheduler()\n        .finish_process_with_business_status(\n            process_tracker,\n            business_status::PSYNC_WORKFLOW_COMPLETE,\n        )\n        .await?;\n\n    // publish events to kafka\n    if let Err(e) = recovery_incoming_flow::RecoveryPaymentTuple::publish_revenue_recovery_event_to_kafka(\n        state,\n        &recovery_payment_tuple,\n        Some(retry_count+1)\n    )\n    .await{\n        router_env::logger::error!(\n            \"Failed to publish revenue recovery event to kafka: {:?}\",\n            e\n        );\n    };",
    "prompt": "What is the revenue recovery flow doing when a payment succeeds? Why does it update Redis token status and publish to Kafka?",
    "constraints": "Explain the complete workflow including scheduler, Redis, and Kafka interactions.",
    "expected_output": "When a revenue recovery payment succeeds, the system performs several critical operations: (1) It marks the scheduler process as complete with `PSYNC_WORKFLOW_COMPLETE` status, stopping further retry attempts. (2) It publishes a PaymentSucceeded event to Kafka for analytics and audit trails, including the retry count. If Kafka publishing fails, it logs the error but doesn't fail the payment - this ensures payment success isn't blocked by analytics issues. (3) It updates the payment processor token's error code in Redis to None and sets `is_hard_decline` to false, indicating the token is now valid and can be used for future payments. This is crucial because revenue recovery attempts to charge failed payments using stored payment methods - when one succeeds, it proves the payment method is working. (4) It unlocks the connector_customer_id in Redis, allowing other processes to use this customer's payment methods. This entire flow ensures that successful recovery payments update all relevant systems (scheduler, Redis cache, Kafka analytics) to reflect the new payment state and token validity.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "finish_process_with_business_status",
        "publish_revenue_recovery_event_to_kafka",
        "update_payment_processor_token_error_code_from_process_tracker"
      ],
      "related_files": [
        "crates/router/src/workflows/process_tracker.rs",
        "crates/storage_impl/src/redis/revenue_recovery.rs"
      ]
    }
  },
  {
    "id": "exp_006",
    "file_path": "crates/hyperswitch_interfaces/src/api.rs",
    "task_type": "code_understanding",
    "context_code": "pub trait ConnectorSpecifications {\n    /// Details related to payment method supported by the connector\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    /// Whether SDK session token generation is enabled for this connector\n    fn is_sdk_client_token_generation_enabled(&self) -> bool {\n        false\n    }\n\n    /// Payment method types that support SDK session token generation\n    fn supported_payment_method_types_for_sdk_client_token_generation(\n        &self,\n    ) -> Vec<PaymentMethodType> {\n        vec![]\n    }",
    "prompt": "Explain the relationship between `is_sdk_client_token_generation_enabled` and `supported_payment_method_types_for_sdk_client_token_generation`. Why are both methods needed?",
    "constraints": "Describe how these methods work together to control SDK token generation.",
    "expected_output": "The `is_sdk_client_token_generation_enabled` method acts as a global feature flag for the connector, indicating whether it supports SDK client token generation at all. The `supported_payment_method_types_for_sdk_client_token_generation` method provides granular control by specifying which specific payment method types (like ApplePay, GooglePay) support SDK tokens. Both are needed because: (1) The first method provides a quick check to avoid unnecessary processing if the connector doesn't support SDK tokens at all, (2) The second method allows fine-grained control since not all payment methods may support SDK integration even if the connector does. The `validate_sdk_session_token_for_payment_method` method combines both checks to determine if a specific payment method type should use SDK token generation.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "validate_sdk_session_token_for_payment_method",
        "get_supported_payment_methods"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/connector_integration_interface.rs"
      ]
    }
  },
  {
    "id": "exp_007",
    "file_path": "crates/hyperswitch_interfaces/src/api.rs",
    "task_type": "code_understanding",
    "context_code": "pub trait ConnectorSpecifications {\n    /// Details related to payment method supported by the connector\n    fn get_supported_payment_methods(&self) -> Option<&'static SupportedPaymentMethods> {\n        None\n    }\n\n    /// Whether SDK session token generation is enabled for this connector\n    fn is_sdk_client_token_generation_enabled(&self) -> bool {\n        false\n    }\n\n    /// Payment method types that support SDK session token generation\n    fn supported_payment_method_types_for_sdk_client_token_generation(\n        &self,\n    ) -> Vec<PaymentMethodType> {\n        vec![]\n    }",
    "prompt": "Explain the relationship between `is_sdk_client_token_generation_enabled` and `supported_payment_method_types_for_sdk_client_token_generation`. Why are both methods needed?",
    "constraints": "Describe how these methods work together to control SDK token generation.",
    "expected_output": "The `is_sdk_client_token_generation_enabled` method acts as a global feature flag for the connector, indicating whether it supports SDK client token generation at all. The `supported_payment_method_types_for_sdk_client_token_generation` method provides granular control by specifying which specific payment method types (like ApplePay, GooglePay) support SDK tokens. Both are needed because: (1) The first method provides a quick check to avoid unnecessary processing if the connector doesn't support SDK tokens at all, (2) The second method allows fine-grained control since not all payment methods may support SDK integration even if the connector does. The `validate_sdk_session_token_for_payment_method` method combines both checks to determine if a specific payment method type should use SDK token generation.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "validate_sdk_session_token_for_payment_method",
        "get_supported_payment_methods"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/connector_integration_interface.rs"
      ]
    }
  },
  {
    "id": "exp_008",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_understanding",
    "context_code": "# Generate template files for the connector\ncargo install cargo-generate\ncargo generate --path ../../../../connector-template -n $payment_gateway\n\n# Move sub files and test files to appropriate folder\nmv $payment_gateway/mod.rs $payment_gateway.rs\nmkdir -p ../../../router/tests/connectors\nmv \"$payment_gateway/test.rs\" ../../../router/tests/connectors/$payment_gateway.rs",
    "prompt": "Explain what the add_connector.sh script does when creating a new connector. What files does it generate and where does it place them?",
    "constraints": "Describe the complete workflow from template generation to file organization.",
    "expected_output": "The add_connector.sh script automates the creation of a new payment connector in Hyperswitch. It first installs cargo-generate if not already present, then uses it to generate connector files from the connector-template directory. The script generates two main files: a module file (mod.rs) and a test file (test.rs). It then reorganizes these files by renaming mod.rs to {connector_name}.rs in the connectors directory, and moves the test file to crates/router/tests/connectors/{connector_name}.rs. This ensures the connector implementation and its tests are properly separated into their respective locations within the codebase structure.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "cargo-generate",
        "mv"
      ],
      "related_files": [
        "connector-template/",
        "crates/router/tests/connectors/"
      ]
    }
  },
  {
    "id": "exp_009",
    "file_path": "crates/router/src/routes/files.rs",
    "task_type": "code_understanding",
    "context_code": "use actix_multipart::Multipart;\nuse actix_web::{web, HttpRequest, HttpResponse};\nuse api_models::files as file_types;\nuse router_env::{instrument, tracing, Flow};\n\nuse crate::core::api_locking;\npub mod transformers;\n\nuse super::app::AppState;\nuse crate::{\n    core::files::*,\n    services::{api, authentication as auth},\n    types::{api::files, domain},\n};",
    "prompt": "Explain the purpose of the `actix_multipart::Multipart` import in the files module. How does Hyperswitch handle file uploads, and why is multipart form data necessary?",
    "constraints": "Describe the file upload flow and the role of multipart encoding in handling binary file data.",
    "expected_output": "The `actix_multipart::Multipart` import enables handling of multipart/form-data requests, which is the standard HTTP encoding for file uploads. In Hyperswitch, the files module handles uploading evidence documents for disputes, merchant logos, and other binary files. Multipart encoding is necessary because it allows mixing binary file data with text metadata in a single HTTP request - for example, uploading a PDF receipt along with fields like file_name, file_type, and purpose. The `files_create` endpoint (lines 32-119) accepts a `Multipart` stream, which the transformers module parses to extract both the file binary data and associated metadata. This is more efficient than base64-encoding files in JSON, which would increase payload size by ~33%. The multipart stream is processed asynchronously, allowing large files to be uploaded without blocking the server thread.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "files_create",
        "transformers"
      ],
      "related_files": [
        "crates/router/src/routes/files/transformers.rs",
        "crates/router/src/core/files.rs"
      ]
    }
  },
  {
    "id": "exp_010",
    "file_path": "crates/hyperswitch_interfaces/src/lib.rs",
    "task_type": "code_understanding",
    "context_code": "//! Hyperswitch interface\n#![warn(missing_docs, missing_debug_implementations)]\n\npub mod api;\npub mod api_client;\npub mod authentication;\npub mod configs;\npub mod connector_integration_interface;\npub mod connector_integration_v2;\npub mod consts;\npub mod conversion_impls;\npub mod disputes;\npub mod encryption_interface;\npub mod errors;\npub mod events;\npub mod helpers;\npub mod integrity;\npub mod metrics;\npub mod secrets_interface;\npub mod types;\npub mod unified_connector_service;\npub mod webhooks;\npub mod crm;",
    "prompt": "Analyze the module structure of `hyperswitch_interfaces`. What architectural pattern does this crate implement, and why is it separated from the main router crate?",
    "constraints": "Discuss the separation of concerns, trait definitions, and how this enables modularity and testability.",
    "expected_output": "The `hyperswitch_interfaces` crate implements the **Interface Segregation Principle** and **Dependency Inversion Principle** from SOLID design. It defines pure trait interfaces and type definitions without concrete implementations, serving as a contract layer between the router and external integrations (connectors, authentication providers, encryption services, etc.). This separation provides several architectural benefits: (1) **Modularity** - Connectors can be developed independently by implementing these interfaces without depending on the entire router crate, (2) **Testability** - Mock implementations can be created for testing without pulling in heavy dependencies, (3) **Compilation Speed** - Changes to connector implementations don't require recompiling the interface definitions, (4) **Versioning** - The crate supports both v1 and v2 connector integration patterns (connector_integration_interface vs connector_integration_v2), allowing gradual migration, (5) **Clear Boundaries** - The interface layer makes it explicit what contracts external integrations must fulfill. This is why you see modules like `api`, `authentication`, `encryption_interface`, and `webhooks` - they define the 'what' (interfaces) while other crates define the 'how' (implementations).",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "connector_integration_interface",
        "connector_integration_v2"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/connector_integration_interface.rs",
        "crates/hyperswitch_interfaces/src/connector_integration_v2.rs",
        "crates/hyperswitch_connectors/src/connectors.rs"
      ]
    }
  },
  {
    "id": "exp_011",
    "file_path": "crates/hyperswitch_domain_models/src/router_flow_types.rs",
    "task_type": "code_understanding",
    "context_code": "pub mod access_token_auth;\npub mod authentication;\npub mod dispute;\npub mod files;\npub mod fraud_check;\npub mod mandate_revoke;\npub mod payments;\npub mod payouts;\npub mod refunds;\npub mod revenue_recovery;\npub mod subscriptions;\npub mod unified_authentication_service;\npub mod vault;\npub mod webhooks;\npub use access_token_auth::*;\npub use dispute::*;\npub use files::*;\npub use fraud_check::*;\npub use payments::*;\npub use payouts::*;\npub use refunds::*;\npub use revenue_recovery::*;\npub use subscriptions::*;\npub use unified_authentication_service::*;\npub use vault::*;\npub use webhooks::*;",
    "prompt": "What is the purpose of the `router_flow_types` module and why does it re-export all items from its submodules using `pub use`? How does this pattern benefit the API design?",
    "constraints": "Explain the module organization strategy and the benefits of the re-export pattern for API consumers.",
    "expected_output": "The `router_flow_types` module serves as a central registry for all flow type definitions used in the Hyperswitch router. Each submodule (payments, payouts, refunds, etc.) defines flow marker types that represent different operations (Authorize, Capture, Refund, etc.). The `pub use` pattern re-exports all items from these submodules at the parent level, creating a flat namespace. This provides several benefits: (1) API consumers can import flow types directly from `router_flow_types` without needing to know the internal module structure (e.g., `use router_flow_types::Authorize` instead of `use router_flow_types::payments::Authorize`), (2) It creates a single source of truth for all flow types, making them easier to discover, (3) Internal refactoring of submodule organization doesn't break external APIs since the public interface remains stable. This is a common Rust pattern for creating ergonomic APIs while maintaining internal organization.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payments",
        "payouts",
        "refunds"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
        "crates/hyperswitch_domain_models/src/router_flow_types/payouts.rs"
      ]
    }
  },
  {
    "id": "exp_012",
    "file_path": "crates/common_utils/src/lib.rs",
    "task_type": "code_understanding",
    "context_code": "pub mod access_token;\npub mod consts;\npub mod crypto;\npub mod custom_serde;\n#[allow(missing_docs)]\npub mod encryption;\npub mod errors;\n#[allow(missing_docs)]\npub mod events;\npub mod ext_traits;\npub mod fp_utils;\npub mod hashing;\npub mod id_type;\n#[cfg(feature = \"keymanager\")]\npub mod keymanager;\npub mod link_utils;\npub mod macros;\n#[cfg(feature = \"metrics\")]\npub mod metrics;\npub mod new_type;\npub mod payout_method_utils;\npub mod pii;\n#[allow(missing_docs)]\npub mod request;",
    "prompt": "Explain the purpose of the `common_utils` crate and why certain modules like `encryption`, `events`, and `request` have the `#[allow(missing_docs)]` attribute. What does this tell you about the codebase's documentation standards?",
    "constraints": "Describe the role of common utilities in a multi-crate workspace and the implications of allowing missing documentation.",
    "expected_output": "The `common_utils` crate serves as a shared utility library across the Hyperswitch workspace, providing reusable functionality for encryption, hashing, PII handling, metrics, and request handling. The `#[allow(missing_docs)]` attribute on modules like `encryption`, `events`, and `request` indicates that these modules are temporarily exempt from the crate-level `#![warn(missing_docs)]` directive. This suggests that while the codebase enforces documentation standards (as seen in line 1 with `#![warn(missing_docs, missing_debug_implementations)]`), these specific modules are still under development or refactoring and haven't been fully documented yet. The TODO comments next to these attributes confirm this is intentional technical debt that the team plans to address. This is a pragmatic approach that allows shipping functionality while maintaining a goal of comprehensive documentation.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "encryption",
        "events",
        "request"
      ],
      "related_files": [
        "crates/common_utils/src/encryption.rs",
        "crates/common_utils/src/events.rs",
        "crates/common_utils/src/request.rs"
      ]
    }
  },
  {
    "id": "exp_013",
    "file_path": "crates/router/src/core/revenue_recovery/types.rs",
    "task_type": "code_understanding",
    "context_code": "Self::Succeeded => {\n    db.as_scheduler()\n        .finish_process_with_business_status(\n            process_tracker,\n            business_status::PSYNC_WORKFLOW_COMPLETE,\n        )\n        .await?;\n\n    let event_status = common_enums::EventType::PaymentSucceeded;\n\n    if let Err(e) = recovery_incoming_flow::RecoveryPaymentTuple::publish_revenue_recovery_event_to_kafka(\n        state,\n        &recovery_payment_tuple,\n        Some(retry_count+1)\n    ).await {\n        router_env::logger::error!(\"Failed to publish revenue recovery event to kafka: {:?}\", e);\n    };\n\n    let _update_error_code = storage::revenue_recovery_redis_operation::RedisTokenManager::update_payment_processor_token_error_code_from_process_tracker(\n        state,\n        &connector_customer_id,\n        &None,\n        &Some(false),\n        used_token.as_deref(),\n    ).await;",
    "prompt": "What is the revenue recovery flow doing when a payment succeeds? Why does it update Redis token status and publish to Kafka?",
    "constraints": "Explain the complete workflow including scheduler, Redis, and Kafka interactions.",
    "expected_output": "When a revenue recovery payment succeeds, the system performs several critical operations: (1) It marks the scheduler process as complete with `PSYNC_WORKFLOW_COMPLETE` status, stopping further retry attempts. (2) It publishes a PaymentSucceeded event to Kafka for analytics and audit trails, including the retry count. If Kafka publishing fails, it logs the error but doesn't fail the payment - this ensures payment success isn't blocked by analytics issues. (3) It updates the payment processor token's error code in Redis to None and sets `is_hard_decline` to false, indicating the token is now valid and can be used for future payments. This is crucial because revenue recovery attempts to charge failed payments using stored payment methods - when one succeeds, it proves the payment method is working. (4) It unlocks the connector_customer_id in Redis, allowing other processes to use this customer's payment methods. This entire flow ensures that successful recovery payments update all relevant systems (scheduler, Redis cache, Kafka analytics) to reflect the new payment state and token validity.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "finish_process_with_business_status",
        "publish_revenue_recovery_event_to_kafka",
        "update_payment_processor_token_error_code_from_process_tracker",
        "unlock_connector_customer_status"
      ],
      "related_files": [
        "crates/router/src/workflows/process_tracker.rs",
        "crates/storage_impl/src/redis/revenue_recovery.rs",
        "crates/router/src/events/kafka.rs"
      ]
    }
  },
  {
    "id": "exp_014",
    "file_path": "crates/hyperswitch_domain_models/src/payments/payment_attempt.rs",
    "task_type": "code_understanding",
    "context_code": "#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize)]\npub struct ErrorDetails {\n    pub code: String,\n    pub message: String,\n    pub reason: Option<String>,\n    pub unified_code: Option<String>,\n    pub unified_message: Option<String>,\n    pub network_advice_code: Option<String>,\n    pub network_decline_code: Option<String>,\n    pub network_error_message: Option<String>,\n}",
    "prompt": "Explain the difference between `code`/`message` and `unified_code`/`unified_message` in the ErrorDetails struct. Why does Hyperswitch maintain both?",
    "constraints": "Describe the error normalization strategy and its benefits.",
    "expected_output": "The `code` and `message` fields contain the raw error code and message returned directly from the payment connector (e.g., Stripe's 'card_declined', Adyen's 'REFUSED'). The `unified_code` and `unified_message` fields contain Hyperswitch's normalized versions of these errors, mapped through the global status map. Hyperswitch maintains both because: (1) Different connectors use different error codes for the same failure (e.g., insufficient funds might be 'insufficient_funds' in Stripe but 'NOT_ENOUGH_BALANCE' in another processor), (2) Merchants need consistent error codes across all connectors for their error handling logic, (3) The unified codes enable features like intelligent retries - the system can determine if an error is retryable based on the unified code rather than maintaining retry logic for 100+ connectors. The `unified_message` can also be translated to the merchant's requested language. The raw `code` and `message` are preserved for debugging and connector-specific handling when needed.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ErrorDetails",
        "global_status_map_lookup"
      ],
      "related_files": [
        "crates/router/src/core/errors.rs",
        "crates/diesel_models/src/gsm.rs"
      ]
    }
  },
  {
    "id": "exp_015",
    "file_path": "crates/hyperswitch_connectors/src/connectors/braintree.rs",
    "task_type": "code_understanding",
    "context_code": "static BRAINTREE_CONNECTOR_INFO: ConnectorInfo = ConnectorInfo {\n    display_name: \"Braintree\",\n    description: \"Braintree, a PayPal service, offers a full-stack payment platform that simplifies accepting payments in your app or website, supporting various payment methods including credit cards and PayPal.\",\n    connector_type: enums::HyperswitchConnectorCategory::PaymentGateway,\n    integration_status: enums::ConnectorIntegrationStatus::Live,\n};\n\nfn is_sdk_client_token_generation_enabled(&self) -> bool {\n    true\n}\n\nfn supported_payment_method_types_for_sdk_client_token_generation(&self) -> Vec<enums::PaymentMethodType> {\n    vec![\n        enums::PaymentMethodType::ApplePay,\n        enums::PaymentMethodType::GooglePay,\n        enums::PaymentMethodType::Paypal,\n    ]\n}",
    "prompt": "What is the purpose of SDK client token generation in the Braintree connector? Why are only specific payment method types supported?",
    "constraints": "Explain how SDK tokens work and why they're needed for certain payment methods.",
    "expected_output": "SDK client token generation in the Braintree connector enables client-side payment processing for specific payment methods. The `is_sdk_client_token_generation_enabled()` returns true, indicating Braintree supports generating tokens that can be used by client-side SDKs (mobile apps, web browsers) to securely collect payment information. Only ApplePay, GooglePay, and Paypal are supported because these payment methods require client-side SDK integration - they use platform-specific APIs (Apple's PassKit, Google's Pay API, PayPal's SDK) that must run in the client environment. The token allows the client SDK to authenticate with Braintree's services without exposing merchant credentials. Traditional card payments don't need SDK tokens because they can be processed server-side. This pattern reduces PCI compliance scope by keeping sensitive payment data on the client side and in Braintree's systems, never touching the merchant's servers.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "is_sdk_client_token_generation_enabled",
        "supported_payment_method_types_for_sdk_client_token_generation",
        "validate_sdk_session_token_for_payment_method"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/api.rs",
        "crates/router/src/core/payments/flows/session_flow.rs"
      ]
    }
  },
  {
    "id": "exp_016",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_understanding",
    "context_code": "#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;",
    "prompt": "What is the purpose of the `dynamic_routing` feature flag? How does it differ from regular routing?",
    "constraints": "Explain the decision engine integration and caching strategy.",
    "expected_output": "The `dynamic_routing` feature flag enables machine learning-based routing decisions through a decision engine. Regular routing uses static rules defined in the routing algorithm (configured via the admin API), while dynamic routing uses real-time performance data and ML models to select optimal connectors. When enabled, the system calls `enable_decision_engine_dynamic_routing_setup()` to initialize the decision engine integration and `update_decision_engine_dynamic_routing_setup()` to refresh routing configurations. The feature uses Redis caching (via `storage_impl::redis::cache`) to store routing decisions and performance metrics, reducing latency for routing decisions. The decision engine analyzes factors like success rates, processing times, and costs across connectors to dynamically adjust routing preferences. This is particularly useful for high-volume merchants where static routing rules may not adapt quickly enough to changing connector performance patterns.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "enable_decision_engine_dynamic_routing_setup",
        "update_decision_engine_dynamic_routing_setup",
        "decide_route"
      ],
      "related_files": [
        "crates/router/src/core/payments/routing/helpers.rs",
        "crates/storage_impl/src/redis/cache.rs",
        "crates/euclid/src/backend.rs"
      ]
    }
  },
  {
    "id": "exp_017",
    "file_path": "crates/hyperswitch_connectors/src/connectors/payload.rs",
    "task_type": "code_understanding",
    "context_code": "use common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{CustomResult, ReportSwitchExt},\n    ext_traits::{ByteSliceExt, BytesExt},\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, StringMajorUnit, StringMajorUnitForConnector},\n};",
    "prompt": "Why does the payload connector use `StringMajorUnit` instead of `StringMinorUnit`? What does this tell you about the connector's API requirements?",
    "constraints": "Explain the difference between major and minor currency units and when to use each.",
    "expected_output": "The payload connector uses `StringMajorUnit` because its API expects amounts in the major currency unit (e.g., dollars, euros) rather than minor units (cents). This is indicated by the `StringMajorUnitForConnector` type which ensures amounts are converted to decimal strings representing major units. For example, $10.50 would be sent as \"10.50\" instead of \"1050\". Different payment processors have different requirements: some expect integer minor units (Stripe uses cents), others expect decimal major units (some European processors), and some expect string representations of either. The `AmountConvertor` trait handles these conversions safely, ensuring that currency precision is maintained and rounding errors are avoided. When implementing a connector, you must check the processor's API documentation to determine whether they expect major or minor units, and choose the appropriate type accordingly.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "AmountConvertor",
        "convert_amount"
      ],
      "related_files": [
        "crates/common_utils/src/types.rs",
        "crates/hyperswitch_connectors/src/utils.rs"
      ]
    }
  },
  {
    "id": "exp_018",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_understanding",
    "context_code": "#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\nuse hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;",
    "prompt": "What is the purpose of the `dynamic_routing` feature flag? How does it differ from regular routing?",
    "constraints": "Explain the decision engine integration and caching strategy.",
    "expected_output": "The `dynamic_routing` feature flag enables machine learning-based routing decisions through a decision engine. Regular routing uses static rules defined in the routing algorithm (configured via the admin API), while dynamic routing uses real-time performance data and ML models to select optimal connectors. When enabled, the system calls `enable_decision_engine_dynamic_routing_setup()` to initialize the decision engine integration and `update_decision_engine_dynamic_routing_setup()` to refresh routing configurations. The feature uses Redis caching (via `storage_impl::redis::cache`) to store routing decisions and performance metrics, reducing latency for routing decisions. The decision engine analyzes factors like success rates, processing times, and costs across connectors to dynamically adjust routing preferences. This is particularly useful for high-volume merchants where static routing rules may not adapt quickly enough to changing connector performance patterns.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "enable_decision_engine_dynamic_routing_setup",
        "update_decision_engine_dynamic_routing_setup",
        "decide_route"
      ],
      "related_files": [
        "crates/router/src/core/payments/routing/helpers.rs",
        "crates/storage_impl/src/redis/cache.rs",
        "crates/euclid/src/backend.rs"
      ]
    }
  },
  {
    "id": "exp_019",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_understanding",
    "context_code": "let file_new: diesel_models::FileMetadataNew = diesel_models::file::FileMetadataNew {\n    file_id: file_id.clone(),\n    merchant_id: merchant_context.get_merchant_account().get_id().clone(),\n    file_name: create_file_request.file_name.clone(),\n    file_size: create_file_request.file_size,\n    file_type: create_file_request.file_type.to_string(),\n    provider_file_id: None,\n    file_upload_provider: None,\n    available: false,\n    connector_label: None,\n    profile_id: None,\n    merchant_connector_id: None,\n};",
    "prompt": "Why is the file metadata initially created with `available: false` and `provider_file_id: None`? What happens after this initial creation?",
    "constraints": "Explain the two-phase file creation process and when the file becomes available.",
    "expected_output": "The file metadata is initially created with `available: false` and `provider_file_id: None` because file creation is a two-phase process. First, the metadata record is created in the database to reserve the file_id and track the upload attempt. Then, the actual file upload happens asynchronously via `helpers::upload_and_get_provider_provider_file_id_profile_id()`. Only after the upload succeeds does the system update the metadata with `provider_file_id` (the ID from the external storage provider), `file_upload_provider` (which connector/service stored it), and sets `available: true`. This pattern ensures that: (1) The file_id is immediately available to return to the client, (2) Failed uploads don't leave orphaned files in external storage, and (3) The system can track upload attempts and retry failures. The update happens via `diesel_models::file::FileMetadataUpdate::Update` which sets all the provider-specific fields once the upload completes successfully.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "insert_file_metadata",
        "update_file_metadata",
        "upload_and_get_provider_provider_file_id_profile_id"
      ],
      "related_files": [
        "crates/diesel_models/src/file.rs",
        "crates/router/src/core/files/helpers.rs"
      ]
    }
  },
  {
    "id": "exp_020",
    "file_path": "crates/router/src/core/disputes.rs",
    "task_type": "code_understanding",
    "context_code": "use crate::{\n    core::{files, payments, utils as core_utils, webhooks},\n    routes::{app::StorageInterface, metrics::TASKS_ADDED_COUNT, SessionState},\n    services,\n    types::{\n        api::{self, disputes},\n        domain,\n        storage::enums as storage_enums,\n        transformers::{ForeignFrom, ForeignInto},\n        AcceptDisputeRequestData, AcceptDisputeResponse, DefendDisputeRequestData,\n        DefendDisputeResponse, DisputePayload, DisputeSyncData, DisputeSyncResponse,\n        FetchDisputesRequestData, FetchDisputesResponse, SubmitEvidenceRequestData,\n        SubmitEvidenceResponse,\n    },\n    workflows::process_dispute,\n};",
    "prompt": "What is the relationship between the disputes module and the files module? Why does dispute handling need file operations?",
    "constraints": "Explain how evidence submission works in the dispute flow.",
    "expected_output": "The disputes module imports the `files` module because dispute evidence submission requires uploading supporting documents (receipts, shipping confirmations, etc.) to payment processors. When merchants defend against chargebacks, they need to submit evidence files through the `SubmitEvidenceRequestData` flow. The files module handles uploading these documents to external storage (S3, connector-specific storage) and managing file metadata. The dispute flow calls `files::upload_and_get_provider_provider_file_id_profile_id()` to store evidence files, then includes the file references in the dispute defense request sent to the payment processor. This integration ensures that evidence files are properly stored and referenced when communicating with connectors about dispute resolution.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "SubmitEvidenceRequestData",
        "upload_and_get_provider_provider_file_id_profile_id"
      ],
      "related_files": [
        "crates/router/src/core/files.rs",
        "crates/router/src/core/files/helpers.rs",
        "crates/api_models/src/disputes.rs"
      ]
    }
  },
  {
    "id": "exp_021",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_understanding",
    "context_code": "static CALIDA_SUPPORTED_PAYMENT_METHODS: LazyLock<SupportedPaymentMethods> = LazyLock::new(|| {\n    let supported_capture_methods = vec![enums::CaptureMethod::Automatic];\n\n    let mut santander_supported_payment_methods = SupportedPaymentMethods::new();\n\n    santander_supported_payment_methods.add(\n        enums::PaymentMethod::Wallet,\n        enums::PaymentMethodType::Bluecode,\n        PaymentMethodDetails {\n            mandates: enums::FeatureStatus::NotSupported,\n            refunds: enums::FeatureStatus::NotSupported,\n            supported_capture_methods,\n            specific_features: None,\n        },\n    );\n\n    santander_supported_payment_methods\n});",
    "prompt": "Why does Calida only support Automatic capture method and not Manual? What are the implications for merchants using this connector?",
    "constraints": "Explain the difference between automatic and manual capture and when each is used.",
    "expected_output": "Calida only supports Automatic capture, meaning payments are immediately captured (funds are transferred) when authorized. Manual capture allows merchants to authorize a payment first, then capture it later (useful for scenarios like shipping confirmation or fraud review). The implications for merchants using Calida: (1) They cannot hold authorizations and capture later - every authorization immediately charges the customer. (2) They cannot partially capture amounts (e.g., authorize $100 but only capture $80 if one item is out of stock). (3) They cannot cancel authorizations before capture. (4) This is typical for wallet-based payment methods like Bluecode, which often don't support the two-step auth/capture flow that credit cards do. Merchants needing manual capture capabilities would need to use a different connector or payment method. The `supported_capture_methods` vector being limited to `Automatic` ensures Hyperswitch won't attempt manual capture operations with Calida, preventing API errors.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "SupportedPaymentMethods::add",
        "validate_capture_method"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_response_types.rs",
        "crates/router/src/core/payments/flows/capture_flow.rs"
      ]
    }
  },
  {
    "id": "exp_022",
    "file_path": "crates/storage_impl/src/payments/payment_attempt.rs",
    "task_type": "code_understanding",
    "context_code": "use diesel_models::{\n    enums::{\n        MandateAmountData as DieselMandateAmountData, MandateDataType as DieselMandateType,\n        MandateDetails as DieselMandateDetails, MerchantStorageScheme,\n    },\n    kv,\n    payment_attempt::PaymentAttempt as DieselPaymentAttempt,\n    reverse_lookup::{ReverseLookup, ReverseLookupNew},\n};",
    "prompt": "What is the purpose of the `reverse_lookup` types imported here? How do they relate to payment attempt storage?",
    "constraints": "Explain the reverse lookup pattern and why it's needed for payment attempts.",
    "expected_output": "The `reverse_lookup` types (`ReverseLookup` and `ReverseLookupNew`) implement a bidirectional lookup pattern for payment attempts. In Hyperswitch, payment attempts can be queried by multiple identifiers - the internal `attempt_id`, the `payment_id`, or the `connector_payment_id` (the ID returned by the payment processor). The reverse lookup table maintains mappings between these different identifiers, allowing efficient queries regardless of which ID the caller has. For example, when a webhook arrives from a connector with only the `connector_payment_id`, the system can use reverse lookup to find the corresponding internal `attempt_id` and `payment_id`. This is particularly important in v1 where the system needs to support lookups by connector transaction IDs for webhook processing and payment status synchronization.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "insert_payment_attempt",
        "find_payment_attempt_by_connector_transaction_id"
      ],
      "related_files": [
        "crates/diesel_models/src/reverse_lookup.rs",
        "crates/hyperswitch_domain_models/src/payments/payment_attempt.rs"
      ]
    }
  },
  {
    "id": "exp_023",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    payment_method_data::{\n        self, BankRedirectData, Card, CardRedirectData, GiftCardData, GooglePayWalletData,\n        PayLaterData, PaymentMethodData, VoucherData, WalletData,\n    },\n    router_data::{\n        AdditionalPaymentMethodConnectorResponse, ConnectorAuthType, ConnectorResponseData,\n        ExtendedAuthorizationResponseData, PaymentMethodToken, RouterData,\n    },\n};",
    "prompt": "Why does the Stripe transformer import so many different payment method data types? How does this relate to Stripe's support for multiple payment methods?",
    "constraints": "Explain the relationship between Hyperswitch's unified payment method data model and connector-specific transformations.",
    "expected_output": "The Stripe transformer imports multiple payment method data types because Stripe supports a wide variety of payment methods beyond just cards - including bank redirects (iDEAL, Giropay), wallets (Apple Pay, Google Pay), pay-later services (Klarna, Affirm), vouchers (Boleto), and gift cards. Hyperswitch uses a unified `PaymentMethodData` enum that can represent any of these payment methods in a standardized way. The transformer's job is to convert from Hyperswitch's unified representation into Stripe's specific API format. Each payment method type requires different fields and formatting in Stripe's API, so the transformer needs access to all these types to properly construct Stripe-specific request payloads. This design allows Hyperswitch to support 100+ connectors with different payment method requirements while maintaining a single, consistent internal data model.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "try_from",
        "PaymentMethodData"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/payment_method_data.rs",
        "crates/api_models/src/payments.rs"
      ]
    }
  },
  {
    "id": "exp_024",
    "file_path": "crates/hyperswitch_connectors/src/utils.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    address::{Address, AddressDetails, PhoneDetails},\n    mandates,\n    network_tokenization::NetworkTokenNumber,\n    payment_method_data::{\n        self, Card, CardDetailsForNetworkTransactionId, GooglePayPaymentMethodInfo,\n        PaymentMethodData,\n    },\n    router_data::{\n        ErrorResponse, L2L3Data, PaymentMethodToken, RecurringMandatePaymentData,\n        RouterData as ConnectorRouterData,\n    },\n};",
    "prompt": "Explain the purpose of the `utils.rs` file in the hyperswitch_connectors crate. What types of utilities does it provide based on the imports shown?",
    "constraints": "Describe the role of connector utilities and how they support connector implementations.",
    "expected_output": "The `utils.rs` file in the hyperswitch_connectors crate provides shared utility functions and helper methods used across all connector implementations. Based on the imports, it provides utilities for: (1) Address handling - working with billing/shipping addresses and phone details, (2) Payment method data processing - handling cards, network tokenization, and various payment methods like GooglePay, (3) Router data manipulation - working with the RouterData type that carries request/response data between Hyperswitch and connectors, (4) Mandate handling - processing recurring payment mandates, (5) Error handling - standardized error responses across connectors. These utilities ensure consistent data transformation, validation, and formatting across all 100+ payment connector integrations, reducing code duplication and maintaining uniform behavior.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "RouterData",
        "PaymentMethodData"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_data.rs",
        "crates/hyperswitch_domain_models/src/payment_method_data.rs"
      ]
    }
  },
  {
    "id": "exp_025",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_understanding",
    "context_code": "pub async fn retrieve_file_from_connector(\n    state: &SessionState,\n    file_metadata: diesel_models::file::FileMetadata,\n    dispute_id: Option<String>,\n    merchant_context: &domain::MerchantContext,\n) -> CustomResult<Vec<u8>, errors::ApiErrorResponse> {\n    let connector = &types::Connector::foreign_try_from(\n        file_metadata\n            .file_upload_provider\n            .ok_or(errors::ApiErrorResponse::InternalServerError)\n            .attach_printable(\"Missing file upload provider\")?,\n    )?\n    .to_string();",
    "prompt": "Why does the retrieve_file_from_connector function accept an optional dispute_id parameter? How does this relate to the dispute evidence submission workflow?",
    "constraints": "Explain the connection between file retrieval and dispute handling.",
    "expected_output": "The `dispute_id` parameter is optional because files in Hyperswitch can be used for multiple purposes, not just dispute evidence. When dispute_id is Some, it indicates the file is being retrieved as part of a dispute evidence submission workflow - merchants upload supporting documents (receipts, shipping confirmations, etc.) to defend against chargebacks. The function uses this dispute_id to fetch the dispute record from the database (lines 142-156), which provides additional context needed by some connectors when retrieving dispute-related files. When dispute_id is None, the file is being retrieved for other purposes like merchant logos or general document storage. This design allows the same file retrieval infrastructure to serve both dispute-specific and general file operations, with the dispute context being optionally provided when needed for proper connector API calls.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "find_dispute_by_merchant_id_dispute_id",
        "construct_retrieve_file_router_data"
      ],
      "related_files": [
        "crates/router/src/core/disputes.rs",
        "crates/diesel_models/src/dispute.rs"
      ]
    }
  },
  {
    "id": "exp_026",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_understanding",
    "context_code": "#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse helpers::{\n    enable_decision_engine_dynamic_routing_setup, update_decision_engine_dynamic_routing_setup,\n};\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;",
    "prompt": "What is the relationship between the v1 feature flag and dynamic_routing feature flag? Why are they both required together in these conditional compilation directives?",
    "constraints": "Explain the feature flag architecture and version-specific functionality.",
    "expected_output": "The `v1` and `dynamic_routing` feature flags are combined using `all()` because dynamic routing is a v1-specific feature that hasn't been implemented for v2 yet. The v1 flag indicates the codebase is compiled with version 1 API support, while dynamic_routing enables machine learning-based routing decisions. They must both be enabled together because: (1) The dynamic routing implementation uses v1-specific data structures and APIs that don't exist in v2, (2) The decision engine integration and Redis caching strategy were designed for the v1 architecture, (3) V2 uses a different routing approach that doesn't yet support the ML-based decision engine. This conditional compilation ensures that dynamic routing code is only included when both the v1 API is enabled AND the merchant has opted into dynamic routing features, preventing compilation errors and runtime issues when running v2-only or when dynamic routing is disabled.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "enable_decision_engine_dynamic_routing_setup",
        "update_decision_engine_dynamic_routing_setup"
      ],
      "related_files": [
        "crates/router/src/core/payments/routing/helpers.rs",
        "crates/storage_impl/src/redis/cache.rs"
      ]
    }
  },
  {
    "id": "exp_027",
    "file_path": "docs/architecture.md",
    "task_type": "code_understanding",
    "context_code": "## Scheduler\n\nSuppose a scenario where a customer has saved their card details in your application, but for security reasons, you want to remove the saved card information after a certain period.\nTo automate this process, Scheduler comes into picture. It schedules a task with a specific time for execution and stores it in the database. When the scheduled time arrives, the job associated with the task starts executing, here in this case, allowing the saved card details to be deleted automatically.",
    "prompt": "Explain the architecture of the Scheduler service and how it differs from the Router service. What are the Producer and Consumer components?",
    "constraints": "Describe the complete workflow from task scheduling to execution.",
    "expected_output": "The Scheduler is a separate service from the Router that handles deferred task execution. It consists of two components: (1) Producer (Job Scheduler) - monitors the database for tasks whose scheduled time has arrived, batches them together, and pushes these batches into a Redis queue. (2) Consumer (Job Executor) - retrieves task batches from the Redis queue and executes them according to their processing logic. The workflow is: Router inserts a task into the database with a scheduled time → Producer polls the database, finds tasks ready for execution → Producer batches tasks and pushes to Redis queue → Consumer pulls batches from Redis → Consumer executes each task. This architecture separates concerns: Router handles real-time API requests while Scheduler handles time-delayed operations like card deletion, API key expiration notifications, and payment status syncs. The Redis queue provides buffering and allows horizontal scaling of consumers for high-volume task processing.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": [
        "crates/scheduler/",
        "crates/router/"
      ]
    }
  },
  {
    "id": "exp_028",
    "file_path": ".github/CODEOWNERS",
    "task_type": "code_understanding",
    "context_code": "* @juspay/hyperswitch-maintainers\n\nconfig/ @juspay/hyperswitch-framework\ncrates/ @juspay/hyperswitch-framework\n\nscripts/add_connector.sh @juspay/hyperswitch-connector\nconnector-template/ @juspay/hyperswitch-connector\ncrates/hyperswitch_connectors/ @juspay/hyperswitch-connector\n\ncrates/router/src/core/ @juspay/hyperswitch-core",
    "prompt": "How does the CODEOWNERS file implement a hierarchical ownership model? What happens when a file matches multiple patterns?",
    "constraints": "Explain GitHub's CODEOWNERS precedence rules and team structure.",
    "expected_output": "The CODEOWNERS file implements hierarchical ownership through pattern specificity - more specific paths override general ones. The wildcard `*` at the top assigns @juspay/hyperswitch-maintainers as default owners for everything. Then more specific patterns override this: `crates/` assigns @juspay/hyperswitch-framework, but `crates/hyperswitch_connectors/` further overrides to @juspay/hyperswitch-connector. When a file matches multiple patterns, GitHub uses the last (most specific) matching pattern. For example, a file in `crates/hyperswitch_connectors/src/connectors/stripe.rs` matches three patterns: (1) `*` → maintainers, (2) `crates/` → framework team, (3) `crates/hyperswitch_connectors/` → connector team. The connector team wins because it's the most specific match. This creates clear ownership boundaries: framework team owns infrastructure, connector team owns payment integrations, core team owns business logic, while maintainers have oversight of everything as a fallback.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        ".github/workflows/"
      ]
    }
  },
  {
    "id": "exp_029",
    "file_path": "crates/hyperswitch_connectors/src/connectors/tesouro.rs",
    "task_type": "code_understanding",
    "context_code": "use common_utils::{\n    errors::CustomResult,\n    ext_traits::BytesExt,\n    request::{Method, Request, RequestBuilder, RequestContent},\n    types::{AmountConvertor, FloatMajorUnit, FloatMajorUnitForConnector},\n};",
    "prompt": "Why does the Tesouro connector use FloatMajorUnit instead of StringMinorUnit or StringMajorUnit? What does this tell you about Tesouro's API requirements?",
    "constraints": "Explain the different amount representation types and when each is used.",
    "expected_output": "The Tesouro connector uses `FloatMajorUnit` because Tesouro's API expects amounts as floating-point numbers in the major currency unit (e.g., 10.50 for ten dollars and fifty cents). This differs from other connectors: `StringMinorUnit` represents amounts as string integers in minor units (\"1050\" for $10.50), `StringMajorUnit` represents amounts as string decimals (\"10.50\"), and `FloatMajorUnit` represents amounts as actual float numbers (10.50). The choice depends on the payment processor's API specification. Tesouro requires float numbers, likely because their API was designed with languages that handle floats natively. The `AmountConvertor` trait handles the conversion from Hyperswitch's internal `MinorUnit` representation to Tesouro's required `FloatMajorUnit` format, ensuring proper decimal precision and avoiding rounding errors during currency conversion. This type-safe approach prevents amount mismatches that could cause payment failures or incorrect charges.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "AmountConvertor",
        "convert_amount"
      ],
      "related_files": [
        "crates/common_utils/src/types.rs",
        "crates/hyperswitch_connectors/src/utils.rs"
      ]
    }
  },
  {
    "id": "exp_030",
    "file_path": "crates/hyperswitch_connectors/src/default_implementations.rs",
    "task_type": "code_understanding",
    "context_code": "#[cfg(feature = \"frm\")]\nuse hyperswitch_domain_models::{\n    router_flow_types::fraud_check::{Checkout, Fulfillment, RecordReturn, Sale, Transaction},\n};",
    "prompt": "What is the 'frm' feature flag and what do the fraud_check flow types (Checkout, Fulfillment, RecordReturn, Sale, Transaction) represent?",
    "constraints": "Explain fraud and risk management integration in Hyperswitch.",
    "expected_output": "The 'frm' feature flag enables Fraud and Risk Management functionality in Hyperswitch. When enabled, it allows integration with fraud detection services to assess transaction risk before processing payments. The fraud_check flow types represent different stages of the fraud assessment lifecycle: (1) `Checkout` - pre-authorization fraud check when customer initiates payment, (2) `Sale` - fraud assessment for completed sale transactions, (3) `Transaction` - general transaction-level fraud analysis, (4) `Fulfillment` - fraud check after order fulfillment to detect post-purchase fraud, (5) `RecordReturn` - fraud assessment for return/refund transactions to detect return fraud. Each flow type corresponds to a specific `ConnectorIntegration` implementation that connectors can implement to support fraud checks at that stage. This modular approach allows merchants to configure fraud checks at different points in the payment lifecycle based on their risk tolerance and the capabilities of their fraud detection provider.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ConnectorIntegration"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_flow_types/fraud_check.rs"
      ]
    }
  },
  {
    "id": "exp_031",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_understanding",
    "context_code": "pub async fn files_create_core(\n    state: SessionState,\n    merchant_context: domain::MerchantContext,\n    create_file_request: api::CreateFileRequest,\n) -> RouterResponse<files::CreateFileResponse> {\n    helpers::validate_file_upload(\n        &state,\n        merchant_context.clone(),\n        create_file_request.clone(),\n    )\n    .await?;\n    let file_id = common_utils::generate_id(consts::ID_LENGTH, \"file\");\n    let file_key = format!(\n        \"{}/{}\",\n        merchant_context\n            .get_merchant_account()\n            .get_id()\n            .get_string_repr(),\n        file_id\n    );",
    "prompt": "Why does the file_key combine the merchant_id and file_id with a forward slash? What purpose does this hierarchical structure serve in file storage?",
    "constraints": "Explain the multi-tenancy implications and file organization strategy.",
    "expected_output": "The file_key combines merchant_id and file_id with a forward slash to create a hierarchical namespace for file storage, ensuring multi-tenant isolation. This structure serves several purposes: (1) **Tenant Isolation** - Files from different merchants are logically separated, preventing accidental access or conflicts. (2) **Storage Organization** - When using object storage like S3, the forward slash creates a virtual folder structure (merchant_id/file_id), making it easier to manage, list, and delete files per merchant. (3) **Access Control** - The merchant_id prefix enables bucket policies or IAM rules to restrict access based on the merchant context. (4) **Cleanup & Maintenance** - When a merchant account is deleted, all their files can be efficiently removed by deleting the entire merchant_id prefix. This pattern is consistent with Hyperswitch's multi-tenant architecture where all resources are scoped to merchant_id for data isolation.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "generate_id",
        "get_merchant_account"
      ],
      "related_files": [
        "crates/router/src/core/files/helpers.rs",
        "crates/hyperswitch_domain_models/src/merchant_account.rs"
      ]
    }
  },
  {
    "id": "exp_032",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_understanding",
    "context_code": "match provider {\n    diesel_models::enums::FileUploadProvider::Router => state\n        .file_storage_client\n        .delete_file(&provider_file_id)\n        .await\n        .change_context(errors::ApiErrorResponse::InternalServerError),\n    _ => Err(errors::ApiErrorResponse::FileProviderNotSupported {\n        message: \"Not Supported because provider is not Router\".to_string(),\n    }\n    .into()),\n}",
    "prompt": "Why does the file deletion logic only support the Router provider and not other providers? What are the implications for files stored with external connectors?",
    "constraints": "Explain the provider architecture and deletion limitations.",
    "expected_output": "The file deletion logic only supports the Router provider because files stored with external connectors (like Stripe, Cybersource) are managed by those third-party systems, not by Hyperswitch. The implications are: (1) **Ownership** - Files uploaded to connectors for dispute evidence are owned and managed by the connector's infrastructure. Hyperswitch doesn't have direct delete permissions on those files. (2) **Lifecycle Management** - External connector files follow the connector's retention policies and lifecycle rules, which Hyperswitch cannot control. (3) **Metadata Only** - For connector-stored files, Hyperswitch only maintains metadata (file_id, provider_file_id) in its database, not the actual file content. Deleting the metadata doesn't delete the actual file from the connector. (4) **Router Provider** - Files with FileUploadProvider::Router are stored in Hyperswitch's own file_storage_client (typically S3 or similar), giving full control over deletion. This design reflects the separation of concerns between Hyperswitch-managed storage and connector-managed storage.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "delete_file",
        "FileUploadProvider"
      ],
      "related_files": [
        "crates/diesel_models/src/enums.rs",
        "crates/router/src/services/file_storage.rs"
      ]
    }
  },
  {
    "id": "exp_033",
    "file_path": "crates/router/src/core/files/helpers.rs",
    "task_type": "code_understanding",
    "context_code": "let connector_integration: services::BoxedFilesConnectorIntegrationInterface<\n    api::Retrieve,\n    types::RetrieveFileRequestData,\n    types::RetrieveFileResponse,\n> = connector_data.connector.get_connector_integration();\nlet router_data = utils::construct_retrieve_file_router_data(\n    state,\n    merchant_context,\n    &file_metadata,\n    dispute,\n    connector,\n)\n.await",
    "prompt": "Explain the purpose of BoxedFilesConnectorIntegrationInterface and why it uses type parameters for Retrieve, RetrieveFileRequestData, and RetrieveFileResponse.",
    "constraints": "Describe the generic connector integration pattern and type safety benefits.",
    "expected_output": "BoxedFilesConnectorIntegrationInterface is a type alias for a boxed trait object that implements the ConnectorIntegration trait with specific type parameters for file retrieval operations. The type parameters serve specific purposes: (1) **api::Retrieve** - The flow type that identifies this as a file retrieval operation, distinguishing it from Upload or other file operations. (2) **types::RetrieveFileRequestData** - The request type containing data needed to retrieve a file (file_id, dispute context, etc.), ensuring type-safe request construction. (3) **types::RetrieveFileResponse** - The response type containing the retrieved file data, ensuring type-safe response handling. This generic pattern provides: (a) **Compile-time Safety** - The compiler ensures that only compatible request/response types are used with the Retrieve flow. (b) **Connector Flexibility** - Different connectors can implement the same interface while handling their specific API requirements internally. (c) **Code Reuse** - The same execute_connector_processing_step function works for all file operations by being generic over the flow and data types. (d) **Type Documentation** - The type signature clearly documents what data flows through the system.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "get_connector_integration",
        "execute_connector_processing_step"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/connector_integration_interface.rs",
        "crates/router/src/services/api.rs"
      ]
    }
  },
  {
    "id": "exp_034",
    "file_path": "crates/common_utils/src/id_type/global_id/payment.rs",
    "task_type": "code_understanding",
    "context_code": "impl GlobalAttemptId {\n    pub fn get_psync_revenue_recovery_id(\n        &self,\n        task: &str,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\"{runner}_{task}_{}\", self.get_string_repr())\n    }\n}",
    "prompt": "What is the purpose of get_psync_revenue_recovery_id and why does it combine runner, task, and attempt_id in a specific format?",
    "constraints": "Explain the revenue recovery workflow and process tracking system.",
    "expected_output": "The get_psync_revenue_recovery_id method generates unique identifiers for revenue recovery payment sync (psync) tasks in the process tracker system. The format combines three components for specific reasons: (1) **runner** (ProcessTrackerRunner enum) - Identifies which background service is executing the task (e.g., scheduler, drainer), enabling task distribution and preventing duplicate execution across multiple workers. (2) **task** - Identifies the specific workflow step (e.g., 'psync', 'retry'), allowing the system to track different stages of revenue recovery independently. (3) **attempt_id** - Links the task to a specific payment attempt, ensuring tasks are scoped to individual transactions. This format enables: (a) **Idempotency** - The same task for the same attempt always generates the same ID, preventing duplicate task creation. (b) **Task Routing** - The runner prefix allows the scheduler to route tasks to appropriate workers. (c) **Debugging** - The structured format makes it easy to identify which payment attempt and workflow stage a task belongs to. (d) **Cleanup** - Tasks can be efficiently queried and cleaned up based on attempt_id or runner. This is part of Hyperswitch's revenue recovery feature that automatically retries failed payments using different payment methods or connectors.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "ProcessTrackerRunner",
        "get_string_repr"
      ],
      "related_files": [
        "crates/router/src/workflows/revenue_recovery.rs",
        "crates/diesel_models/src/process_tracker.rs"
      ]
    }
  },
  {
    "id": "exp_035",
    "file_path": "crates/hyperswitch_connectors/src/default_implementations_v2.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    router_data_v2::{\n        flow_common_types::{\n            BillingConnectorInvoiceSyncFlowData, BillingConnectorPaymentsSyncFlowData,\n            DisputesFlowData, GiftCardBalanceCheckFlowData, InvoiceRecordBackData,\n            MandateRevokeFlowData, PaymentFlowData, RefundFlowData, WebhookSourceVerifyData,\n        },\n        AccessTokenFlowData, AuthenticationTokenFlowData, ExternalAuthenticationFlowData,\n        FilesFlowData, VaultConnectorFlowData,\n    },",
    "prompt": "What is the purpose of the flow_common_types module and why are flow data types separated into this module versus being defined directly in router_data_v2?",
    "constraints": "Explain the architectural decision and code organization benefits.",
    "expected_output": "The flow_common_types module groups flow data types that are shared across multiple connector operations, providing a centralized location for common data structures. The separation serves several architectural purposes: (1) **Reusability** - Flow data types like PaymentFlowData, RefundFlowData are used by multiple flow types (Authorize, Capture, Void all use PaymentFlowData), so centralizing them avoids duplication. (2) **Versioning** - By placing these in router_data_v2, they're clearly marked as v2-specific types, separate from v1 implementations, making version migration clearer. (3) **Dependency Management** - Separating flow data from flow types reduces circular dependencies, as flow types can reference flow data without creating import cycles. (4) **Maintainability** - When a flow data structure needs to change (e.g., adding a new field to PaymentFlowData), there's a single location to update rather than multiple flow type definitions. (5) **Type Safety** - The separation enforces that all flows using the same data type (e.g., all payment flows) have consistent data structures, preventing accidental divergence. This pattern is part of Hyperswitch's v2 architecture redesign that improves type safety and reduces code duplication compared to v1.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "PaymentFlowData",
        "RefundFlowData"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_data_v2.rs",
        "crates/hyperswitch_interfaces/src/api.rs"
      ]
    }
  },
  {
    "id": "exp_036",
    "file_path": "crates/hyperswitch_interfaces/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    router_data::{AccessToken, AccessTokenAuthenticationResponse},\n    router_data_v2::flow_common_types,\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n        files::{Retrieve, Upload},\n        mandate_revoke::MandateRevoke,",
    "prompt": "Why does the types.rs file in hyperswitch_interfaces import both router_data and router_data_v2? What does this tell you about the interface layer's role in version compatibility?",
    "constraints": "Explain the interface abstraction and version bridging strategy.",
    "expected_output": "The types.rs file imports both router_data (v1) and router_data_v2 because the hyperswitch_interfaces crate serves as a version-agnostic abstraction layer that must support both API versions simultaneously. This dual import strategy reveals several architectural decisions: (1) **Interface Stability** - The interfaces crate defines traits and types that remain stable across versions, allowing connectors to implement a single interface that works with both v1 and v2. (2) **Gradual Migration** - By supporting both versions, the system can migrate incrementally - some flows can use v2 while others remain on v1, without breaking existing functionality. (3) **Connector Compatibility** - Connectors don't need to know which API version is being used; they implement the interface traits, and the router layer handles version-specific logic. (4) **Type Bridging** - Some types like AccessToken and AccessTokenAuthenticationResponse are shared between versions, while flow-specific types diverge. The interface layer provides the common ground. (5) **Feature Flags** - The actual version used is controlled by feature flags (v1/v2) at compile time, but the interface layer must be aware of both to provide the abstraction. This design allows Hyperswitch to maintain backward compatibility while evolving the API, a critical requirement for a payment platform with existing integrations.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "AccessToken",
        "flow_common_types"
      ],
      "related_files": [
        "crates/hyperswitch_domain_models/src/router_data.rs",
        "crates/hyperswitch_domain_models/src/router_data_v2.rs"
      ]
    }
  },
  {
    "id": "exp_037",
    "file_path": "crates/hyperswitch_domain_models/Cargo.toml",
    "task_type": "code_understanding",
    "context_code": "[features]\ndefault = [\"olap\", \"frm\"]\nencryption_service = []\nolap = []\npayouts = [\"api_models/payouts\"]\nfrm = [\"api_models/frm\"]\nv2 = [\"api_models/v2\", \"diesel_models/v2\", \"common_utils/v2\", \"common_types/v2\"]\nv1 = [\"api_models/v1\", \"diesel_models/v1\", \"common_utils/v1\", \"common_types/v1\"]\ntokenization_v2 = [\"api_models/tokenization_v2\", \"diesel_models/tokenization_v2\"]\ndummy_connector = []\nrevenue_recovery= []",
    "prompt": "Why are both 'olap' and 'frm' included in the default features? What does this tell you about the core functionality expected in most Hyperswitch deployments?",
    "constraints": "Explain the business rationale behind making these features default.",
    "expected_output": "Both 'olap' and 'frm' are included in the default features because they represent core value-add capabilities that most Hyperswitch deployments need: (1) **OLAP (Online Analytical Processing)** - Enables analytics and reporting functionality, which is essential for merchants to track payment performance, success rates, and business metrics. Without OLAP, merchants would lack visibility into their payment operations. (2) **FRM (Fraud and Risk Management)** - Provides fraud detection and risk assessment capabilities, which are critical for payment security. Most payment processors require some level of fraud prevention to minimize chargebacks and fraudulent transactions. By making these default features, Hyperswitch ensures that: (a) Standard deployments have analytics and fraud protection out-of-the-box, (b) The codebase is tested with these features enabled by default, reducing the chance of feature-flag-related bugs, (c) Merchants don't need to explicitly enable these commonly-needed capabilities. The features can still be disabled for specialized deployments (e.g., embedded systems with limited resources) by using `default-features = false` in the dependency declaration.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [],
      "related_files": [
        "crates/api_models/Cargo.toml",
        "crates/hyperswitch_interfaces/Cargo.toml"
      ]
    }
  },
  {
    "id": "exp_038",
    "file_path": "crates/common_utils/src/id_type/global_id/payment.rs",
    "task_type": "code_understanding",
    "context_code": "impl GlobalPaymentId {\n    /// Generate a new GlobalPaymentId from a cell id\n    pub fn generate(cell_id: &crate::id_type::CellId) -> Self {\n        let global_id = super::GlobalId::generate(cell_id, super::GlobalEntity::Payment);\n        Self(global_id)\n    }\n\n    /// Generate the id for revenue recovery Execute PT workflow\n    pub fn get_execute_revenue_recovery_id(\n        &self,\n        task: &str,\n        runner: enums::ProcessTrackerRunner,\n    ) -> String {\n        format!(\"{runner}_{task}_{}\", self.get_string_repr())\n    }",
    "prompt": "What is the purpose of the get_execute_revenue_recovery_id method? How does it relate to the process tracker workflow system?",
    "constraints": "Explain the revenue recovery workflow and why it needs special ID generation.",
    "expected_output": "The `get_execute_revenue_recovery_id` method generates unique identifiers for revenue recovery workflow tasks in the process tracker system. Revenue recovery is a feature that automatically retries failed payments using different payment methods or tokens to maximize successful payment completion. The method creates IDs by combining: (1) **ProcessTrackerRunner** - Identifies which scheduler instance (consumer/producer) is handling the task, enabling distributed task processing and preventing duplicate execution. (2) **Task name** - Specifies the specific revenue recovery operation (e.g., 'retry_payment', 'token_rotation'). (3) **Payment ID** - Links the workflow back to the original payment attempt. This ID format serves several purposes: (a) **Uniqueness** - Ensures each revenue recovery task has a globally unique identifier across distributed scheduler instances. (b) **Traceability** - The ID embeds the payment context, making it easy to trace which payment a recovery task belongs to. (c) **Idempotency** - The deterministic ID generation prevents duplicate task creation if the same recovery operation is triggered multiple times. The process tracker uses these IDs to schedule, execute, and monitor revenue recovery workflows asynchronously, separate from the main payment processing flow.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "GlobalId::generate",
        "get_psync_revenue_recovery_id"
      ],
      "related_files": [
        "crates/router/src/workflows/process_tracker.rs",
        "crates/scheduler/src/workflows/payment_sync.rs"
      ]
    }
  },
  {
    "id": "exp_039",
    "file_path": "crates/hyperswitch_interfaces/src/lib.rs",
    "task_type": "code_understanding",
    "context_code": "//! Hyperswitch interface\n#![warn(missing_docs, missing_debug_implementations)]\n\npub mod api;\n/// API client interface module\npub mod api_client;\npub mod authentication;\n/// Configuration related functionalities\npub mod configs;\n/// Connector integration interface module\npub mod connector_integration_interface;\n/// definition of the new connector integration trait\npub mod connector_integration_v2;",
    "prompt": "Why does the hyperswitch_interfaces crate have both connector_integration_interface and connector_integration_v2 modules? What does this dual interface approach indicate about the connector architecture evolution?",
    "constraints": "Explain the versioning strategy and migration path for connector integrations.",
    "expected_output": "The hyperswitch_interfaces crate maintains both `connector_integration_interface` and `connector_integration_v2` modules to support a gradual migration from the legacy connector integration pattern to a new, improved architecture. This dual interface approach indicates: (1) **Backward Compatibility** - Existing connectors (100+ payment processors) continue using the original `connector_integration_interface` without breaking changes, ensuring production stability. (2) **Incremental Migration** - New connectors can be built using `connector_integration_v2`, which likely has improvements like better type safety, cleaner async handling, or more flexible flow definitions. (3) **Parallel Development** - The team can evolve the v2 interface based on lessons learned from v1 without disrupting existing integrations. (4) **Feature Parity Testing** - Both interfaces can coexist during the transition period, allowing thorough testing before deprecating v1. The presence of both modules suggests Hyperswitch is in an active migration phase where: (a) The v2 interface represents the future direction of connector integrations, (b) The v1 interface is maintained for stability but likely frozen from new features, (c) Connectors will eventually be migrated from v1 to v2 in a controlled manner. This pattern is common in large-scale systems where breaking changes to core abstractions must be carefully managed to avoid disrupting production traffic.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "ConnectorIntegration"
      ],
      "related_files": [
        "crates/hyperswitch_interfaces/src/connector_integration_interface.rs",
        "crates/hyperswitch_interfaces/src/connector_integration_v2.rs"
      ]
    }
  },
  {
    "id": "exp_040",
    "file_path": "crates/router/src/core/files.rs",
    "task_type": "code_understanding",
    "context_code": "let file_new: diesel_models::FileMetadataNew = diesel_models::file::FileMetadataNew {\n    file_id: file_id.clone(),\n    merchant_id: merchant_context.get_merchant_account().get_id().clone(),\n    file_name: create_file_request.file_name.clone(),\n    file_size: create_file_request.file_size,\n    file_type: create_file_request.file_type.to_string(),\n    provider_file_id: None,\n    file_upload_provider: None,\n    available: false,\n    connector_label: None,\n    profile_id: None,\n    merchant_connector_id: None,\n};",
    "prompt": "Why is the file metadata initially created with available: false and None values for provider_file_id and file_upload_provider? What does this two-phase creation pattern prevent?",
    "constraints": "Explain the atomicity and consistency guarantees this pattern provides.",
    "expected_output": "The file metadata is initially created with `available: false` and `None` values for provider fields to implement a two-phase commit pattern that ensures data consistency and prevents race conditions. This pattern provides several guarantees: (1) **Atomicity** - The file record is created in the database immediately (lines 48-53), reserving the file_id and establishing ownership, but marked as unavailable until the actual upload completes. If the upload fails, the file remains unavailable rather than pointing to non-existent data. (2) **Consistency** - By setting `provider_file_id: None` and `file_upload_provider: None` initially, the system ensures that no code can attempt to retrieve or reference the file until it's fully uploaded. The `available: false` flag acts as a safety lock. (3) **Idempotency** - If the upload process crashes or times out, the file metadata exists but is marked unavailable, allowing retry logic to detect the partial state and either resume or clean up. (4) **Audit Trail** - The initial record creation timestamp captures when the upload was initiated, separate from when it completed (via the update at lines 72-80). This two-phase pattern prevents: (a) **Orphaned References** - Users can't access files that failed to upload, (b) **Race Conditions** - Concurrent requests won't see partially uploaded files, (c) **Data Loss** - The metadata survives even if the upload fails, enabling debugging and retry mechanisms. After successful upload (lines 54-62), the metadata is updated with the actual provider details and `available: true` (lines 65-71), making the file accessible to users.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "upload_and_get_provider_provider_file_id_profile_id",
        "update_file_metadata"
      ],
      "related_files": [
        "crates/router/src/core/files/helpers.rs",
        "crates/diesel_models/src/file.rs"
      ]
    }
  },
  {
    "id": "exp_041",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "    #[test]\n    fn test_serialize_alpha2() {\n        let x_request = Alpha2Request {\n            country: Country::India,\n        };\n        let serialized_country = serde_json::to_string(&x_request).unwrap();\n        assert_eq!(serialized_country, r#\"{\"country\":\"IN\"}\"#);\n\n        let x_request = Alpha2Request {\n            country: Country::MacedoniaTheFormerYugoslavRepublic,\n        };\n        let serialized_country = serde_json::to_string(&x_request).unwrap();\n        assert_eq!(serialized_country, r#\"{\"country\":\"MK\"}\"#);\n\n        let x_request = Alpha2Request {\n            country: Country::FrenchSouthernTerritories,\n        };\n        let serialized_country = serde_json::to_string(&x_request).unwrap();\n        assert_eq!(serialized_country, r#\"{\"country\":\"TF\"}\"#);\n    }",
    "prompt": "Explain how the `test_serialize_alpha2` function demonstrates the serialization of the `Country` enum into its Alpha-2 code representation.",
    "constraints": "Focus on the `Alpha2Request` struct and the `serde_json::to_string` method.",
    "expected_output": "The `test_serialize_alpha2` function creates instances of `Alpha2Request` with different `Country` enum values. It then uses `serde_json::to_string` to serialize these requests into JSON strings. The assertions verify that the `Country` enum is correctly serialized into its corresponding two-letter (Alpha-2) ISO 3166-1 country code, such as `Country::India` becoming `\"IN\"`.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_serialize_alpha2",
        "serde_json::to_string"
      ],
      "related_files": [
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "exp_042",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "    #[test]\n    fn test_deserialize_numeric() {\n        let request_str = r#\"{\"country\":356}\"#;\n        let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n        assert_eq!(request.country, Country::India);\n\n        let request_str = r#\"{\"country\":239}\"#;\n        let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n        assert_eq!(\n            request.country,\n            Country::SouthGeorgiaAndTheSouthSandwichIslands\n        );\n\n        let request_str = r#\"{\"country\":826}\"#;\n        let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n        assert_eq!(\n            request.country,\n            Country::UnitedKingdomOfGreatBritainAndNorthernIreland\n        );\n    }",
    "prompt": "How does `test_deserialize_numeric` verify the deserialization of numeric country codes into the `Country` enum?",
    "constraints": "Explain the role of `HyperswitchRequestNumeric` and `serde_json::from_str`.",
    "expected_output": "The `test_deserialize_numeric` function takes JSON strings containing numeric country codes (e.g., `{\"country\":356}`). It then uses `serde_json::from_str` to deserialize these strings into `HyperswitchRequestNumeric` structs. The assertions confirm that the numeric codes are correctly mapped back to their corresponding `Country` enum variants, such as `356` deserializing to `Country::India`.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "test_deserialize_numeric",
        "serde_json::from_str"
      ],
      "related_files": [
        "crates/common_enums/src/enums.rs"
      ]
    }
  },
  {
    "id": "exp_043",
    "file_path": "crates/hyperswitch_connectors/src/connectors/cybersource/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "pub fn map_cybersource_attempt_status(\n    status: CybersourcePaymentStatus,\n    capture: bool,\n) -> enums::AttemptStatus {\n    match status {\n        CybersourcePaymentStatus::Authorized => {\n            if capture {\n                // Because Cybersource will return Payment Status as Authorized even in AutoCapture Payment\n                enums::AttemptStatus::Charged\n            } else {\n                enums::AttemptStatus::Authorized\n            }\n        }\n        CybersourcePaymentStatus::Succeeded | CybersourcePaymentStatus::Transmitted => {\n            enums::AttemptStatus::Charged\n        }\n        CybersourcePaymentStatus::Voided\n        | CybersourcePaymentStatus::Reversed\n        | CybersourcePaymentStatus::Cancelled => enums::AttemptStatus::Voided,\n        CybersourcePaymentStatus::Failed\n        | CybersourcePaymentStatus::Declined\n        | CybersourcePaymentStatus::AuthorizedRiskDeclined\n        | CybersourcePaymentStatus::Rejected\n        | CybersourcePaymentStatus::InvalidRequest\n        | CybersourcePaymentStatus::ServerError => enums::AttemptStatus::Failure,\n        CybersourcePaymentStatus::PendingAuthentication => {\n            enums::AttemptStatus::AuthenticationPending\n        }\n        CybersourcePaymentStatus::PendingReview\n        | CybersourcePaymentStatus::StatusNotReceived\n        | CybersourcePaymentStatus::Challenge\n        | CybersourcePaymentStatus::Accepted\n        | CybersourcePaymentStatus::Pending\n        | CybersourcePaymentStatus::AuthorizedPendingReview => enums::AttemptStatus::Pending,\n    }\n}",
    "prompt": "Describe the logic within `map_cybersource_attempt_status` for converting a `CybersourcePaymentStatus` to a `common_enums::AttemptStatus`, specifically focusing on how `CybersourcePaymentStatus::Authorized` is handled.",
    "constraints": "Explain the conditional logic for `capture` and the mapping of other statuses.",
    "expected_output": "The `map_cybersource_attempt_status` function converts a `CybersourcePaymentStatus` to a `common_enums::AttemptStatus`. For `CybersourcePaymentStatus::Authorized`, it checks the `capture` boolean: if `true`, it maps to `enums::AttemptStatus::Charged` (indicating auto-capture); otherwise, it maps to `enums::AttemptStatus::Authorized`. Other statuses like `Succeeded` and `Transmitted` map to `Charged`, `Voided` and `Reversed` map to `Voided`, various failure states map to `Failure`, `PendingAuthentication` maps to `AuthenticationPending`, and several pending/review states map to `Pending`.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "map_cybersource_attempt_status",
        "CybersourcePaymentStatus",
        "enums::AttemptStatus"
      ],
      "related_files": [
        "crates/common_enums/src/enums.rs",
        "crates/hyperswitch_connectors/src/connectors/cybersource/mod.rs"
      ]
    }
  },
  {
    "id": "exp_044",
    "file_path": ".github/workflows/validate-openapi-spec.yml",
    "task_type": "code_understanding",
    "context_code": "      - name: Generate the OpenAPI spec file for V1\n        shell: bash\n        run: cargo run -p openapi --features v1\n\n      - name: Generate the OpenAPI spec file for V2\n        shell: bash\n        run: cargo run -p openapi --features v2",
    "prompt": "What is the purpose of these two steps in the `validate-openapi-spec.yml` workflow?",
    "constraints": "Explain what each `cargo run` command does in the context of OpenAPI specification generation.",
    "expected_output": "These steps in the `validate-openapi-spec.yml` workflow are responsible for generating the OpenAPI specification files for both V1 and V2 of the Hyperswitch API. The first step, `cargo run -p openapi --features v1`, generates the V1 OpenAPI spec, and the second step, `cargo run -p openapi --features v2`, generates the V2 OpenAPI spec. This ensures that the API documentation is always up-to-date with the codebase.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/openapi/src/openapi.rs",
        "crates/openapi/src/openapi_v2.rs"
      ]
    }
  },
  {
    "id": "exp_045",
    "file_path": "crates/hyperswitch_connectors/src/connectors/celero/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "pub fn get_avs_definition(code: &str) -> Option<&'static str> {\n    match code {\n        \"0\" => Some(\"AVS Not Available\"),\n        \"A\" => Some(\"Address match only\"),\n        \"B\" => Some(\"Address matches, ZIP not verified\"),\n        \"C\" => Some(\"Incompatible format\"),\n        \"D\" => Some(\"Exact match\"),\n        \"F\" => Some(\"Exact match, UK-issued cards\"),\n        \"G\" => Some(\"Non-U.S. Issuer does not participate\"),\n        \"I\" => Some(\"Not verified\"),\n        \"M\" => Some(\"Exact match\"),\n        \"N\" => Some(\"No address or ZIP match\"),\n        \"P\" => Some(\"Postal Code match\"),\n        \"R\" => Some(\"Issuer system unavailable\"),\n        \"S\" => Some(\"Service not supported\"),\n        \"U\" => Some(\"Address unavailable\"),\n        \"W\" => Some(\"9-character numeric ZIP match only\"),\n        \"X\" => Some(\"Exact match, 9-character numeric ZIP\"),\n        \"Y\" => Some(\"Exact match, 5-character numeric ZIP\"),\n        \"Z\" => Some(\"5-character ZIP match only\"),\n        \"L\" => Some(\"Partial match, Name and billing postal code match\"),\n        \"1\" => Some(\"Cardholder name and ZIP match\"),\n        \"2\" => Some(\"Cardholder name, address and ZIP match\"),\n        \"3\" => Some(\"Cardholder name and address match\"),\n        \"4\" => Some(\"Cardholder name matches\"),\n        \"5\" => Some(\"Cardholder name incorrect, ZIP matches\"),\n        \"6\" => Some(\"Cardholder name incorrect, address and zip match\"),\n        \"7\" => Some(\"Cardholder name incorrect, address matches\"),\n        \"8\" => Some(\"Cardholder name, address, and ZIP do not match\"),\n        _ => {\n            router_env::logger::info!(\n                \"Celero avs response code ({:?}) is not mapped to any definition.\",\n                code\n            );\n\n            None\n        }\n    }\n}",
    "prompt": "What is the function of `get_avs_definition` and how does it handle unrecognized AVS response codes?",
    "constraints": "Explain the mapping of AVS codes to their definitions and the fallback behavior.",
    "expected_output": "The `get_avs_definition` function maps Address Verification System (AVS) response codes (e.g., \"A\", \"X\", \"Y\") to human-readable definitions (e.g., \"Address match only\", \"Exact match, 9-character numeric ZIP\"). If an unrecognized AVS code is provided, the function logs an informational message using `router_env::logger::info!` indicating that the code is not mapped to any definition, and then returns `None`.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_avs_definition",
        "router_env::logger::info!"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/celero/mod.rs"
      ]
    }
  },
  {
    "id": "exp_046",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "impl TryFrom<&SubmitEvidenceRouterData> for Evidence {\n    type Error = error_stack::Report<ConnectorError>;\n    fn try_from(item: &SubmitEvidenceRouterData) -> Result<Self, Self::Error> {\n        let submit_evidence_request_data = item.request.clone();\n        Ok(Self {\n            access_activity_log: submit_evidence_request_data.access_activity_log,\n            billing_address: submit_evidence_request_data\n                .billing_address\n                .map(Secret::new),\n            cancellation_policy: submit_evidence_request_data.cancellation_policy_provider_file_id,\n            cancellation_policy_disclosure: submit_evidence_request_data\n                .cancellation_policy_disclosure,\n            cancellation_rebuttal: submit_evidence_request_data.cancellation_rebuttal,\n            customer_communication: submit_evidence_request_data\n                .customer_communication_provider_file_id,\n            customer_email_address: submit_evidence_request_data\n                .customer_email_address\n                .map(Secret::new),\n            customer_name: submit_evidence_request_data.customer_name.map(Secret::new),\n            customer_purchase_ip: submit_evidence_request_data\n                .customer_purchase_ip\n                .map(Secret::new),\n            customer_signature: submit_evidence_request_data\n                .customer_signature_provider_file_id\n                .map(Secret::new),\n            product_description: submit_evidence_request_data.product_description,\n            receipt: submit_evidence_request_data\n                .receipt_provider_file_id\n                .map(Secret::new),\n            refund_policy: submit_evidence_request_data.refund_policy_provider_file_id,\n            refund_policy_disclosure: submit_evidence_request_data.refund_policy_disclosure,\n            refund_refusal_explanation: submit_evidence_request_data.refund_refusal_explanation,\n            service_date: submit_evidence_request_data.service_date,\n            service_documentation: submit_evidence_request_data\n                .service_documentation_provider_file_id,\n            shipping_address: submit_evidence_request_data\n                .shipping_address\n                .map(Secret::new),\n            shipping_carrier: submit_evidence_request_data.shipping_carrier,\n            shipping_date: submit_evidence_request_data.shipping_date,\n            shipping_documentation: submit_evidence_request_data\n                .shipping_documentation_provider_file_id\n                .map(Secret::new),\n            shipping_tracking_number: submit_evidence_request_data\n                .shipping_tracking_number\n                .map(Secret::new),\n            uncategorized_file: submit_evidence_request_data.uncategorized_file_provider_file_id,\n            uncategorized_text: submit_evidence_request_data.uncategorized_text,\n            submit: true,\n        })\n    }\n}",
    "prompt": "What is the purpose of the `TryFrom<&SubmitEvidenceRouterData> for Evidence` implementation?",
    "constraints": "Explain how data is transformed from `SubmitEvidenceRouterData` to `Evidence`.",
    "expected_output": "This `impl TryFrom` block defines how to convert a `SubmitEvidenceRouterData` object into an `Evidence` object. It extracts various fields from `submit_evidence_request_data` (which is cloned from `item.request`) and maps them to the corresponding fields in the `Evidence` struct. Notably, sensitive fields like `billing_address`, `customer_email_address`, `customer_name`, `customer_purchase_ip`, `customer_signature`, `receipt`, `shipping_address`, `shipping_documentation`, and `shipping_tracking_number` are wrapped in `Secret::new()` for masking purposes. The `submit` field is hardcoded to `true`.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "try_from"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/stripe.rs",
        "crates/hyperswitch_connectors/src/types.rs",
        "crates/router/src/types.rs"
      ]
    }
  },
  {
    "id": "exp_047",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "pub struct DisputeObj {\n    #[serde(rename = \"id\")]\n    pub dispute_id: String,\n    pub status: String,\n}",
    "prompt": "What is the structure and purpose of the `DisputeObj` struct?",
    "constraints": "Explain the fields and their serialization behavior.",
    "expected_output": "The `DisputeObj` struct is used to represent a dispute object, likely for serialization and deserialization. It has two public fields: `dispute_id` of type `String`, which is deserialized from a field named \"id\" due to `#[serde(rename = \"id\")]`, and `status` of type `String`, representing the status of the dispute. This struct is marked with `#[derive(Debug, Deserialize, Serialize)]`, indicating it can be debug-printed, deserialized from, and serialized to formats like JSON.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/stripe.rs"
      ]
    }
  },
  {
    "id": "exp_048",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "fn get_transaction_metadata(\n    merchant_metadata: Option<Secret<Value>>,\n    order_id: String,\n) -> HashMap<String, String> {\n    let mut meta_data = HashMap::from([(\"metadata[order_id]\".to_string(), order_id)]);\n    let mut request_hash_map = HashMap::new();\n\n    if let Some(metadata) = merchant_metadata {\n        let hashmap: HashMap<String, Value> =\n            serde_json::from_str(&metadata.peek().to_string()).unwrap_or(HashMap::new());\n\n        for (key, value) in hashmap {\n            request_hash_map.insert(format!(\"metadata[{key}]\"), value.to_string());\n        }\n\n        meta_data.extend(request_hash_map)\n    };\n    meta_data\n}",
    "prompt": "How does `get_transaction_metadata` process `merchant_metadata` and `order_id` to generate a `HashMap`?",
    "constraints": "Describe the steps involved in constructing the final `meta_data` HashMap.",
    "expected_output": "The `get_transaction_metadata` function initializes a `HashMap` named `meta_data` with the `order_id` under the key \"metadata[order_id]\". If `merchant_metadata` is provided, it attempts to parse the `Secret<Value>` into a `HashMap<String, Value>`. It then iterates through this parsed `hashmap`, formatting each key as \"metadata[{key}]\" and converting the value to a `String`, inserting these into `request_hash_map`. Finally, `request_hash_map` is extended into `meta_data`, and the combined `meta_data` is returned.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "serde_json::from_str",
        "HashMap::from",
        "HashMap::new",
        "HashMap::extend"
      ],
      "related_files": []
    }
  },
  {
    "id": "exp_049",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "fn get_stripe_payments_response_data(\n    response: &Option<ErrorDetails>,\n    http_code: u16,\n    response_id: String,\n) -> Box<Result<PaymentsResponseData, hyperswitch_domain_models::router_data::ErrorResponse>> {\n    let (code, error_message) = match response {\n        Some(error_details) => (\n            error_details\n                .code\n                .to_owned()\n                .unwrap_or_else(|| consts::NO_ERROR_CODE.to_string()),\n            error_details\n                .message\n                .to_owned()\n                .unwrap_or_else(|| consts::NO_ERROR_MESSAGE.to_string()),\n        ),\n        None => (\n            consts::NO_ERROR_CODE.to_string(),\n            consts::NO_ERROR_MESSAGE.to_string(),\n        ),\n    };\n\n    Box::new(Err(hyperswitch_domain_models::router_data::ErrorResponse {\n        code,\n        message: error_message.clone(),\n        reason: response.clone().and_then(|res| {\n            res.decline_code\n                .clone()\n                .map(|decline_code| {\n                    format!(\"message - {error_message}, decline_code - {decline_code}\")\n                })\n                .or(Some(error_message.clone()))\n        }),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(response_id),\n        network_advice_code: response\n            .as_ref()\n            .and_then(|res| res.network_advice_code.clone()),\n        network_decline_code: response\n            .as_ref()\n            .and_then(|res| res.network_decline_code.clone()),\n        network_error_message: response\n            .as_ref()\n            .and_then(|res| res.decline_code.clone().or(res.advice_code.clone())),\n        connector_metadata: None,\n    }))\n}",
    "prompt": "Explain the logic within `get_stripe_payments_response_data` for constructing an `ErrorResponse`.",
    "constraints": "Detail how `code`, `message`, and `reason` fields are derived, considering the `response` parameter.",
    "expected_output": "The `get_stripe_payments_response_data` function first determines `code` and `error_message` based on whether `response` (an `Option<ErrorDetails>`) is `Some` or `None`. If `Some`, it uses the `code` and `message` from `ErrorDetails`, defaulting to `consts::NO_ERROR_CODE` and `consts::NO_ERROR_MESSAGE` if absent. If `None`, it uses the default constants. It then constructs an `ErrorResponse` where `code` and `message` are set from the derived values. The `reason` field is conditionally formatted: if `response` contains a `decline_code`, it combines the `error_message` and `decline_code`; otherwise, it uses the `error_message`. Other fields like `status_code`, `connector_transaction_id`, `network_advice_code`, `network_decline_code`, and `network_error_message` are populated from the input parameters and `response` if available.",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "unwrap_or_else",
        "and_then",
        "map",
        "clone"
      ],
      "related_files": []
    }
  },
  {
    "id": "exp_050",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "pub(super) fn transform_headers_for_connect_platform(\n    charge_type: PaymentChargeType,\n    transfer_account_id: String,\n    header: &mut Vec<(String, Maskable<String>)>,\n) {\n    if let PaymentChargeType::Stripe(StripeChargeType::Direct) = charge_type {\n        let mut customer_account_header = vec![(",
    "prompt": "Under what conditions does `transform_headers_for_connect_platform` modify the `header` vector, and what modification is made?",
    "constraints": "Focus on the `if let` condition and the header manipulation.",
    "expected_output": "The `transform_headers_for_connect_platform` function modifies the `header` vector only if the `charge_type` is `PaymentChargeType::Stripe(StripeChargeType::Direct)`. When this condition is met, it creates a new header entry with the key `STRIPE_COMPATIBLE_CONNECT_ACCOUNT` and the `transfer_account_id` (masked), and then appends this new header to the existing `header` vector.",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "append"
      ],
      "related_files": [
        "crates/hyperswitch_connectors/src/connectors/stripe.rs"
      ]
    }
  },
  {
    "id": "exp_051",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "pub fn construct_charge_response<T>(\n    charge_id: String,\n    request: &T,\n) -> Option<common_types::payments::ConnectorChargeResponseData>\nwhere\n    T: SplitPaymentData,\n{\n    let charge_request = request.get_split_payment_data();\n    if let Some(SplitPaymentsRequest::StripeSplitPayment(stripe_split_payment)) = charge_request {\n        let stripe_charge_response = common_types::payments::StripeChargeResponseData {\n            charge_id: Some(charge_id),\n            charge_type: stripe_split_payment.charge_type,\n            application_fees: stripe_split_payment.application_fees,\n            transfer_account_id: stripe_split_payment.transfer_account_id,\n        };\n        Some(\n            common_types::payments::ConnectorChargeResponseData::StripeSplitPayment(\n                stripe_charge_response,\n            ),\n        )\n    } else {\n        None\n    }\n}",
    "prompt": "What is the purpose of the `construct_charge_response` function and how does it handle different `SplitPaymentsRequest` types?",
    "constraints": "Explain the return type and the conditional logic for `SplitPaymentsRequest`.",
    "expected_output": "The `construct_charge_response` function aims to create an `Option<common_types::payments::ConnectorChargeResponseData>` based on a `charge_id` and a `request` that implements `SplitPaymentData`. It first retrieves `charge_request` from the `request`. If `charge_request` is `Some` and specifically matches `SplitPaymentsRequest::StripeSplitPayment`, it constructs a `common_types::payments::StripeChargeResponseData` using the provided `charge_id` and fields from `stripe_split_payment`, then wraps it in `ConnectorChargeResponseData::StripeSplitPayment` and returns `Some`. Otherwise, if the `charge_request` is `None` or a different `SplitPaymentsRequest` type, it returns `None`.",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_split_payment_data"
      ],
      "related_files": [
        "crates/common_types/src/payments.rs",
        "crates/hyperswitch_connectors/src/connectors/stripe.rs",
        "crates/router/src/connector/utils.rs"
      ]
    }
  },
  {
    "id": "exp_052",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "# Contributing to hyperswitch\n\n:tada: First off, thanks for taking the time to contribute!\nWe are so happy to have you! :tada:\n\nThere are opportunities to contribute to hyperswitch at any level.\nIt doesn't matter if you are just getting started with Rust or are the most\nweathered expert, we can use your help.\n\n**No contribution is too small and all contributions are valued.**",
    "prompt": "What is the purpose of the `CONTRIBUTING.md` file?",
    "constraints": "Focus on the initial sections of the document.",
    "expected_output": "The `CONTRIBUTING.md` file serves as a guide for individuals who wish to contribute to the Hyperswitch project. It welcomes contributors of all skill levels and emphasizes that all contributions are valued. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"1\" end=\"10\" />",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md"
    ]
  },
  {
    "id": "exp_053",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "You can also get help with contributing on our [Discord server][discord],\n[Slack workspace][slack], or [Discussions][discussions] space.\nPlease join us!\n\n[discord]: https://discord.gg/wJZ7DVW8mm\n[slack]: https://join.slack.com/t/hyperswitch-io/shared_invite/zt-2awm23agh-p_G5xNpziv6yAiedTkkqLg\n[discussions]: https://github.com/juspay/hyperswitch/discussions",
    "prompt": "Where can contributors find help or discuss issues related to Hyperswitch?",
    "constraints": "List all communication channels mentioned.",
    "expected_output": "Contributors can find help and discuss issues on the Hyperswitch Discord server, Slack workspace, or Discussions space. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"16\" end=\"22\" />",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md"
    ]
  },
  {
    "id": "exp_054",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "## What's Included❓\n\n### Repositories\nThe current setup contains three different repositories, corresponding to the different Hyperswitch components.\n\n- [App Server][app-server] - The core payments engine responsible for managing payment flows, payment unification and smart routing. App server is maintained in this repo itself.\n\n- [Web Client (SDK)][web-client] - An inclusive, consistent and blended payment experience optimized for the best payment conversions.\n\n- [Control center][control-center] - A dashboard for payment analytics and operations, managing payment processors or payment methods and configuring payment routing rules.\n\n[app-server]: https://github.com/juspay/hyperswitch\n[web-client]: https://github.com/juspay/hyperswitch-web\n[control-center]: https://github.com/juspay/hyperswitch-control-center",
    "prompt": "What are the three main repositories that constitute the Hyperswitch ecosystem, and what is the purpose of each?",
    "constraints": "Provide a brief description for each repository.",
    "expected_output": "The Hyperswitch ecosystem consists of three main repositories: <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"62\" end=\"75\" />\n1.  **App Server**: The core payments engine for managing payment flows, unification, and smart routing. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"67\" end=\"67\" />\n2.  **Web Client (SDK)**: Provides a consistent payment experience optimized for conversions. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"69\" end=\"69\" />\n3.  **Control Center**: A dashboard for payment analytics, operations, and configuring routing rules. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"71\" end=\"71\" />",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md",
      "README.md"
    ]
  },
  {
    "id": "exp_055",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": ".\n├── config                             : Initial startup config files for the router\n├── connector-template                 : boilerplate code for connectors\n├── crates                             : sub-crates\n│   ├── api_models                     : Request/response models for the `router` crate\n│   ├── cards                          : Types to handle card masking and validation\n│   ├── common_enums                   : Enums shared across the request/response types and database types\n│   ├── common_utils                   : Utilities shared across `router` and other crates\n│   ├── data_models                    : Represents the data/domain models used by the business/domain layer\n│   ├── diesel_models                  : Database models shared across `router` and other crates\n│   ├── drainer                        : Application that reads Redis streams and executes queries in database\n│   ├── external_services              : Interactions with external systems like emails, AWS KMS, etc.\n│   ├── masking                        : Personal Identifiable Information protection\n│   ├── redis_interface                : A user-friendly interface to Redis\n│   ├── router                         : Main crate of the project\n│   ├── router_derive                  : Utility macros for the `router` crate\n│   ├── router_env                     : Environment of payment router: logger, basic config, its environment awareness\n│   ├── scheduler                      : Scheduling and executing deferred tasks like mail scheduling\n│   ├── storage_impl                   : Storage backend implementations for data structures & objects\n│   └── test_utils                     : Utilities to run Postman and connector UI tests\n├── docs                               : hand-written documentation\n├── loadtest                           : performance benchmarking setup\n├── migrations                         : diesel DB setup\n├── monitoring                         : Grafana & Loki monitoring related configuration files\n├── openapi                            : automatically generated OpenAPI spec\n├── postman                            : postman scenarios API\n└── scripts                            : automation, testing, and other utility scripts",
    "prompt": "Describe the purpose of the `crates/router` and `crates/api_models` directories within the Hyperswitch project structure.",
    "constraints": "Refer to the provided file tree layout.",
    "expected_output": "According to the file tree layout, `crates/router` is the main crate of the project, <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"101\" end=\"101\" /> while `crates/api_models` contains the request/response models for the `router` crate. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"91\" end=\"91\" />",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md",
      "crates/router/",
      "crates/api_models/"
    ]
  },
  {
    "id": "exp_056",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "## Contributing in Issues\n\nFor any issue, there are fundamentally three ways an individual can contribute:\n\n1. By opening the issue for discussion: For instance, if you believe that you\n   have discovered a bug in hyperswitch, creating a new issue in [the\n   juspay/hyperswitch issue tracker][issue] is the way to report it.\n\n2. By helping to triage the issue: This can be done by providing supporting\n   details (a test case that demonstrates a bug), providing suggestions on how\n   to address the issue, or ensuring that the issue is tagged correctly.\n\n3. By helping to resolve the issue: Typically this is done either in the form of\n   demonstrating that the issue reported is not a problem after all, or more\n   often, by opening a Pull Request that changes some bit of something in\n   hyperswitch in a concrete and reviewable manner.",
    "prompt": "What are the three primary ways an individual can contribute to issues in Hyperswitch?",
    "constraints": "List each method of contribution.",
    "expected_output": "An individual can contribute to issues in Hyperswitch in three primary ways: <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"116\" end=\"131\" />\n1.  **Opening the issue for discussion**: Reporting bugs or suggesting new features. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"120\" end=\"122\" />\n2.  **Helping to triage the issue**: Providing supporting details, suggestions, or ensuring correct tagging. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"124\" end=\"126\" />\n3.  **Helping to resolve the issue**: Demonstrating that an issue is not a problem or opening a Pull Request to fix it. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"128\" end=\"131\" />",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md"
    ]
  },
  {
    "id": "exp_057",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "### Code Coverage\n\nWe appreciate well-tested code, so feel free to add tests when you can.\n\nTo generate code coverage using the cypress tests, follow these steps:\n\n0. Make sure `grcov` and `llvm-tools-preview` are installed\n\n   ```shell\n   rustup component add llvm-tools-preview\n   cargo install grcov\n   ```",
    "prompt": "What tools are required to generate code coverage for Hyperswitch using Cypress tests?",
    "constraints": "Identify the specific tools mentioned in the setup steps.",
    "expected_output": "To generate code coverage using Cypress tests, `grcov` and `llvm-tools-preview` are required. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"233\" end=\"233\" /> These can be installed using `rustup component add llvm-tools-preview` and `cargo install grcov`. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"236\" end=\"237\" />",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md",
      "cypress-tests/"
    ]
  },
  {
    "id": "exp_058",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "#[test]\nfn test_deserialize_alpha3() {\n    let request_str = r#\"{\"country\":\"IND\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha3>(request_str).unwrap();\n    assert_eq!(request.country, Country::India);\n\n    let request_str = r#\"{\"country\":\"LVA\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha3>(request_str).unwrap();\n    assert_eq!(request.country, Country::Latvia);\n\n    let request_str = r#\"{\"country\":\"PNG\"}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestAlpha3>(request_str).unwrap();\n    assert_eq!(request.country, Country::PapuaNewGuinea);\n}",
    "prompt": "What is the purpose of the `test_deserialize_alpha3` function?",
    "constraints": "Focus on the function's role in deserialization and country codes.",
    "expected_output": "The `test_deserialize_alpha3` function tests the deserialization of country codes provided in Alpha-3 format (e.g., \"IND\", \"LVA\", \"PNG\") into their corresponding `Country` enum variants (e.g., `Country::India`, `Country::Latvia`, `Country::PapuaNewGuinea`). <cite repo=\"juspay/hyperswitch\" path=\"crates/common_enums/src/transformers.rs\" start=\"1\" end=\"14\" /> It uses `serde_json::from_str` to parse JSON strings containing the country code and asserts that the deserialized `Country` enum matches the expected value. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "serde_json::from_str",
        "assert_eq"
      ]
    },
    "related_files": [
      "crates/common_enums/src/transformers.rs",
      "crates/common_enums/src/enums.rs"
    ]
  },
  {
    "id": "exp_059",
    "file_path": "crates/common_enums/src/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "#[test]\nfn test_deserialize_numeric() {\n    let request_str = r#\"{\"country\":356}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n    assert_eq!(request.country, Country::India);\n\n    let request_str = r#\"{\"country\":239}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n    assert_eq!(\n        request.country,\n        Country::SouthGeorgiaAndTheSouthSandwichIslands\n    );\n\n    let request_str = r#\"{\"country\":826}\"#;\n    let request = serde_json::from_str::<HyperswitchRequestNumeric>(request_str).unwrap();\n    assert_eq!(\n        request.country,\n        Country::UnitedKingdomOfGreatBritainAndNorthernIreland\n    );\n}",
    "prompt": "How does `test_deserialize_numeric` verify country code deserialization?",
    "constraints": "Explain the input format and the expected output.",
    "expected_output": "The `test_deserialize_numeric` function verifies the deserialization of country codes provided in numeric format (e.g., 356, 239, 826) into their corresponding `Country` enum variants. <cite repo=\"juspay/hyperswitch\" path=\"crates/common_enums/src/transformers.rs\" start=\"1\" end=\"20\" /> It takes JSON strings with a numeric `country` field, uses `serde_json::from_str` to deserialize them into `HyperswitchRequestNumeric`, and then asserts that the `country` field of the deserialized object matches the expected `Country` enum variant. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "serde_json::from_str",
        "assert_eq"
      ]
    },
    "related_files": [
      "crates/common_enums/src/transformers.rs",
      "crates/common_enums/src/enums.rs"
    ]
  },
  {
    "id": "exp_060",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "fn get_transaction_metadata(\n    merchant_metadata: Option<Secret<Value>>,\n    order_id: String,\n) -> HashMap<String, String> {\n    let mut meta_data = HashMap::from([(\"metadata[order_id]\".to_string(), order_id)]);\n    let mut request_hash_map = HashMap::new();\n\n    if let Some(metadata) = merchant_metadata {\n        let hashmap: HashMap<String, Value> =\n            serde_json::from_str(&metadata.peek().to_string()).unwrap_or(HashMap::new());\n\n        for (key, value) in hashmap {\n            request_hash_map.insert(format!(\"metadata[{key}]\"), value.to_string());\n        }\n\n        meta_data.extend(request_hash_map)\n    };\n    meta_data\n}",
    "prompt": "What is the purpose of the `get_transaction_metadata` function and how does it process `merchant_metadata`?",
    "constraints": "Explain the role of `merchant_metadata` and how it's transformed.",
    "expected_output": "The `get_transaction_metadata` function constructs a `HashMap<String, String>` containing metadata for a transaction. <cite repo=\"juspay/hyperswitch\" path=\"crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs\" start=\"1\" end=\"19\" /> It initializes the map with an `order_id`. <cite/> If `merchant_metadata` (an `Option<Secret<Value>>`) is provided, it deserializes the JSON `Value` within it into a `HashMap<String, Value>`. <cite/> It then iterates over this map, formatting each key as `\"metadata[{key}]\"` and converting the value to a string, before extending the initial `meta_data` HashMap. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "serde_json::from_str",
        "HashMap::from",
        "HashMap::extend"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
      "crates/hyperswitch_connectors/src/connectors/stripe.rs"
    ]
  },
  {
    "id": "exp_061",
    "file_path": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "task_type": "code_understanding",
    "context_code": "fn get_stripe_payments_response_data(\n    response: &Option<ErrorDetails>,\n    http_code: u16,\n    response_id: String,\n) -> Box<Result<PaymentsResponseData, hyperswitch_domain_models::router_data::ErrorResponse>> {\n    let (code, error_message) = match response {\n        Some(error_details) => (\n            error_details\n                .code\n                .to_owned()\n                .unwrap_or_else(|| consts::NO_ERROR_CODE.to_string()),\n            error_details\n                .message\n                .to_owned()\n                .unwrap_or_else(|| consts::NO_ERROR_MESSAGE.to_string()),\n        ),\n        None => (\n            consts::NO_ERROR_CODE.to_string(),\n            consts::NO_ERROR_MESSAGE.to_string(),\n        ),\n    };\n\n    Box::new(Err(hyperswitch_domain_models::router_data::ErrorResponse {\n        code,\n        message: error_message.clone(),\n        reason: response.clone().and_then(|res| {\n            res.decline_code\n                .clone()\n                .map(|decline_code|\n                    format!(\"message - {error_message}, decline_code - {decline_code}\")\n                )\n                .or(Some(error_message.clone()))\n        }),\n        status_code: http_code,\n        attempt_status: None,\n        connector_transaction_id: Some(response_id),\n        network_advice_code: response\n            .as_ref()\n            .and_then(|res| res.network_advice_code.clone()),\n        network_decline_code: response\n            .as_ref()\n            .and_then(|res| res.network_decline_code.clone()),\n        network_error_message: response\n            .as_ref()\n            .and_then(|res| res.decline_code.clone().or(res.advice_code.clone())),\n        connector_metadata: None,\n    }))\n}",
    "prompt": "Explain the error handling logic within `get_stripe_payments_response_data`.",
    "constraints": "Describe how error codes, messages, and reasons are extracted and structured into an `ErrorResponse`.",
    "expected_output": "The `get_stripe_payments_response_data` function constructs an `ErrorResponse` from an optional `ErrorDetails` object and an HTTP status code. <cite repo=\"juspay/hyperswitch\" path=\"crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs\" start=\"1\" end=\"48\" /> It extracts the `code` and `message` from `ErrorDetails`, defaulting to `NO_ERROR_CODE` and `NO_ERROR_MESSAGE` if `ErrorDetails` is `None`. <cite/> The `reason` field of the `ErrorResponse` is built by combining the `error_message` with a `decline_code` if available, or just using the `error_message`. <cite/> It also populates `status_code`, `connector_transaction_id`, `network_advice_code`, `network_decline_code`, and `network_error_message` from the `ErrorDetails`. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "ErrorDetails::code",
        "ErrorDetails::message",
        "ErrorDetails::decline_code"
      ]
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
      "crates/hyperswitch_domain_models/src/router_data.rs"
    ]
  },
  {
    "id": "exp_062",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "### Files Tree Layout\n\nWithin the repositories, you'll find the following directories and files,\nlogically grouping common assets and providing both compiled and minified\nvariations.\n\n```text\n.\n├── config                             : Initial startup config files for the router\n├── connector-template                 : boilerplate code for connectors\n├── crates                             : sub-crates\n│   ├── api_models                     : Request/response models for the `router` crate\n│   ├── cards                          : Types to handle card masking and validation\n│   ├── common_enums                   : Enums shared across the request/response types and database types\n│   ├── common_utils                   : Utilities shared across `router` and other crates\n│   ├── data_models                    : Represents the data/domain models used by the business/domain layer\n│   ├── diesel_models                  : Database models shared across `router` and other crates\n│   ├── drainer                        : Application that reads Redis streams and executes queries in database\n│   ├── external_services              : Interactions with external systems like emails, AWS KMS, etc.\n│   ├── masking                        : Personal Identifiable Information protection\n│   ├── redis_interface                : A user-friendly interface to Redis\n│   ├── router                         : Main crate of the project\n│   ├── router_derive                  : Utility macros for the `router` crate\n│   ├── router_env                     : Environment of payment router: logger, basic config, its environment awareness\n│   ├── scheduler                      : Scheduling and executing deferred tasks like mail scheduling\n│   ├── storage_impl                   : Storage layer implementations for data structures & objects\n│   └── test_utils                     : Utilities to run Postman and connector UI tests\n├── docs                               : hand-written documentation\n├── loadtest                           : performance benchmarking setup\n├── migrations                         : diesel DB setup\n├── monitoring                         : Grafana & Loki monitoring related configuration files\n├── openapi                            : automatically generated OpenAPI spec\n├── postman                            : postman scenarios API\n└── scripts                            : automation, testing, and other utility scripts\n```",
    "prompt": "Describe the directory structure of the Hyperswitch repository, focusing on the purpose of the `crates` subdirectory.",
    "constraints": "List the main top-level directories and elaborate on the contents and purpose of at least five sub-crates.",
    "expected_output": "The Hyperswitch repository has a well-defined directory structure. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"77\" end=\"114\" /> Top-level directories include `config` for router startup files, `connector-template` for boilerplate code, `crates` for sub-crates, `docs` for documentation, `loadtest` for performance benchmarking, `migrations` for database setup, `monitoring` for Grafana & Loki configurations, `openapi` for generated OpenAPI spec, `postman` for Postman scenarios, and `scripts` for utilities. <cite/> The `crates` subdirectory contains various sub-crates, such as `api_models` for request/response models, `common_enums` for shared enums, `diesel_models` for database models, `router` as the main project crate, and `storage_impl` for storage layer implementations. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md",
      "crates/router/",
      "crates/api_models/",
      "crates/common_enums/",
      "crates/diesel_models/",
      "crates/storage_impl/"
    ]
  },
  {
    "id": "exp_063",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "#### Commit message guidelines\n\nEach commit message consists of a header, an optional body, and an optional\nfooter.\n\n```text\n<header>\n<BLANK LINE>\n<optional body>\n<BLANK LINE>\n<optional footer>\n```\n\nThe `header` is mandatory and must conform to the",
    "prompt": "What are the required components of a commit message according to the contributing guidelines?",
    "constraints": "Explain the structure and mandatory parts.",
    "expected_output": "According to the contributing guidelines, each commit message must consist of a mandatory `header`, an optional `body`, and an optional `footer`. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"317\" end=\"331\" /> The structure is defined as `<header>`, followed by a blank line, then `<optional body>`, another blank line, and finally `<optional footer>`. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md"
    ]
  },
  {
    "id": "exp_064",
    "file_path": "docs/CONTRIBUTING.md",
    "task_type": "code_understanding",
    "context_code": "The following is the list of supported scopes:\n\n- `masking`\n- `router`\n- `router_derive`\n- `router_env`\n\nThere are currently a few exceptions to the \"use crate name\" rule:\n\n- `changelog`: Used for updating the release notes in the `CHANGELOG.md` file.\n  Commonly used with the `docs` commit type\n  (e.g. `docs(changelog): generate release notes for v0.4.0 release`).\n- `config`: Used for changes which affect the configuration files of any of the\n  services.\n- `migrations`: Used for changes to the database migration scripts.\n- `openapi`: Used for changes to the OpenAPI specification file.\n- `postman`: Used for changes to the Postman collection file.\n- none/empty string: Useful for test and refactor changes that are done across\n  all crates (e.g. `test: add missing unit tests`) and for docs changes that are\n  not related to a specific crate (e.g. `docs: fix typo in tutorial`).",
    "prompt": "What are the supported scopes for commit messages, and what are the exceptions to the 'use crate name' rule?",
    "constraints": "List both supported scopes and exceptions with their descriptions.",
    "expected_output": "The supported scopes for commit messages include `masking`, `router`, `router_derive`, and `router_env`. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"379\" end=\"384\" /> Exceptions to the 'use crate name' rule are `changelog` for updating release notes, `config` for changes to configuration files, `migrations` for database migration scripts, `openapi` for OpenAPI specification file changes, `postman` for Postman collection file changes, and an empty string for cross-crate test/refactor changes or general documentation updates. <cite repo=\"juspay/hyperswitch\" path=\"docs/CONTRIBUTING.md\" start=\"386\" end=\"398\" />",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "docs/CONTRIBUTING.md"
    ]
  },
  {
    "id": "exp_065",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_understanding",
    "context_code": "impl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsCaptureData>\n    for PaymentResponse\n{\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<F, types::PaymentsCaptureData, types::PaymentsResponseData>,\n        key_store: &domain::MerchantKeyStore,\n        storage_scheme: enums::MerchantStorageScheme,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b + Send,\n    {\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            key_store,\n            storage_scheme,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }",
    "prompt": "What is the purpose of the `update_tracker` method within the `PaymentResponse` implementation of the `PostUpdateTracker` trait?",
    "constraints": "Explain in simple terms, focusing on its role in the payment processing flow.",
    "expected_output": "The `update_tracker` method in the `PaymentResponse` implementation is responsible for updating the payment data after a payment capture operation. <cite/> It calls the `payment_response_update_tracker` function to perform the actual update logic, which likely involves persisting changes to the database based on the `router_data` (containing the connector's response) and returning the modified `PaymentData`. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payment_response_update_tracker"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs",
      "crates/router/src/core/payments/helpers.rs"
    ]
  },
  {
    "id": "exp_066",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_understanding",
    "context_code": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails, payments::RequestSurchargeDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{",
    "prompt": "What is the significance of `PaymentIntentUpdateFields` in the context of payment updates?",
    "constraints": "Focus on its role in modifying payment intent data.",
    "expected_output": "`PaymentIntentUpdateFields` is a type from `hyperswitch_domain_models::payments::payment_intent` that likely encapsulates the specific fields of a `PaymentIntent` that can be modified during a payment update operation. <cite/> This allows for a structured way to define and apply changes to an existing payment intent, ensuring that only permissible fields are altered. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "PaymentIntentUpdateFields"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/hyperswitch_domain_models/src/payments/payment_intent.rs"
    ]
  },
  {
    "id": "exp_067",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "pub use hyperswitch_domain_models::{ \n    payment_address::PaymentAddress,\n    router_data::{ \n        AccessToken, AccessTokenAuthenticationResponse, AdditionalPaymentMethodConnectorResponse,\n        BillingDetails, ConnectorAuthType, ConnectorResponseData, CustomerInfo, ErrorResponse,\n        GooglePayPaymentMethodDetails, GooglePayPredecryptDataInternal, L2L3Data, OrderInfo,\n        PaymentMethodBalance, PaymentMethodToken, RecurringMandatePaymentData, RouterData, TaxInfo,\n    },\n    router_data_v2::{\n        AccessTokenFlowData, AuthenticationTokenFlowData, DisputesFlowData,\n        ExternalAuthenticationFlowData, FilesFlowData, MandateRevokeFlowData, PaymentFlowData,\n        RefundFlowData, RouterDataV2, UasFlowData, WebhookSourceVerifyData,\n    },\n    router_request_types::{",
    "prompt": "Explain the distinction between `RouterData` and `RouterDataV2` as imported in this file.",
    "constraints": "Highlight the architectural reason for having both.",
    "expected_output": "`RouterData` and `RouterDataV2` represent different versions of the core data structure used for communication with connectors. <cite/> `RouterData` is likely part of the V1 data model, while `RouterDataV2` signifies an evolution towards a V2 architecture, which might involve changes like global identifiers, simplified routing logic, and streamlined data structures, as indicated in the wiki. <cite/> This allows for a transition to an improved data model while maintaining compatibility with existing V1 components. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "RouterData",
        "RouterDataV2"
      ]
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/hyperswitch_domain_models/src/router_data.rs",
      "crates/hyperswitch_domain_models/src/router_data_v2.rs"
    ]
  },
  {
    "id": "exp_068",
    "file_path": "crates/hyperswitch_interfaces/src/api/payments.rs",
    "task_type": "code_understanding",
    "context_code": "/// trait PaymentSession\npub trait PaymentSession:\n    api::ConnectorIntegration<Session, PaymentsSessionData, PaymentsResponseData>\n{\n}\n\n/// trait MandateSetup\npub trait MandateSetup:\n    api::ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentAuthorize\npub trait PaymentAuthorize:\n    api::ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentCapture\npub trait PaymentCapture:\n    api::ConnectorIntegration<Capture, PaymentsCaptureData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentSync\npub trait PaymentSync:\n    api::ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>\n{\n}",
    "prompt": "What is the role of the `PaymentAuthorize` trait and how does it relate to `api::ConnectorIntegration`?",
    "constraints": "Explain the generic parameters used.",
    "expected_output": "The `PaymentAuthorize` trait defines the contract for connectors that support payment authorization. <cite/> It extends `api::ConnectorIntegration`, specializing it with `Authorize` as the flow type, `PaymentsAuthorizeData` as the request data, and `PaymentsResponseData` as the response data. <cite/> This means any connector implementing `PaymentAuthorize` must provide logic for handling authorization requests, transforming `PaymentsAuthorizeData` into a connector-specific format, and converting the connector's response back into `PaymentsResponseData`. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "ConnectorIntegration",
        "Authorize",
        "PaymentsAuthorizeData",
        "PaymentsResponseData"
      ]
    },
    "related_files": [
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/hyperswitch_interfaces/src/api.rs"
    ]
  },
  {
    "id": "exp_069",
    "file_path": "crates/hyperswitch_interfaces/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    router_data::{AccessToken, AccessTokenAuthenticationResponse},\n    router_data_v2::flow_common_types,\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n        files::{Retrieve, Upload},\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, AuthorizeSessionToken, Balance, CalculateTax, Capture, CompleteAuthorize,\n            CreateConnectorCustomer, CreateOrder, ExtendAuthorization, IncrementalAuthorization,\n            InitPayment, PSync, PaymentMethodToken, PostCaptureVoid, PostProcessing,\n            PostSessionTokens, PreProcessing, SdkSessionUpdate, Session, SetupMandate,\n            UpdateMetadata, Void,\n        },\n        refunds::{Execute, RSync},\n        revenue_recovery::{BillingConnectorPaymentsSync, InvoiceRecordBack},\n        subscriptions::{",
    "prompt": "What is the purpose of the `router_flow_types` module and how does it contribute to the overall architecture?",
    "constraints": "Explain its role in categorizing different payment-related operations.",
    "expected_output": "The `router_flow_types` module, imported from `hyperswitch_domain_models`, serves as a central enumeration and categorization of all possible payment-related operations and their associated data flows within the Hyperswitch system. <cite/> It defines distinct types like `Authorize`, `Capture`, `Refunds::Execute`, `MandateRevoke`, etc., which are used as phantom types in `RouterData` to ensure type-safe and flow-specific handling of requests and responses across different connectors. <cite/> This modular approach helps in orchestrating complex payment lifecycles and integrating diverse connector APIs consistently. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "router_flow_types",
        "Authorize",
        "Capture",
        "Refunds"
      ]
    },
    "related_files": [
      "crates/hyperswitch_interfaces/src/types.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types.rs"
    ]
  },
  {
    "id": "exp_070",
    "file_path": "crates/router/src/core/payments/flows/authorize_flow.rs",
    "task_type": "code_understanding",
    "context_code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\nuse common_utils::{id_type, types::MinorUnit, ucs_types};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{\n    errors::api_error_response::ApiErrorResponse, payments as domain_payments,\n    router_response_types,\n};\nuse hyperswitch_interfaces::{api as api_interface, api::ConnectorSpecifications};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\n// use router_env::tracing::Instrument;\nuse super::{ConstructFlowSpecificData, Feature};\nuse crate::{",
    "prompt": "What is the role of `unified_connector_service_client` and `unified_connector_service_masking` in this file?",
    "constraints": "Explain their purpose in relation to connector interactions.",
    "expected_output": "`unified_connector_service_client` and `unified_connector_service_masking` are used for interacting with a Unified Connector Service (UCS). <cite/> `unified_connector_service_client` likely provides the client-side implementation for making gRPC calls to the UCS, specifically for payment-related operations (`payments_grpc`). <cite/> `unified_connector_service_masking` probably provides utilities for handling sensitive data (masking) when communicating with the UCS, ensuring PCI compliance and data security. <cite/> This suggests that some connector interactions are offloaded to a separate, unified service. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payments_grpc",
        "ExposeInterface"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/flows/authorize_flow.rs",
      "crates/unified_connector_service_client/",
      "crates/unified_connector_service_masking/"
    ]
  },
  {
    "id": "exp_071",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{mandates, payment_address};\nuse payment_methods::helpers::StorageErrorExt;\nuse rustc_hash::FxHashSet;\n\n#[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\nuse storage_impl::redis::cache;\n\n#[cfg(feature = \"payouts\")]\nuse super::payouts;\nuse super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, utils::ValueExt};\nuse crate::{",
    "prompt": "How does the `payments_routing` module contribute to the overall routing logic in Hyperswitch?",
    "constraints": "Focus on its organizational role within the `routing` module.",
    "expected_output": "The `payments_routing` module, imported as `self as payments_routing` within the `routing` module, is specifically dedicated to handling the routing logic for payment operations. <cite/> This modularization indicates that payment routing is a distinct and complex concern, separated from other potential routing functionalities (e.g., for payouts, if the `payouts` feature is enabled). <cite/> It likely contains functions and structures that determine which connector to use for a given payment based on various criteria. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": [
        "payments_routing"
      ]
    },
    "related_files": [
      "crates/router/src/core/routing.rs",
      "crates/router/src/core/payments/routing.rs"
    ]
  },
  {
    "id": "exp_072",
    "file_path": "crates/router/tests/payments.rs",
    "task_type": "code_understanding",
    "context_code": "let actual_response = Box::pin(payments::payments_core::< \n    api::Authorize,\n    api::PaymentsResponse,\n    _,\n    _,\n    _,\n    payments::PaymentData<api::Authorize>,\n>(\n    state.clone(),\n    state.get_req_state(),\n    merchant_context,\n    None,\n    payments::PaymentCreate,\n    req,\n    services::AuthFlow::Merchant,\n    payments::CallConnectorAction::Trigger,\n    None,\n    None,\n    hyperswitch_domain_models::payments::HeaderPayload::default(),\n))\n.await\n.unwrap();\nassert_eq!(expected_response, actual_response);",
    "prompt": "What is the purpose of the `payments::payments_core` function call in this test case?",
    "constraints": "Explain the role of the generic parameters and arguments.",
    "expected_output": "The `payments::payments_core` function call is the central entry point for processing payment operations in Hyperswitch. <cite/> In this test case, it's being used to simulate a payment creation and authorization flow. <cite/> The generic parameters `api::Authorize` and `api::PaymentsResponse` specify the flow type (authorization) and the expected response type. <cite/> The arguments include the application state, merchant context, the `PaymentCreate` operation, the request payload (`req`), the authentication flow, and `CallConnectorAction::Trigger`, indicating that a connector call should be made. <cite/> This function orchestrates the entire payment processing pipeline, from validation to connector interaction and state updates. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "payments_core",
        "PaymentCreate",
        "CallConnectorAction::Trigger"
      ]
    },
    "related_files": [
      "crates/router/tests/payments.rs",
      "crates/router/src/core/payments.rs"
    ]
  },
  {
    "id": "exp_073",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "pub use hyperswitch_domain_models::router_flow_types::{\n    self,\n    access_token_auth::AccessTokenAuth,\n    dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n    files::{Retrieve, Upload},\n    mandate_revoke::MandateRevoke,\n    payments::{\n        Approve, Authorize, AuthorizeSessionToken, Balance, CalculateTax, Capture,\n        CompleteAuthorize, CreateConnectorCustomer, CreateOrder, ExtendAuthorization,\n        ExternalVaultProxy, IncrementalAuthorization, InitPayment, PSync, PostCaptureVoid,\n        PostProcessing, PostSessionTokens, PreProcessing, Reject, SdkSessionUpdate, Session,\n        SetupMandate, UpdateMetadata, Void,\n    },\n    refunds::{Execute, RSync},\n    webhooks::VerifyWebhookSource,\n};",
    "prompt": "What is the purpose of the `router_flow_types` module and what kind of operations does it define for payments and refunds?",
    "constraints": "Explain the module's role in the overall architecture and list the specific payment and refund operations it includes.",
    "expected_output": "The `router_flow_types` module defines various flow types that represent different operations within the Hyperswitch system, particularly for payments and refunds. <cite/> It acts as a central place to declare the types of actions that can be performed. <cite/> For payments, it includes operations like `Authorize`, `Capture`, `PSync` (Payment Synchronization), `CompleteAuthorize`, `Session`, `SetupMandate`, `Void`, `CreateOrder`, `PostProcessing`, `PreProcessing`, `Approve`, `Reject`, `UpdateMetadata`, `ExtendAuthorization`, `IncrementalAuthorization`, `InitPayment`, `PostCaptureVoid`, `PostSessionTokens`, `SdkSessionUpdate`, `CreateConnectorCustomer`, `AuthorizeSessionToken`, `Balance`, `CalculateTax`, and `ExternalVaultProxy`. <cite/> For refunds, it defines `Execute` and `RSync` (Refund Synchronization). <cite/> It also includes types for `AccessTokenAuth`, `Dispute` operations (`Accept`, `Defend`, `Dsync`, `Evidence`, `Fetch`), `Files` operations (`Retrieve`, `Upload`), `MandateRevoke`, and `VerifyWebhookSource`. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/hyperswitch_interfaces/src/types.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types.rs"
    ]
  },
  {
    "id": "exp_074",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_understanding",
    "context_code": "let m_db = state.clone().store;\nlet m_key_store = key_store.clone();\nlet m_payment_data_payment_intent = payment_data.payment_intent.clone();\nlet m_payment_intent_update = payment_intent_update.clone();\nlet key_manager_state: KeyManagerState = state.into();\nlet payment_intent_fut = tokio::spawn(\n    async move {\n        m_db.update_payment_intent(\n            &key_manager_state,\n            m_payment_data_payment_intent,\n            m_payment_intent_update,\n            &m_key_store,\n            storage_scheme,\n        )\n        .map(|x| x.to_not_found_response(errors::ApiErrorResponse::PaymentNotFound))\n        .await\n    }\n    .in_current_span(),\n);",
    "prompt": "What is the purpose of the `payment_intent_fut` future and how does it interact with the database and key management?",
    "constraints": "Explain the role of `tokio::spawn`, `KeyManagerState`, and `storage_scheme` in this operation.",
    "expected_output": "The `payment_intent_fut` future is responsible for asynchronously updating a `PaymentIntent` in the database. <cite/> It uses `tokio::spawn` to execute this update concurrently without blocking the current thread. <cite/> The update operation requires a `KeyManagerState` for handling encryption/decryption of sensitive data, the `PaymentIntent` data itself, the specific `payment_intent_update` to apply, the `merchant_key_store` for merchant-specific keys, and the `storage_scheme` to determine whether to interact with PostgreSQL directly or via RedisKv. <cite/> The `.map(|x| x.to_not_found_response(errors::ApiErrorResponse::PaymentNotFound))` part handles potential `PaymentNotFound` errors during the update. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "update_payment_intent",
        "to_not_found_response"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs",
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/router/src/db/kafka_store.rs"
    ]
  },
  {
    "id": "exp_075",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_understanding",
    "context_code": "use super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n        mandate::helpers as m_helpers,\n        payment_methods::cards::create_encrypted_data,\n        payments::{self, helpers, operations, CustomerDetails, PaymentAddress, PaymentData},\n        utils as core_utils,\n    },\n    events::audit_events::{AuditEvent, AuditEventType},\n    routes::{app::ReqState, SessionState},\n    services,\n    types::{\n        self,\n        api::{self, ConnectorCallType, PaymentIdTypeExt},\n        domain,\n        storage::{self, enums as storage_enums, payment_attempt::PaymentAttemptExt},\n        transformers::ForeignTryFrom,\n    },\n    utils::OptionExt,\n};",
    "prompt": "What are the key modules and types imported into the `payment_update.rs` file, and what do they suggest about its functionality?",
    "constraints": "Focus on the purpose of each imported module/type in the context of payment updates.",
    "expected_output": "The `payment_update.rs` file imports several key modules and types, indicating its role in handling payment updates. <cite/> It imports `super::{Operation, UpdateTracker, ValidateRequest}` for defining the payment operation's lifecycle. <cite/> From `crate::core`, it brings in `errors` for error handling, `mandate::helpers` for mandate-related utilities, `payment_methods::cards::create_encrypted_data` for handling sensitive card data, and `payments::{helpers, operations, CustomerDetails, PaymentAddress, PaymentData}` which are central to payment processing, customer details, and payment data management. <cite/> It also imports `audit_events` for logging, `routes::{app::ReqState, SessionState}` for application state and session management, and `services` for external service interactions. <cite/> The `types` module provides API definitions (`api`), domain models (`domain`), storage-related enums and traits (`storage`, `storage_enums`, `payment_attempt::PaymentAttemptExt`), and data transformation utilities (`transformers::ForeignTryFrom`). <cite/> These imports collectively suggest that `payment_update.rs` is involved in a complex process of updating payment intents, potentially involving sensitive data, mandates, and interactions with various parts of the system and external services. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "create_encrypted_data"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/router/src/core/payments/helpers.rs",
      "crates/router/src/core/payment_methods/cards.rs"
    ]
  },
  {
    "id": "exp_076",
    "file_path": "crates/hyperswitch_connectors/src/utils.rs",
    "task_type": "code_understanding",
    "context_code": "use api_models::{\n    payments,\n    payments::{additional_info::WalletAdditionalDataForCard, ApplepayPaymentMethod},\n};\nuse base64::Engine;\nuse common_enums::{\n    enums,\n    enums::{\n        AlbaniaStatesAbbreviation, AndorraStatesAbbreviation, AttemptStatus,\n        AustraliaStatesAbbreviation, AustriaStatesAbbreviation, BelarusStatesAbbreviation,\n        BelgiumStatesAbbreviation, BosniaAndHerzegovinaStatesAbbreviation,\n        BrazilStatesAbbreviation, BulgariaStatesAbbreviation, CanadaStatesAbbreviation,\n        CroatiaStatesAbbreviation, CzechRepublicStatesAbbreviation, DenmarkStatesAbbreviation,\n        FinlandStatesAbbreviation, FranceStatesAbbreviation, FutureUsage,\n        GermanyStatesAbbreviation, GreeceStatesAbbreviation, HungaryStatesAbbreviation,\n        IcelandStatesAbbreviation, IndiaStatesAbbreviation, IrelandStatesAbbreviation,\n        ItalyStatesAbbreviation, JapanStatesAbbreviation, LatviaStatesAbbreviation,\n        LiechtensteinStatesAbbreviation, LithuaniaStatesAbbreviation, LuxembourgStatesAbbreviation,\n        MaltaStatesAbbreviation, MoldovaStatesAbbreviation, MonacoStatesAbbreviation,\n        MontenegroStatesAbbreviation, NetherlandsStatesAbbreviation, NewZealandStatesAbbreviation,\n        NorthMacedoniaStatesAbbreviation, NorwayStatesAbbreviation, PhilippinesStatesAbbreviation,\n        PolandStatesAbbreviation, PortugalStatesAbbreviation, RomaniaStatesAbbreviation,\n        RussiaStatesAbbreviation, SanMarinoStatesAbbreviation, SerbiaStatesAbbreviation,\n        SingaporeStatesAbbreviation, SlovakiaStatesAbbreviation, SloveniaStatesAbbreviation,\n        SpainStatesAbbreviation, SwedenStatesAbbreviation, SwitzerlandStatesAbbreviation,\n        ThailandStatesAbbreviation, UkraineStatesAbbreviation, UnitedKingdomStatesAbbreviation,\n        UsStatesAbbreviation,\n    },\n};\nuse common_utils::{\n    consts::BASE64_ENGINE,\n    errors::{CustomResult, ParsingError, ReportSwitchExt},\n    ext_traits::{OptionExt, StringExt, ValueExt},\n    id_type,\n    pii::{self, Email, IpAddress},\n    types::{AmountConvertor, MinorUnit},\n};",
    "prompt": "What is the primary purpose of the `crates/hyperswitch_connectors/src/utils.rs` file based on its imports?",
    "constraints": "Identify the main categories of utilities and data types it provides.",
    "expected_output": "The `crates/hyperswitch_connectors/src/utils.rs` file primarily serves as a utility module for connector-related functionalities. <cite/> Its imports suggest it provides: 1. **Payment-related API models**: `api_models::payments` for payment requests and responses, including specific types like `WalletAdditionalDataForCard` and `ApplepayPaymentMethod`. <cite/> 2. **Base64 encoding/decoding**: `base64::Engine` for handling base64 operations. <cite/> 3. **Common enumerations**: `common_enums::enums` for various system-wide enumerations, including `AttemptStatus` and a comprehensive list of state abbreviations for different countries, indicating a need for geographical data handling. <cite/> 4. **Common utilities**: `common_utils` for constants (`BASE64_ENGINE`), error handling (`CustomResult`, `ParsingError`, `ReportSwitchExt`), extension traits (`OptionExt`, `StringExt`, `ValueExt`), ID types (`id_type`), PII handling (`pii`, `Email`, `IpAddress`), and amount conversion (`AmountConvertor`, `MinorUnit`). <cite/> Overall, this file seems to consolidate common tools and data structures necessary for the various payment connectors to function correctly, especially concerning data transformation, error reporting, and handling of diverse geographical and payment-specific data. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/utils.rs",
      "crates/api_models/src/payments.rs",
      "crates/common_enums/src/enums.rs",
      "crates/common_utils/src/lib.rs"
    ]
  },
  {
    "id": "exp_077",
    "file_path": "crates/router/src/core/routing.rs",
    "task_type": "code_understanding",
    "context_code": "use super::{\n    errors::RouterResult,\n    payments::{\n        routing::{\n            utils::*,\n            {self as payments_routing},\n        },\n        OperationSessionGetters,\n    },\n};\n#[cfg(feature = \"v1\")]\nuse crate::utils::ValueExt;\n#[cfg(feature = \"v2\")]\nuse crate::{core::admin, utils::ValueExt};\nuse crate::{\n    core::{\n        errors::{self, CustomResult, RouterResponse},\n        metrics, utils as core_utils,\n    },\n    db::StorageInterface,\n    routes::SessionState,\n    services::api as service_api,\n    types::{\n        api, domain,\n        storage::{self, enums as storage_enums},\n        transformers::{ForeignInto, ForeignTryFrom},\n    },\n    utils::{self, OptionExt},\n};",
    "prompt": "What are the core responsibilities of the `crates/router/src/core/routing.rs` module, and how does it handle different API versions (v1 vs v2)?",
    "constraints": "Explain the module's role in payment routing and how it adapts to different API versions.",
    "expected_output": "The `crates/router/src/core/routing.rs` module is responsible for orchestrating payment routing logic within the Hyperswitch system. <cite/> It imports `payments::routing` for specific routing utilities and `OperationSessionGetters` for retrieving session-related data. <cite/> The module adapts to different API versions (`v1` and `v2`) using conditional compilation (`#[cfg(feature = \"v1\")]` and `#[cfg(feature = \"v2\")]`). <cite/> For both versions, it uses `crate::utils::ValueExt` for value manipulation. <cite/> Additionally, for `v2`, it imports `crate::core::admin`, suggesting that `v2` routing might involve administrative configurations. <cite/> The module also relies on `errors` for result handling, `metrics` for performance tracking, `core_utils` for general utilities, `db::StorageInterface` for database interactions, `routes::SessionState` for session management, `services::api` for service-level API interactions, and various `types` for API definitions, domain models, storage enums, and data transformations. <cite/> This indicates a comprehensive role in determining how payments are processed and routed, with specific considerations for API versioning. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/core/routing.rs",
      "crates/router/src/core/payments/routing/utils.rs",
      "crates/router/src/db/mod.rs",
      "crates/router/src/types.rs"
    ]
  },
  {
    "id": "exp_078",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_understanding",
    "context_code": "let m_db = state.clone().store;\nlet m_key_store = key_store.clone();\nlet m_payment_data_payment_intent = payment_data.payment_intent.clone();\nlet m_payment_intent_update = payment_intent_update.clone();\nlet key_manager_state: KeyManagerState = state.into();\nlet payment_intent_fut = tokio::spawn(\n    async move {\n        m_db.update_payment_intent(\n            &key_manager_state,\n            m_payment_data_payment_intent,\n            m_payment_intent_update,\n            &m_key_store,\n            storage_scheme,\n        )\n        .map(|x| x.to_not_found_response(errors::ApiErrorResponse::PaymentNotFound))\n        .await\n    }\n    .in_current_span(),\n);",
    "prompt": "How does the system update a payment intent after a connector response, specifically regarding the use of `KeyManagerState` and asynchronous operations?",
    "constraints": "Explain the role of `KeyManagerState` and the asynchronous nature of the update.",
    "expected_output": "The system updates a payment intent by first cloning the database store, key store, and payment intent data. <cite/> A `KeyManagerState` is derived from the current state. <cite/> The actual update operation, `m_db.update_payment_intent`, is then spawned as an asynchronous task using `tokio::spawn`. <cite/> This task uses the `KeyManagerState` to handle encryption/decryption of sensitive data during the update, ensuring data security. <cite/> The `payment_intent_update` contains the changes to be applied to the payment intent. <cite/> The asynchronous execution allows the system to perform other tasks while waiting for the database update to complete, improving overall performance and responsiveness. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "update_payment_intent",
        "tokio::spawn"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs",
      "crates/storage_impl/src/payments/payment_intent.rs"
    ]
  },
  {
    "id": "exp_079",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "pub use hyperswitch_domain_models::router_flow_types::{\n    self,\n    access_token_auth::AccessTokenAuth,\n    dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n    files::{Retrieve, Upload},\n    mandate_revoke::MandateRevoke,\n    payments::{\n        Approve, Authorize, AuthorizeSessionToken, Balance, CalculateTax, Capture,\n        CompleteAuthorize, CreateConnectorCustomer, CreateOrder, ExtendAuthorization,\n        ExternalVaultProxy, IncrementalAuthorization, InitPayment, PSync, PostCaptureVoid,\n        PostProcessing, PostSessionTokens, PreProcessing, Reject, SdkSessionUpdate, Session,\n        SetupMandate, UpdateMetadata, Void,\n    },\n    refunds::{Execute, RSync},\n    webhooks::VerifyWebhookSource,\n};",
    "prompt": "What is the purpose of `router_flow_types` and how does it contribute to the modularity of payment processing in Hyperswitch?",
    "constraints": "Explain the role of the different flow types listed.",
    "expected_output": "`router_flow_types` defines a comprehensive set of distinct operations or 'flows' that can occur within the payment processing lifecycle. <cite/> Each enum variant, such as `Authorize`, `Capture`, `PSync`, `Refunds::Execute`, and `MandateRevoke`, represents a specific action or stage in a payment transaction. <cite/> This modular design allows Hyperswitch to handle various payment scenarios and connector integrations in a structured and type-safe manner. <cite/> By categorizing operations into these flows, the system can apply specific business logic and connector interactions relevant to each stage, enhancing maintainability and extensibility. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs"
    ]
  },
  {
    "id": "exp_080",
    "file_path": "crates/router/src/core/payments/operations/payment_update.rs",
    "task_type": "code_understanding",
    "context_code": "use std::marker::PhantomData;\n\nuse api_models::{\n    enums::FrmSuggestion, mandates::RecurringDetails, payments::RequestSurchargeDetails,\n};\nuse async_trait::async_trait;\nuse common_utils::{\n    ext_traits::{AsyncExt, Encode, ValueExt},\n    pii::Email,\n    types::keymanager::KeyManagerState,\n};\nuse error_stack::{report, ResultExt};\nuse hyperswitch_domain_models::payments::payment_intent::{\n    CustomerData, PaymentIntentUpdateFields,\n};\nuse router_derive::PaymentOperation;\nuse router_env::{instrument, tracing};\n\nuse super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest};\nuse crate::{",
    "prompt": "What are the key traits and modules imported at the beginning of `payment_update.rs` and what do they suggest about the functionality of this file?",
    "constraints": "Focus on the purpose of the imported traits and modules.",
    "expected_output": "The `payment_update.rs` file imports several key traits and modules that indicate its role in handling payment intent updates. <cite/> `PhantomData` is used for type parameter markers. <cite/> `api_models` brings in API-specific models like `FrmSuggestion` and `RecurringDetails`. <cite/> `async_trait` enables asynchronous trait methods. <cite/> `common_utils` provides utilities for extensions, encoding, and `KeyManagerState` for handling sensitive data. <cite/> `error_stack` is for robust error handling. <cite/> `hyperswitch_domain_models` imports `PaymentIntentUpdateFields` and `CustomerData`, which are central to modifying payment intents. <cite/> `router_derive::PaymentOperation` suggests this file implements a payment operation. <cite/> Finally, `super::{BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest}` indicates that this file is part of a larger operation pattern, implementing specific phases like validation, data retrieval, business logic, and state updates for payment modifications. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "validate_request",
        "get_trackers",
        "update_tracker"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/router/src/core/payments/operations.rs",
      "crates/hyperswitch_domain_models/src/payments/payment_intent.rs"
    ]
  },
  {
    "id": "exp_081",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_understanding",
    "context_code": "rm $conn.rs-e $src/types/api/connector_mapping.rs-e $src/configs/settings.rs-e config/development.toml-e config/docker_compose.toml-e config/config.example.toml-e loadtest/config/development.toml-e crates/api_models/src/connector_enums.rs-e crates/euclid/src/enums.rs-e crates/api_models/src/routing.rs-e $src/core/payments/flows.rs-e crates/common_enums/src/connector_enums.rs-e $src/types/connector_transformers.rs-e $src/core/admin.rs-e crates/hyperswitch_connectors/src/default_implementations.rs-e crates/hyperswitch_connectors/src/default_implementations_v2.rs-e crates/hyperswitch_interfaces/src/configs.rs-e $src/connector.rs-e config/deployments/integration_test.toml-e config/deployments/production.toml-e config/deployments/sandbox.toml-e temp crates/connector_configs/src/connector.rs-e",
    "prompt": "What is the purpose of the `rm` command in the `add_connector.sh` script, and why are so many files listed with the `-e` suffix?",
    "constraints": "Explain the function of the command and the significance of the `-e` suffix.",
    "expected_output": "The `rm` command in the `add_connector.sh` script is used to remove temporary files that were created during the connector generation process. <cite/> The `-e` suffix on each file name, such as `$conn.rs-e` or `$src/types/api/connector_mapping.rs-e`, indicates that these are backup files created by `sed -i'' -e` commands. <cite/> The `sed -i'' -e` command is used for in-place editing of files, and the `''` (empty string) after `-i` tells `sed` to create a backup of the original file with the `-e` extension before modifying it. <cite/> This `rm` command cleans up these temporary backup files after the script has finished its modifications. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh"
    ]
  },
  {
    "id": "exp_082",
    "file_path": "add_connector.md",
    "task_type": "code_understanding",
    "context_code": "The `BillwerkErrorResponse` struct serves as the intermediate data structure that bridges Billwerk's API error format and Hyperswitch's internal error representation. The method essentially consumes the struct and produces Hyperswitch's standardized error format. All connectors implement a similar pattern to ensure uniform error handling.",
    "prompt": "How does Hyperswitch ensure uniform error handling across different payment connectors, as described in the `add_connector.md` documentation?",
    "constraints": "Explain the pattern used for error handling.",
    "expected_output": "Hyperswitch ensures uniform error handling across different payment connectors by using an intermediate data structure, like `BillwerkErrorResponse`, to bridge the connector's specific API error format with Hyperswitch's internal standardized `ErrorResponse` format. <cite/> Each connector implements a similar pattern where a method consumes this connector-specific error struct and transforms it into Hyperswitch's `ErrorResponse`. <cite/> This standardization allows the core system to process errors consistently, regardless of the originating connector, and provides appropriate fallbacks for missing error details. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "get_error_response",
        "get_5xx_error_response"
      ]
    },
    "related_files": [
      "add_connector.md",
      "crates/hyperswitch_connectors/src/connectors/billwerk.rs",
      "crates/router/src/services/api.rs"
    ]
  },
  {
    "id": "exp_083",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};",
    "prompt": "What types of payment and refund operations does the `calida` connector support, based on the imported `router_flow_types`?",
    "constraints": "List the specific payment and refund flow types.",
    "expected_output": "Based on the imported `router_flow_types`, the `calida` connector supports a variety of payment and refund operations. <cite/> For payments, it supports `Authorize`, `Capture`, `PSync` (Payment Synchronization), `PaymentMethodToken` (Tokenization), `Session`, `SetupMandate`, and `Void`. <cite/> For refunds, it supports `Execute` (Refund Execution) and `RSync` (Refund Synchronization). <cite/> It also supports `AccessTokenAuth` for obtaining access tokens. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/calida.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs"
    ]
  },
  {
    "id": "exp_084",
    "file_path": "crates/hyperswitch_connectors/src/connectors/cybersource.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        mandate_revoke::MandateRevoke,\n        payments::{\n            Authorize, Capture, CompleteAuthorize, IncrementalAuthorization, PSync,\n            PaymentMethodToken, Session, SetupMandate, Void,\n        },\n        refunds::{Execute, RSync},\n        Authenticate, PostAuthenticate, PreAuthenticate, PreProcessing,\n    },\n    router_request_types::{\n        AccessTokenRequestData, CompleteAuthorizeData, MandateRevokeRequestData,\n        PaymentMethodTokenizationData, PaymentsAuthenticateData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsIncrementalAuthorizationData,\n        PaymentsPostAuthenticateData, PaymentsPreAuthenticateData, PaymentsPreProcessingData,\n        PaymentsSessionData, PaymentsSyncData, RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, MandateRevokeResponseData, PaymentMethodDetails, PaymentsResponseData,\n        RefundsResponseData, SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        MandateRevokeRouterData, PaymentsAuthenticateRouterData, PaymentsAuthorizeRouterData,\n        PaymentsCancelRouterData, PaymentsCaptureRouterData, PaymentsCompleteAuthorizeRouterData,\n        PaymentsIncrementalAuthorizationRouterData, PaymentsPostAuthenticateRouterData,\n        PaymentsPreAuthenticateRouterData, PaymentsPreProcessingRouterData, PaymentsSyncRouterData,\n        RefundExecuteRouterData, RefundSyncRouterData, SetupMandateRouterData,\n    },\n};",
    "prompt": "What authentication-related flow types are supported by the `cybersource` connector, and what do they imply about its capabilities?",
    "constraints": "List the authentication flow types and their general meaning.",
    "expected_output": "The `cybersource` connector supports several authentication-related flow types: `Authenticate`, `PostAuthenticate`, `PreAuthenticate`, and `PreProcessing`. <cite/> These imply that Cybersource can handle various stages of customer authentication, likely including 3D Secure (3DS) flows. <cite/> `PreAuthenticate` would involve initial steps before authentication, `Authenticate` the actual authentication process, and `PostAuthenticate` any follow-up actions after authentication. <cite/> `PreProcessing` suggests it can perform preliminary checks or data preparation before the main payment authorization or authentication begins. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/cybersource.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs"
    ]
  },
  {
    "id": "exp_085",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "pub mod api;\npub mod authentication;\npub mod connector_transformers;\npub mod domain;\n#[cfg(feature = \"frm\")]\npub mod fraud_check;\npub mod payment_methods;\npub mod pm_auth;\nuse masking::Secret;\npub mod storage;\npub mod transformers;\nuse std::marker::PhantomData;\n\npub use api_models::{enums::Connector, mandates};\n#[cfg(feature = \"payouts\")]\npub use api_models::{enums::PayoutConnectors, payouts as payout_types};\n#[cfg(feature = \"v2\")]\nuse common_utils::errors::CustomResult;\npub use common_utils::{pii, pii::Email, request::RequestContent, types::MinorUnit};\n#[cfg(feature = \"v2\")]\nuse error_stack::ResultExt;\n#[cfg(feature = \"frm\")]\npub use hyperswitch_domain_models::router_data_v2::FrmFlowData;\nuse hyperswitch_domain_models::router_flow_types::{\n    self,\n    access_token_auth::AccessTokenAuth,\n    dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n    files::{Retrieve, Upload},\n    mandate_revoke::MandateRevoke,\n    payments::{\n        Approve, Authorize, AuthorizeSessionToken, Balance, CalculateTax, Capture,\n        CompleteAuthorize, CreateConnectorCustomer, CreateOrder, ExtendAuthorization,\n        ExternalVaultProxy, IncrementalAuthorization, InitPayment, PSync, PostCaptureVoid,\n        PostProcessing, PostSessionTokens, PreProcessing, Reject, SdkSessionUpdate, Session,\n        SetupMandate, UpdateMetadata, Void,\n    },\n    refunds::{Execute, RSync},\n    webhooks::VerifyWebhookSource,\n};",
    "prompt": "What is the purpose of the `crates/router/src/types.rs` file and how does it contribute to the overall structure of the Hyperswitch router?",
    "constraints": "Explain the role of the `pub mod` declarations and `pub use` statements in this file.",
    "expected_output": "The `crates/router/src/types.rs` file serves as a central hub for type definitions and module re-exports within the `router` crate. <cite/> It organizes various related types into sub-modules like `api`, `authentication`, `domain`, `payment_methods`, and `storage` using `pub mod` declarations. <cite/> This modular approach helps in separating concerns and maintaining a clean codebase. <cite/> The `pub use` statements then re-export commonly used types and enums from other crates, such as `api_models` and `hyperswitch_domain_models`, making them easily accessible throughout the `router` crate without requiring verbose paths. <cite/> For example, `api_models::enums::Connector` and various payment flow types like `Authorize` and `Capture` are re-exported here, simplifying their usage in payment processing logic. <cite/> This file essentially acts as an entry point for many critical data structures and flow definitions used across the router. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/api_models/src/payments.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs"
    ]
  },
  {
    "id": "exp_086",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_understanding",
    "context_code": "impl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsCaptureData>\n    for PaymentResponse\n{\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<F, types::PaymentsCaptureData, types::PaymentsResponseData>,\n        key_store: &domain::MerchantKeyStore,\n        storage_scheme: enums::MerchantStorageScheme,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b + Send,\n    {\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            key_store,\n            storage_scheme,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n}",
    "prompt": "What is the role of the `update_tracker` method in the `PaymentResponse` implementation of `PostUpdateTracker`?",
    "constraints": "Explain how `payment_data` is updated and what parameters are involved.",
    "expected_output": "The `update_tracker` method in the `PaymentResponse` implementation of `PostUpdateTracker` is responsible for updating the `PaymentData` after a payment operation, specifically for capture data in this context. <cite/> It takes the current `SessionState`, mutable `PaymentData`, `RouterData` containing the capture request and response, `MerchantKeyStore`, `MerchantStorageScheme`, and optional `locale` as input. <cite/> It delegates the actual update logic to the `payment_response_update_tracker` function, passing all relevant data. <cite/> The `payment_data` is then updated with the result of this asynchronous operation. <cite/> This ensures that the payment's state and associated data are consistently maintained across the system after a capture event. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payment_response_update_tracker"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs",
      "crates/router/src/core/payments/operations/payment_update.rs",
      "crates/router/src/types.rs"
    ]
  },
  {
    "id": "exp_087",
    "file_path": "crates/router/src/core/payments/flows/authorize_flow.rs",
    "task_type": "code_understanding",
    "context_code": "use std::str::FromStr;\n\nuse async_trait::async_trait;\nuse common_enums as enums;\nuse common_types::payments as common_payments_types;\nuse common_utils::{id_type, types::MinorUnit, ucs_types};\nuse error_stack::ResultExt;\nuse hyperswitch_domain_models::{payments as domain_payments, router_response_types};\nuse hyperswitch_interfaces::{api as api_interface, api::ConnectorSpecifications};\nuse masking::ExposeInterface;\nuse unified_connector_service_client::payments as payments_grpc;\nuse unified_connector_service_masking::ExposeInterface as UcsMaskingExposeInterface;\n\nuse super::{ConstructFlowSpecificData, Feature};\nuse crate::{\n    core::{\n        errors::{ConnectorErrorExt, RouterResult},\n        mandate,\n        payments::{\n            self, access_token, customers, helpers, tokenization, transformers, PaymentData,\n        },\n        unified_connector_service::{\n            self, build_unified_connector_service_auth_metadata,\n            get_access_token_from_ucs_response,\n            handle_unified_connector_service_response_for_payment_authorize,\n            handle_unified_connector_service_response_for_payment_repeat, set_access_token_for_ucs,\n            ucs_logging_wrapper,\n        },\n    },\n    logger,\n    routes::{metrics, SessionState},\n    services::{self, api::ConnectorValidation},\n    types::{\n        self, api, domain,\n        transformers::{ForeignFrom, ForeignTryFrom},\n    },\n    utils::OptionExt,\n};",
    "prompt": "What are the key components and dependencies involved in the `authorize_flow.rs` file, and what is its primary responsibility?",
    "constraints": "Focus on the `use` statements and the overall purpose of the file in the payment authorization process.",
    "expected_output": "The `authorize_flow.rs` file is central to handling payment authorization within Hyperswitch. <cite/> It relies on several key components and dependencies, as indicated by its `use` statements. <cite/> It imports core functionalities like `async_trait` for asynchronous operations, `common_enums` for shared enumerations, and `error_stack` for robust error handling. <cite/> Crucially, it leverages `hyperswitch_domain_models` for payment-related domain entities and `hyperswitch_interfaces` for connector specifications. <cite/> Within the `core` module, it depends on `errors`, `mandate`, and various `payments` sub-modules for access tokens, customer management, helpers, tokenization, and data transformations. <cite/> A significant dependency is the `unified_connector_service` module, which provides functions for building authentication metadata, handling responses, and setting access tokens for unified connector interactions. <cite/> The file's primary responsibility is to orchestrate the authorization process, including preparing request data, interacting with connectors (potentially through a unified service), and processing their responses to determine the outcome of a payment authorization. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "handle_unified_connector_service_response_for_payment_authorize",
        "build_unified_connector_service_auth_metadata"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/flows/authorize_flow.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/router/src/core/unified_connector_service.rs"
    ]
  },
  {
    "id": "exp_088",
    "file_path": "crates/storage_impl/src/payments/payment_attempt.rs",
    "task_type": "code_understanding",
    "context_code": "#[cfg(feature = \"v1\")]\n#[instrument(skip_all)]\nasync fn find_attempts_by_merchant_id_payment_id(\n    &self,\n    merchant_id: &common_utils::id_type::MerchantId,\n    payment_id: &common_utils::id_type::PaymentId,\n    storage_scheme: MerchantStorageScheme,\n) -> error_stack::Result<Vec<PaymentAttempt>, errors::StorageError> {\n    let storage_scheme = Box::pin(decide_storage_scheme::<_, DieselPaymentAttempt>(\n        self,\n        storage_scheme,\n        Op::Find,\n    ))\n    .await;\n    match storage_scheme {\n        MerchantStorageScheme::PostgresOnly => {\n            self.router_store\n                .find_attempts_by_merchant_id_payment_id(\n                    merchant_id,\n                    payment_id,\n                    storage_scheme,\n                )\n                .await\n        }\n        MerchantStorageScheme::RedisKv => {\n            let key = PartitionKey::MerchantIdPaymentId {\n                merchant_id,\n                payment_id,\n            };\n            Box::pin(try_redis_get_else_try_database_get(\n                async {\n                    Box::pin(kv_wrapper(\n                        self,\n                        KvOperation::<DieselPaymentAttempt>::Scan(\"pa_*\"),\n                        key,\n                    ))\n                    .await?\n                    .try_into_scan()\n                },\n                || async {\n                    self.router_store\n                        .find_attempts_by_merchant_id_payment_id(\n                            merchant_id,\n                            payment_id,\n                            storage_scheme,\n                        )\n                        .await\n                },\n            ))\n            .await\n        }\n    }\n}",
    "prompt": "How does the `find_attempts_by_merchant_id_payment_id` function handle different storage schemes when retrieving payment attempts?",
    "constraints": "Explain the logic for `PostgresOnly` and `RedisKv` schemes.",
    "expected_output": "The `find_attempts_by_merchant_id_payment_id` function in `crates/storage_impl/src/payments/payment_attempt.rs` dynamically handles different storage schemes for retrieving payment attempts. <cite/> First, it determines the effective `MerchantStorageScheme` using `decide_storage_scheme`. <cite/> Then, it uses a `match` statement to branch its logic based on the scheme. <cite/> If the `storage_scheme` is `PostgresOnly`, it directly calls `self.router_store.find_attempts_by_merchant_id_payment_id` to fetch data from the PostgreSQL database. <cite/> If the `storage_scheme` is `RedisKv`, it attempts to retrieve the data from Redis first. <cite/> It constructs a `PartitionKey::MerchantIdPaymentId` and uses `kv_wrapper` with a `Scan` operation to query Redis. <cite/> If the data is not found in Redis, or if there's an error, it falls back to fetching the data from the PostgreSQL database by calling `self.router_store.find_attempts_by_merchant_id_payment_id` as a secondary option. <cite/> This dual-storage approach optimizes performance by leveraging Redis for faster access while ensuring data persistence in PostgreSQL. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": [
        "decide_storage_scheme",
        "kv_wrapper",
        "try_redis_get_else_try_database_get"
      ]
    },
    "related_files": [
      "crates/storage_impl/src/payments/payment_attempt.rs",
      "crates/router/src/db/kafka_store.rs",
      "docs/architecture.md"
    ]
  },
  {
    "id": "exp_089",
    "file_path": "crates/hyperswitch_interfaces/src/api/payments.rs",
    "task_type": "code_understanding",
    "context_code": "/// trait PaymentSession\npub trait PaymentSession:\n    api::ConnectorIntegration<Session, PaymentsSessionData, PaymentsResponseData>\n{\n}\n\n/// trait MandateSetup\npub trait MandateSetup:\n    api::ConnectorIntegration<SetupMandate, SetupMandateRequestData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentAuthorize\npub trait PaymentAuthorize:\n    api::ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentCapture\npub trait PaymentCapture:\n    api::ConnectorIntegration<Capture, PaymentsCaptureData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentSync\npub trait PaymentSync:\n    api::ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>\n{\n}",
    "prompt": "What is the purpose of these trait definitions like `PaymentSession`, `MandateSetup`, `PaymentAuthorize`, `PaymentCapture`, and `PaymentSync` in the `crates/hyperswitch_interfaces/src/api/payments.rs` file?",
    "constraints": "Explain how they relate to `api::ConnectorIntegration` and what role they play in defining connector capabilities.",
    "expected_output": "These trait definitions in `crates/hyperswitch_interfaces/src/api/payments.rs` serve as contracts for various payment-related operations that connectors can implement. <cite/> Each trait, such as `PaymentSession`, `MandateSetup`, `PaymentAuthorize`, `PaymentCapture`, and `PaymentSync`, extends the `api::ConnectorIntegration` trait. <cite/> This means that any connector implementing these specific traits must provide an implementation for the `ConnectorIntegration` methods, tailored to the particular payment flow (e.g., `Session`, `SetupMandate`, `Authorize`, `Capture`, `PSync`) and its corresponding request and response data types (e.g., `PaymentsSessionData`, `PaymentsResponseData`). <cite/> This design enforces a standardized interface across different payment service providers, allowing the Hyperswitch router to interact with various connectors uniformly, regardless of their internal implementation details. <cite/> It effectively defines the capabilities a connector must support for each payment lifecycle stage. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
      "crates/hyperswitch_interfaces/src/types.rs",
      "add_connector.md"
    ]
  },
  {
    "id": "exp_090",
    "file_path": "crates/api_models/src/payments.rs",
    "task_type": "code_understanding",
    "context_code": "pub struct SdkNextActionData {\n    pub next_action: NextActionCall,\n    pub order_id: Option<String>,\n}",
    "prompt": "What is the purpose of the `SdkNextActionData` struct and what information does it hold?",
    "constraints": "Explain in simple terms, focusing on its fields.",
    "expected_output": "The `SdkNextActionData` struct is used to represent data related to the next action required in an SDK-based payment flow. <cite/> It contains two fields: `next_action`, which specifies the actual next action to be performed (of type `NextActionCall`), and `order_id`, an optional string that can hold an order identifier. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "crates/api_models/src/payments.rs"
    ]
  },
  {
    "id": "exp_091",
    "file_path": "crates/router/src/core/payments/operations/payment_response.rs",
    "task_type": "code_understanding",
    "context_code": "impl<F: Clone> PostUpdateTracker<F, PaymentData<F>, types::PaymentsCaptureData>\n    for PaymentResponse\n{\n    async fn update_tracker<'b>(\n        &'b self,\n        db: &'b SessionState,\n        mut payment_data: PaymentData<F>,\n        router_data: types::RouterData<F, types::PaymentsCaptureData, types::PaymentsResponseData>,\n        key_store: &domain::MerchantKeyStore,\n        storage_scheme: enums::MerchantStorageScheme,\n        locale: &Option<String>,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] routable_connector: Vec<\n            RoutableConnectorChoice,\n        >,\n        #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))] business_profile: &domain::Profile,\n    ) -> RouterResult<PaymentData<F>>\n    where\n        F: 'b + Send,\n    {\n        payment_data = Box::pin(payment_response_update_tracker(\n            db,\n            payment_data,\n            router_data,\n            key_store,\n            storage_scheme,\n            locale,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            routable_connector,\n            #[cfg(all(feature = \"v1\", feature = \"dynamic_routing\"))]\n            business_profile,\n        ))\n        .await?;\n\n        Ok(payment_data)\n    }\n}",
    "prompt": "What is the role of the `update_tracker` method within the `PaymentResponse` implementation of the `PostUpdateTracker` trait?",
    "constraints": "Explain its purpose and what parameters it takes.",
    "expected_output": "The `update_tracker` method in the `PaymentResponse` implementation of `PostUpdateTracker` is responsible for updating the payment data after a payment operation, specifically for capture data. <cite/> It takes the current `SessionState` (database connection), `PaymentData` (current payment state), `RouterData` containing the connector's response, `MerchantKeyStore` (for encryption/decryption), `MerchantStorageScheme` (storage strategy), `locale` (for localization), and optionally `routable_connector` and `business_profile` for V1 dynamic routing features. <cite/> It calls `payment_response_update_tracker` to perform the actual update logic and returns the modified `PaymentData`. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": [
        "payment_response_update_tracker"
      ]
    },
    "related_files": [
      "crates/router/src/core/payments/operations/payment_response.rs",
      "crates/router/src/core/payments/operations.rs",
      "crates/router/src/types.rs"
    ]
  },
  {
    "id": "exp_092",
    "file_path": "crates/router/src/types.rs",
    "task_type": "code_understanding",
    "context_code": "pub use hyperswitch_domain_models::router_flow_types::{ \n    self,\n    access_token_auth::AccessTokenAuth,\n    dispute::{Accept, Defend, Dsync, Evidence, Fetch},\n    files::{Retrieve, Upload},\n    mandate_revoke::MandateRevoke,\n    payments::{\n        Approve, Authorize, AuthorizeSessionToken, Balance, CalculateTax, Capture,\n        CompleteAuthorize, CreateConnectorCustomer, CreateOrder, ExtendAuthorization,\n        ExternalVaultProxy, IncrementalAuthorization, InitPayment, PSync, PostCaptureVoid,\n        PostProcessing, PostSessionTokens, PreProcessing, Reject, SdkSessionUpdate, Session,\n        SetupMandate, UpdateMetadata, Void,\n    },\n    refunds::{Execute, RSync},\n    webhooks::VerifyWebhookSource,\n};",
    "prompt": "What is the significance of the `router_flow_types` module being re-exported here, and what kind of payment-related operations are defined within it?",
    "constraints": "List the payment-related operations and explain why this re-export is important.",
    "expected_output": "The `router_flow_types` module is re-exported to make various payment-related flow types easily accessible throughout the `router` crate without requiring verbose import paths. <cite/> It defines a comprehensive set of payment operations including: `Approve`, `Authorize`, `AuthorizeSessionToken`, `Balance`, `CalculateTax`, `Capture`, `CompleteAuthorize`, `CreateConnectorCustomer`, `CreateOrder`, `ExtendAuthorization`, `ExternalVaultProxy`, `IncrementalAuthorization`, `InitPayment`, `PSync` (Payment Synchronization), `PostCaptureVoid`, `PostProcessing`, `PostSessionTokens`, `PreProcessing`, `Reject`, `SdkSessionUpdate`, `Session`, `SetupMandate`, `UpdateMetadata`, and `Void`. <cite/> For refunds, it includes `Execute` and `RSync` (Refund Synchronization). <cite/> It also includes types for `AccessTokenAuth`, dispute operations (`Accept`, `Defend`, `Dsync`, `Evidence`, `Fetch`), file operations (`Retrieve`, `Upload`), `MandateRevoke`, and `VerifyWebhookSource`. <cite/> This re-export is important because it centralizes access to all flow type definitions, making the codebase more maintainable and ensuring consistent usage across the router. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/router/src/types.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs"
    ]
  },
  {
    "id": "exp_093",
    "file_path": "scripts/add_connector.sh",
    "task_type": "code_understanding",
    "context_code": "cargo generate --path ../../../../connector-template -n $payment_gateway\n\nmv $payment_gateway/mod.rs $payment_gateway.rs\nmkdir -p ../../../router/tests/connectors\nmv \"$payment_gateway/test.rs\" ../../../router/tests/connectors/$payment_gateway.rs",
    "prompt": "What is the purpose of these shell commands in the `add_connector.sh` script?",
    "constraints": "Explain the steps involved in creating and organizing files for a new connector.",
    "expected_output": "These shell commands are part of the `add_connector.sh` script, which automates the process of adding a new payment connector to Hyperswitch. <cite/> First, `cargo generate --path ../../../../connector-template -n $payment_gateway` uses the connector template to generate the basic structure for the new connector, naming it after the `$payment_gateway` variable. <cite/> Then, `mv $payment_gateway/mod.rs $payment_gateway.rs` renames the main module file from `mod.rs` to `$payment_gateway.rs` to follow Rust's module naming conventions. <cite/> Next, `mkdir -p ../../../router/tests/connectors` creates the necessary directory structure for connector tests (the `-p` flag ensures parent directories are created if they don't exist). <cite/> Finally, `mv \"$payment_gateway/test.rs\" ../../../router/tests/connectors/$payment_gateway.rs` moves the generated test file into the connector tests directory. <cite/>",
    "metadata": {
      "difficulty": "easy",
      "related_functions": []
    },
    "related_files": [
      "scripts/add_connector.sh",
      "add_connector.md"
    ]
  },
  {
    "id": "exp_094",
    "file_path": "crates/hyperswitch_connectors/src/connectors/calida.rs",
    "task_type": "code_understanding",
    "context_code": "use hyperswitch_domain_models::{\n    payment_method_data::PaymentMethodData,\n    router_data::{AccessToken, ConnectorAuthType, ErrorResponse, RouterData},\n    router_flow_types::{\n        access_token_auth::AccessTokenAuth,\n        payments::{Authorize, Capture, PSync, PaymentMethodToken, Session, SetupMandate, Void},\n        refunds::{Execute, RSync},\n    },\n    router_request_types::{\n        AccessTokenRequestData, PaymentMethodTokenizationData, PaymentsAuthorizeData,\n        PaymentsCancelData, PaymentsCaptureData, PaymentsSessionData, PaymentsSyncData,\n        RefundsData, SetupMandateRequestData,\n    },\n    router_response_types::{\n        ConnectorInfo, PaymentMethodDetails, PaymentsResponseData, RefundsResponseData,\n        SupportedPaymentMethods, SupportedPaymentMethodsExt,\n    },\n    types::{\n        PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsSyncRouterData,\n        RefundSyncRouterData, RefundsRouterData,\n    },\n};",
    "prompt": "What are the key `hyperswitch_domain_models` components imported by the `calida` connector, and what do they represent in the context of payment processing?",
    "constraints": "Focus on the types related to `router_data`, `router_flow_types`, `router_request_types`, and `router_response_types`.",
    "expected_output": "The `calida` connector imports several key `hyperswitch_domain_models` components organized into distinct categories. <cite/> From `router_data`, it imports `PaymentMethodData` (payment instrument details), `AccessToken` (authentication tokens), `ConnectorAuthType` (authentication configuration), `ErrorResponse` (standardized error handling), and `RouterData` (the main state container for routing payment requests). <cite/> From `router_flow_types`, it imports various payment flow operations like `Authorize`, `Capture`, `PSync` (Payment Synchronization), `PaymentMethodToken` (tokenization), `Session`, `SetupMandate`, and `Void`, plus refund operations `Execute` and `RSync` (Refund Synchronization), which define the different stages of a payment lifecycle. <cite/> From `router_request_types`, it imports data structures for specific requests: `PaymentsAuthorizeData`, `PaymentsCaptureData`, `PaymentsSyncData`, `RefundsData`, `SetupMandateRequestData`, `PaymentMethodTokenizationData`, `PaymentsSessionData`, `PaymentsCancelData`, and `AccessTokenRequestData`. <cite/> From `router_response_types`, it imports `ConnectorInfo`, `PaymentMethodDetails`, `PaymentsResponseData`, `RefundsResponseData`, `SupportedPaymentMethods`, and `SupportedPaymentMethodsExt` for handling connector responses. <cite/> Finally, from `types`, it imports specific `RouterData` type aliases like `PaymentsAuthorizeRouterData`, `PaymentsCaptureRouterData`, `PaymentsSyncRouterData`, `RefundSyncRouterData`, and `RefundsRouterData` that provide type-safe routing for each operation. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_connectors/src/connectors/calida.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
      "crates/router/src/types.rs"
    ]
  },
  {
    "id": "exp_095",
    "file_path": "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
    "task_type": "code_understanding",
    "context_code": "pub struct Authorize;\n\npub struct AuthorizeSessionToken;\n\npub struct CompleteAuthorize;\n\npub struct Approve;\n\n// Used in gift cards balance check\npub struct Balance;\n\npub struct InitPayment;\n\npub struct Capture;\n\npub struct PSync;\npub struct Void;\n\npub struct PostCaptureVoid;\n\npub struct Reject;\n\npub struct Session;\n\npub struct PaymentMethodToken;\n\npub struct CreateConnectorCustomer;\n\npub struct SetupMandate;\n\npub struct PreProcessing;\n\npub struct IncrementalAuthorization;\n\npub struct ExtendAuthorization;\n\npub struct PostProcessing;\n\npub struct CalculateTax;\n\npub struct SdkSessionUpdate;\n\npub struct PaymentCreateIntent;\n\npub struct PaymentGetIntent;\n\npub struct PaymentUpdateIntent;\n\npub struct PostSessionTokens;\n\npub struct RecordAttempt;\n\npub struct UpdateMetadata;\n\npub struct CreateOrder;\n\npub struct PaymentGetListAttempts;\n\npub struct ExternalVaultProxy;\n\npub struct GiftCardBalanceCheck;",
    "prompt": "What is the purpose of defining these empty structs in `router_flow_types/payments.rs`?",
    "constraints": "Explain the Rust pattern being used and its benefit.",
    "expected_output": "These empty structs, such as `Authorize`, `Capture`, `PSync`, and `Void`, are used as 'phantom types' in Rust. <cite/> They don't hold any data themselves but serve as type-level markers or tags to differentiate between various payment flow types at compile time. <cite/> This pattern allows the `RouterData` generic struct to be specialized for different operations (e.g., `RouterData<Authorize, ...>` vs `RouterData<Capture, ...>`), enabling the compiler to enforce that the correct request and response types are used for each specific payment flow. <cite/> This provides strong compile-time type-checking and helps orchestrate the payment processing pipeline by guiding which connector trait methods should be invoked for a given operation. <cite/>",
    "metadata": {
      "difficulty": "medium",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
      "crates/router/src/types.rs",
      "crates/hyperswitch_interfaces/src/api/payments.rs"
    ]
  },
  {
    "id": "exp_096",
    "file_path": "crates/hyperswitch_interfaces/src/api/payments.rs",
    "task_type": "code_understanding",
    "context_code": "pub trait PaymentAuthorize:\n    api::ConnectorIntegration<Authorize, PaymentsAuthorizeData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentCapture\npub trait PaymentCapture:\n    api::ConnectorIntegration<Capture, PaymentsCaptureData, PaymentsResponseData>\n{\n}\n\n/// trait PaymentSync\npub trait PaymentSync:\n    api::ConnectorIntegration<PSync, PaymentsSyncData, PaymentsResponseData>\n{\n}",
    "prompt": "How do the `PaymentAuthorize`, `PaymentCapture`, and `PaymentSync` traits relate to the `api::ConnectorIntegration` trait, and what is their significance?",
    "constraints": "Explain the role of `ConnectorIntegration` and the specific flow types.",
    "expected_output": "The `PaymentAuthorize`, `PaymentCapture`, and `PaymentSync` traits are 'marker traits' that extend the `api::ConnectorIntegration` trait. <cite/> They signify that a connector implementing these traits supports the respective payment operations: authorization, capture, and synchronization. <cite/> The `api::ConnectorIntegration` trait is a generic trait that takes three type parameters: a flow type (e.g., `Authorize`, `Capture`, `PSync`), the request data type (e.g., `PaymentsAuthorizeData`), and the response data type (e.g., `PaymentsResponseData`). <cite/> By extending `ConnectorIntegration` with specific flow types, these traits ensure that any connector implementing them will provide the necessary logic and data transformations for that particular payment operation, enforcing a standardized interface across different payment service providers. <cite/>",
    "metadata": {
      "difficulty": "hard",
      "related_functions": []
    },
    "related_files": [
      "crates/hyperswitch_interfaces/src/api/payments.rs",
      "crates/hyperswitch_domain_models/src/router_flow_types/payments.rs",
      "crates/router/src/types.rs"
    ]
  }
]